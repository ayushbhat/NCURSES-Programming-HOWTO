<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>NCURSES Programming HOWTO</title>
<!-- 2016-01-14 jue 17:14 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="ppadala" />
<link rel="stylesheet" type="text/css" href="worg-data/worg.css" /
</head>
<body>
<div id="content">
<h1 class="title">NCURSES Programming HOWTO</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Revisión histórica</a></li>
<li><a href="#sec-2">1. Introduccion</a>
<ul>
<li><a href="#sec-2-1">1.1. ¿Qué es Ncurses?</a></li>
<li><a href="#sec-2-2">1.2. Que podemos hacer con Ncurses</a></li>
<li><a href="#sec-2-3">1.3. Dónde conseguirlo</a>
<ul>
<li><a href="#sec-2-3-1"><i>Compilación del paquete</i></a></li>
<li><a href="#sec-2-3-2"><i>Usando el RPM</i></a></li>
</ul>
</li>
<li><a href="#sec-2-4">1.4. Objetivo/Alcance del documento</a></li>
<li><a href="#sec-2-5">15. Acerca de los Programas</a></li>
<li><a href="#sec-2-6">16. Otros formatos del documento</a>
<ul>
<li><a href="#sec-2-6-1">1.6.1. Formatos de fácil acceso desde tldp.org</a></li>
<li><a href="#sec-2-6-2">1.6.2. Construcción desde codigo fuente</a></li>
</ul>
</li>
<li><a href="#sec-2-7">1.7. Créditos</a></li>
<li><a href="#sec-2-8">1.8. Lista de deseos</a></li>
<li><a href="#sec-2-9">1.9. Derechos de autor</a></li>
</ul>
</li>
<li><a href="#sec-3">2. Hola Mundo!!!</a>
<ul>
<li><a href="#sec-3-1">2.1. Compilar con la librería NCURSES</a></li>
<li><a href="#sec-3-2">2.2. Disección</a>
<ul>
<li><a href="#sec-3-2-1">2.2.1. Acerca de initscr()</a></li>
<li><a href="#sec-3-2-2">2.2.2. La misteriosa refresh()</a></li>
<li><a href="#sec-3-2-3">2.2.3. Acerca de endwin()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">3. Los detalles sangrientos</a></li>
<li><a href="#sec-5">4. Inicialización                                                   </a>
<ul>
<li><a href="#sec-5-1">4.1. Funciones de inicialización</a>
<ul>
<li><a href="#sec-5-1-1">4.1.1. <code>raw()</code> and <code>cbreak()</code></a></li>
<li><a href="#sec-5-1-2">4.1.2. <code>echo()</code> and <code>noecho()</code></a></li>
<li><a href="#sec-5-1-3">4.1.3. <code>keypad()</code></a></li>
<li><a href="#sec-5-1-4">4.1.4. <code>halfdelay()</code></a></li>
</ul>
</li>
<li><a href="#sec-5-2">4.2. Otras funciones de inicialización</a></li>
<li><a href="#sec-5-3">4.3. Un ejemplo</a></li>
</ul>
</li>
<li><a href="#sec-6">5. Una indicacion acerca de las Ventanas</a></li>
<li><a href="#sec-7">6. Funciones de Salida</a>
<ul>
<li><a href="#sec-7-1">6.1. Clase de funciones <code>addch()</code></a></li>
<li><a href="#sec-7-2">6.2. <code>mvaddch()</code>, <code>waddch()</code> y <code>mvwaddch()</code></a></li>
<li><a href="#sec-7-3">6.3. Clase de funciones <code>printw()</code></a>
<ul>
<li><a href="#sec-7-3-1">6.3.1. <code>printw()</code> y <code>mvprintw</code></a></li>
<li><a href="#sec-7-3-2">6.3.2. <code>wprintw()</code> y <code>mvwprintw</code></a></li>
<li><a href="#sec-7-3-3">6.3.3. <code>vwprintw()</code></a></li>
<li><a href="#sec-7-3-4">6.3.4. Un ejemplo sencillo de <code>printw</code></a></li>
</ul>
</li>
<li><a href="#sec-7-4">6.4. clase de funciones <code>addstr()</code></a></li>
<li><a href="#sec-7-5">6.5. Una plabra de advertencia</a></li>
</ul>
</li>
<li><a href="#sec-8">7. Funciones de entrada</a>
<ul>
<li><a href="#sec-8-1">7.1. clase de funciones <code>getch()</code></a></li>
<li><a href="#sec-8-2">7.2. clase de funciones <code>scanw()</code></a>
<ul>
<li><a href="#sec-8-2-1">7.2.1. <code>scanw()</code> y <code>mvscanw</code></a></li>
<li><a href="#sec-8-2-2">7.2.2. <code>wscanw()</code> y <code>mvwscanw()</code></a></li>
<li><a href="#sec-8-2-3">7.2.3. <code>vwscanw()</code></a></li>
</ul>
</li>
<li><a href="#sec-8-3">7.3. Clase de funciones <code>getstr()</code></a></li>
<li><a href="#sec-8-4">7.4. Algunos ejemplos</a></li>
</ul>
</li>
<li><a href="#sec-9">8. Atributos                                                        </a>
<ul>
<li><a href="#sec-9-1">8.1. Los detalles</a></li>
<li><a href="#sec-9-2">8.2. <code>attron()</code> vs <code>attrset()</code></a></li>
<li><a href="#sec-9-3">8.3. <code>attr_get()</code></a></li>
<li><a href="#sec-9-4">8.4. funciones <code>attr_</code></a></li>
<li><a href="#sec-9-5">8.5. funciones <code>wattr</code></a></li>
<li><a href="#sec-9-6">8.6. funciones <code>chgat()</code></a></li>
</ul>
</li>
<li><a href="#sec-10">9. Ventanas                                                         </a>
<ul>
<li><a href="#sec-10-1">9.1. Lo basico</a></li>
<li><a href="#sec-10-2">9.2. Que haya una Ventana !!!</a></li>
<li><a href="#sec-10-3">9.3. Explicación</a></li>
<li><a href="#sec-10-4">9.4. Las otras cosas en el ejemplo</a></li>
<li><a href="#sec-10-5">9.5. Otras funciones de Borde</a></li>
</ul>
</li>
<li><a href="#sec-11">10. Colores                                                         </a>
<ul>
<li><a href="#sec-11-1">10.1. Lo basico</a></li>
<li><a href="#sec-11-2">10.2. Cambio en Definiciones de Color</a></li>
<li><a href="#sec-11-3">10.3. Contenido en color</a></li>
</ul>
</li>
<li><a href="#sec-12">11. Comunicandonos con el teclado                                   </a>
<ul>
<li><a href="#sec-12-1">11.1. Lo basico</a></li>
<li><a href="#sec-12-2">11.2. Ejemplo simple de uso de teclado</a></li>
</ul>
</li>
<li><a href="#sec-13">12. Interfaz con el ratón</a>
<ul>
<li><a href="#sec-13-1">12.1. Lo basico</a></li>
<li><a href="#sec-13-2">12.2. Obtención de eventos</a></li>
<li><a href="#sec-13-3">12.3. Poniendo todo junto</a></li>
<li><a href="#sec-13-4">12.4. Funciones varias</a></li>
</ul>
</li>
<li><a href="#sec-14">13. Manipulación de Pantalla</a>
<ul>
<li><a href="#sec-14-1">13.1. funciones <code>getyx()</code></a></li>
<li><a href="#sec-14-2">13.2. Volcado de Pantalla</a></li>
<li><a href="#sec-14-3">13.3. Volcado de Ventana</a></li>
</ul>
</li>
<li><a href="#sec-15">14. Características diversas</a>
<ul>
<li><a href="#sec-15-1">14.1. <code>curs_set()</code></a></li>
<li><a href="#sec-15-2">14.2. Dejar Temporalmente el modo curses</a></li>
<li><a href="#sec-15-3">14.3. Variables <code>ACS_</code></a></li>
</ul>
</li>
<li><a href="#sec-16">15. Otras librerias</a></li>
<li><a href="#sec-17">16. Libreria Panel</a>
<ul>
<li><a href="#sec-17-1">16.1. Lo basico</a></li>
<li><a href="#sec-17-2">16.2. Compilación con la Librería Panel</a></li>
<li><a href="#sec-17-3">16.3. Navegacion en Paneles de Ventana</a></li>
<li><a href="#sec-17-4">16.4. Utilizando punteros de usuario</a></li>
<li><a href="#sec-17-5">16.5. Mover y Redimensionar Paneles</a></li>
<li><a href="#sec-17-6">16.6. Ocultar y Mostrar Paneles</a></li>
<li><a href="#sec-17-7">16.7. Funciones <code>panel_above()</code> y <code>panel_below()</code></a></li>
</ul>
</li>
<li><a href="#sec-18">17. Libreria Menu</a>
<ul>
<li><a href="#sec-18-1">17.1. Lo basico</a></li>
<li><a href="#sec-18-2">17.2. Compilación con la Libreria Menú</a></li>
<li><a href="#sec-18-3">17.3. Menu Driver: El caballo de trabajo del sistema de menus</a></li>
<li><a href="#sec-18-4">17.4. Ventanas de Menu</a></li>
<li><a href="#sec-18-5">17.5. Desplazamiento en Menus</a></li>
<li><a href="#sec-18-6">17.6. Menu de Multiples Columnas</a></li>
<li><a href="#sec-18-7">17.7. Menu de Valores Multiples</a></li>
<li><a href="#sec-18-8">17.8. Opciones de Menu</a></li>
<li><a href="#sec-18-9">17.9. El conveniente Puntero de Usuario</a></li>
</ul>
</li>
<li><a href="#sec-19">18. Libreria Form</a>
<ul>
<li><a href="#sec-19-1">18.1. Lo basico</a></li>
<li><a href="#sec-19-2">18.2. Compilación con la Libreria Form</a></li>
<li><a href="#sec-19-3">18.3. Jugando con Campos</a>
<ul>
<li><a href="#sec-19-3-1">18.3.1. Recuperar el Tamaño y Posicion del campo</a></li>
<li><a href="#sec-19-3-2">18.3.2. Mover el campo</a></li>
<li><a href="#sec-19-3-3">18.3.3. Justificar un campo</a></li>
<li><a href="#sec-19-3-4">18.3.4. Atributos de Visualizacion del Campo</a></li>
<li><a href="#sec-19-3-5">18.3.5. Bits de Opcion de Campo</a></li>
<li><a href="#sec-19-3-6">18.3.6. Estado del Campo</a></li>
<li><a href="#sec-19-3-7">18.3.7. Puntero de Usuario de Campo</a></li>
<li><a href="#sec-19-3-8">18.3.8. Campos de Tamaño Variable</a></li>
</ul>
</li>
<li><a href="#sec-19-4">18.4. Ventanas de Formulario</a></li>
<li><a href="#sec-19-5">18.5. Validación de Campo</a>
<ul>
<li><a href="#sec-19-5-1"><code>TYPE_ALPHA</code></a></li>
<li><a href="#sec-19-5-2"><code>TYPE_ALNUM</code></a></li>
<li><a href="#sec-19-5-3"><code>TYPE_ENUM</code></a></li>
<li><a href="#sec-19-5-4"><code>TYPE_INTEGER</code></a></li>
<li><a href="#sec-19-5-5"><code>TYPE_NUMERIC</code></a></li>
<li><a href="#sec-19-5-6"><code>TYPE_REGEXP</code></a></li>
</ul>
</li>
<li><a href="#sec-19-6">18.6. Controlador del Formulario: El caballo de trabajo del sistema de formularios</a>
<ul>
<li><a href="#sec-19-6-1">18.6.1. Solicitudes de Navegacion por Pagina</a></li>
<li><a href="#sec-19-6-2">18.6.2. Solicitudes de Navegación Entre Campos</a></li>
<li><a href="#sec-19-6-3">18.6.3. Solicitudes de Navegacion dentro del Campo</a></li>
<li><a href="#sec-19-6-4">18.6.4. Solicitudes de Desplazamiento</a></li>
<li><a href="#sec-19-6-5">18.6.5. Solicitudes de Edición</a></li>
<li><a href="#sec-19-6-6">18.6.6. Solicitudes de Peticion</a></li>
<li><a href="#sec-19-6-7">18.6.7. Comandos de aplicacion</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-20">19. Librerias de Widgets y Herramientas</a>
<ul>
<li><a href="#sec-20-1">19.1. CDK (Kit de desarrollo de curses)</a>
<ul>
<li><a href="#sec-20-1-1">19.1.1. Lista de Widgets</a></li>
<li><a href="#sec-20-1-2">19.1.2. Algunas Características Atractivas</a></li>
<li><a href="#sec-20-1-3">19.1.3. Conclusión</a></li>
</ul>
</li>
<li><a href="#sec-20-2">19.2. dialog</a></li>
<li><a href="#sec-20-3">19.3. Módulos curses de Perl CURSES::FORM y CURSES::WIDGETS</a></li>
</ul>
</li>
<li><a href="#sec-21">20. Solo Por Diversion !!!</a>
<ul>
<li><a href="#sec-21-1">20.1. El juego de la vida</a></li>
<li><a href="#sec-21-2">20.2. Cuadrado Mágico</a></li>
<li><a href="#sec-21-3">20.3. Torres de Hanoi</a></li>
<li><a href="#sec-21-4">20.4. Rompecabezas de las Reinas</a></li>
<li><a href="#sec-21-5">20.5. Barajar</a></li>
<li><a href="#sec-21-6">20.6. Tutor de Mecanografia</a></li>
</ul>
</li>
<li><a href="#sec-22">21. Referencias</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Revisión histórica</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Revision 1.9     2005-06-20   Revised by: ppadala

<p>
La licencia se ha cambiado a una licencia estilo MIT utilizada por
Ncurses. Tenga en cuenta que los programas están también
re-licenciados bajo esta.
</p>
</li>

<li>Revision 1.8     2005-06-17   Revised by: ppadala

<p>
Un montón de actualizaciones. Añadidas referencias y ejemplos de
perl. Cambios a ejemplos. Muchos cambios gramaticales y de estilo
al contenido. Cambios en la historia NCURSES.
</p>
</li>

<li>Revision 1.7.1   2002-06-25   Revised by: ppadala

<p>
Se ha añadido un archivo README para la construcción y las
instrucciones para la construcción desde el codigo fuente.
</p>
</li>

<li>Revision 1.7     2002-06-25   Revised by: ppadala

<p>
Añadida sección "Other formats" y un montón de cambios fantasticos
a los programas. Inlining de los programas se ha ido.
</p>
</li>

<li>Revision 1.6.1   2002-02-24   Revised by: ppadala

<p>
Eliminada la vieja sección Changelog, limpieza a los makefiles
</p>
</li>

<li>Revision 1.6     2002-02-16   Revised by: ppadala

<p>
Se han corregido un montón de errores de ortografía, agregó
sección de variables ACS
</p>
</li>

<li>Revision 1.5     2002-01-05   Revised by: ppadala

<p>
Estructura cambiada para presentar TOC adecuado
</p>
</li>

<li>Revision 1.3.1   2001-07-26   Revised by: ppadala

<p>
Párrafo de mantenedores corregido, número de versión estable
Corregido
</p>
</li>

<li>Revision 1.3     2001-07-24   Revised by: ppadala

<p>
Añadido aviso de copyright al documento principal (licencia LDP) y
programas (GPL), corregido <code>printw_example</code>.
</p>
</li>

<li>Revision 1.2     2001-06-05   Revised by: ppadala

<p>
Incorporados los cambios de Ravi. Principalmente a la
introducción, menu, form, y secciones JustForFun
</p>
</li>

<li>Revision 1.1     2001-05-22   Revised by: ppadala

<p>
Se agregó una sección "a word about window", Agregado
<code>scanw_example</code>.
</p>
</li>
</ul>


<div class="italic">
<p>
Este documento pretende ser una guía "Todo en Uno" para la
programación con ncurses y sus bibliotecas hermanas. Nos graduamos
desde un simple programa "Hola Mundo" a una forma más compleja de
manipulación. Se asume una nula experiencia previa en
ncurses. Enviar comentarios a <a href="mailto:ppadala@gmail.com">esta direccion</a>
</p>

</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">1. Introduccion</h2>
<div class="outline-text-2" id="text-2">
<p>
En los viejos tiempos de los terminales de teletipo, los terminales
estaban lejos de las computadoras y se conectaban a ellos a través
de cables seriales. los terminales podrían ser configurados mediante
el envío de una serie de bytes. Todas las capacidades (tales como
mover el cursor a una nueva ubicación, borrar parte de la pantalla,
el desplazamiento de pantalla, cambio de modos, etc.) de los
terminales se puede acceder a través de esta serie de bytes. Estas
secuencias de control generalmente se llaman secuencias de escape,
ya que comenzar con un carácter de escape(0x1B). Incluso hoy en día,
con la adecuada emulación, podemos enviar secuencias de escape a el
emulador y lograr el mismo efecto en una ventana de terminal.
</p>

<p>
Suponga que desea imprimir una línea en color. Pruebe a escribir
esto en su consola.
</p>

<div class="org-src-container">

<pre class="src src-sh">echo "^[[0;31;40mIn Color"
</pre>
</div>

<p>
El primer carácter es un carácter de escape, que aparece como los
caracteres <code>^</code> y <code>[</code>. Para poder imprimirlo, hay que pulsar CTRL+V y
luego la tecla ESC. Todos los demás son caracteres imprimibles
normales.  Usted debe ser capaz de ver la cadena "In Color" en
rojo. Se mantiene de esa forma y para volver de nuevo al tipo de
modo original.
</p>

<div class="org-src-container">

<pre class="src src-sh">echo "^[[0;37;40m"
</pre>
</div>

<p>
Ahora, ¿qué significan estos caracteres mágicos? Difíciles de
comprender?  Incluso podrían ser diferentes para diferentes
terminales. Asi que los diseñadores de UNIX inventaron un mecanismo
denominado <code>termcap</code>. Es un archivo que enumera todas las
capacidades de un terminal en particular, junto con las secuencias
de escape necesarias para conseguir un efecto particular. Años más
tarde, este fue reemplazado por <code>terminfo</code>. Sin ahondar demasiado en
detalles, este mecanismo permite a los programas de aplicación
consultar la base de datos terminfo y obtener los caracteres de
control para ser enviados a un terminal o emulador de terminal.
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1.1. ¿Qué es Ncurses?</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Usted podría preguntarse, el significado de toda esta algarabia
técnica. En el escenario anterior, todos los programas de
aplicación se supone consultan terminfo y realizan las cosas
necesarias (envío de caracteres de control, etc.). Pronto se hizo
difícil gestionar toda esta complejidad y esto dio a luz a
'CURSES'. Curses es un juego de palabras del nombre "cursor
optimization" (optimización del cursor). La libreria Curses forma
un envoltorio para trabajar encima de los códigos de terminal
puros, y proporciona una API (Application Programming Interface)
altamente flexible y eficiente. Proporciona funciones para mover el
cursor, crear ventanas, producir colores, jugar con el ratón,
etc. Los programas de aplicación no necesitan preocuparse por las
capacidades subyacentes del terminal.
</p>

<p>
Entonces, ¿qué es NCURSES? NCURSES es un clon del original Sistem V
Release 4.0 (SVr4) curses. Es una biblioteca de libre disposición,
totalmente compatible con la versión anterior de curses. En breve,
es una libreria de funciones que maneja la pantalla de una
aplicación en terminales de celdas de caracter. En el resto del
documento, la términos curses y ncurses se utilizan
indistintamente.
</p>

<p>
Una historia detallada de NCURSES se puede encontrar en el archivo
NEWS dentro del codigo fuente. El paquete actual es mantenido por
<a href="mailto:dickey@his.com">Thomas Dickey</a>. Puede contactar con los mantenedores en
<a href="mailto:bug-ncurses@gnu.org">bug-ncurses@gnu.org</a>.
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">1.2. Que podemos hacer con Ncurses</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Ncurses no sólo crea una envoltura sobre las capacidades del
terminal, también le da un marco sólido para crear una bonita UI
(User Interface/interfaz de usuario) en modo texto. Proporciona
funciones para crear ventanas etc. Sus bibliotecas hermanas
<code>panel</code>, <code>menu</code> y <code>form</code> proporcionan una extensión a la biblioteca
básica curses. Estas bibliotecas por lo general vienen tambien con
Curses. Uno puede crear aplicaciones que contienen múltiples
ventanas, menús, paneles y formularios. Las ventanas se pueden
manejar independientemente, pueden proporcionar 'deslizabilidad' e
incluso pueden ocultarse.
</p>

<p>
Los menús ofrecen al usuario una fácil opción de selección de
comandos. Los formularios facilitan la entrada de datos y ventanas
de visualización. Los paneles extienden las capacidades de ncurses
para hacer frente a ventanas superpuestas y apiladas.
</p>

<p>
Estas son sólo algunas de las cosas básicas que podemos hacer con
ncurses. A medida que avancemos, veremos todas las capacidades de
estas librerias.
</p>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">1.3. Dónde conseguirlo</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Muy bien, ahora que ya sabes lo que puedes hacer con ncurses, debes
estar ancioso por empezar. Generalmente NCURSES viene con su
distribucion. En caso de que usted no tenga la libreria o quiera
compilar por su cuenta, siga leyendo.
</p>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><i>Compilación del paquete</i></h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
Ncurses pueden obtenerse desde
<a href="ftp://ftp.gnu.org/pub/gnu/ncurses/ncurses.tar.gz">ftp://ftp.gnu.org/pub/gnu/ncurses/ncurses.tar.gz</a> o cualquiera de
los sitios ftp mencionados en <a href="http://www.gnu.org/order/ftp.html">http://www.gnu.org/order/ftp.html</a>.
</p>

<p>
Lea los archivos README e INSTALL para obtener más información
sobre cómo instalarlo. Por lo general, implica las siguientes
operaciones.
</p>

<div class="org-src-container">

<pre class="src src-sh">tar zxvf ncurses&lt;version&gt;.tar.gz  # descomprimir y desempaquetar el archivo
cd ncurses&lt;version&gt;               # ir al directorio
./configure                             # configurar la contruccion de acuerdo
                                        # con su entorno
make                                    # fabricar
su root                                 # como root
make install                            # instalarlo
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><i>Usando el RPM</i></h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
El RPM de NCURSES se puede encontrar y descargar desde
<a href="http://rpmfind.net">http://rpmfind.net</a>.  El RPM se puede instalar con el siguiente
comando después de convertirse en root.
</p>

<div class="org-src-container">

<pre class="src src-sh">rpm -i &lt;downloaded rpm&gt;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">1.4. Objetivo/Alcance del documento</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Este documento pretende ser una guía "Todo en Uno" para la
programación con ncurses y sus librerias hermanas. Nos graduamos
desde un simple programa "Hola Mundo" a una forma más compleja de
manipulación. Se asume una nula experiencia previa en ncurses. La
escritura es informal, pero se proporciona una gran cantidad de
detalles de cada uno de los ejemplos.
</p>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">15. Acerca de los Programas</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Todos los programas en el documento están disponibles en forma de
empaquetado <a href="http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs.tar.gz">aqui</a>. Descomprima y desempaquete. La estructura de
directorios se parece a esto.
</p>

<div class="block">
<p>
<a href="ncurses_programs/">ncurses</a>
   ┬
   ├────&gt; <a href="ncurses_programs/JustForFun">JustForFun</a>     – Solo para programas divertidos
   ├────&gt; <a href="ncurses_programs/basics">basics</a>         – programas basicos
   ├────&gt; <a href="ncurses_programs/demo">demo</a>           – los archivos de salida van a este directorio
   │        ┬
   │        └──────&gt; <a href="ncurses_programs/demo/exe">exe</a> – executables de todos los programas de ejemplo
   ├────&gt; <a href="ncurses_programs/forms">forms</a>          – programas relacionados con la libreria form
   ├────&gt; <a href="ncurses_programs/menus">menus</a>          – programas relacionados con la libreria menu
   ├────&gt; <a href="ncurses_programs/panels">panels</a>         – programas relacionados con la libreria panel
   ├────&gt; <a href="ncurses_programs/perl">perl</a>           – equivalentes en perl de los ejemplos
   │                           (aportados por Anuradha Ratnaweera)
   ├────&gt; <a href="ncurses_programs/Makefile">Makefile</a>       – Makefile del nivel superior
   ├────&gt; <a href="ncurses_programs/README">README</a>         – archivo README del nivel superior. contiene instrucciones
   └────&gt; <a href="ncurses_programs/COPYING">COPYING</a>        – aviso de copyright
</p>

</div>

<p>
Los directorios individuales contienen los siguientes archivos.
</p>

<div class="block">
<p>
Descripción de los archivos en cada directorio
––––––––––––––––––––––––––––––––––––––––––––––
<a href="ncurses_programs/JustForFun">JustForFun</a>
    ┬
    ├────&gt; <a href="ncurses_programs/JustForFun/hanoi.c"><code>hanoi.c</code></a>   – Solucionador de las Torres de Hanoi
    ├────&gt; <a href="ncurses_programs/JustForFun/life.c"><code>life.c</code></a>    – Demostracion de el Juego de la Vida
    ├────&gt; <a href="ncurses_programs/JustForFun/magic.c"><code>magic.c</code></a>   – Constructor del cuadrado mágico
    ├────&gt; <a href="ncurses_programs/JustForFun/queens.c"><code>queens.c</code></a>  – Solucionador del famoso N-Queens
    ├────&gt; <a href="ncurses_programs/JustForFun/shuffle.c"><code>shuffle.c</code></a> – Un juego divertido, si tienes tiempo para matar
    └────&gt; <a href="ncurses_programs/JustForFun/tt.c"><code>tt.c</code></a>      – Un tutor de mecanografía muy trivial
</p>

<p>
<a href="ncurses_programs/basics">basics</a>
  ┬
  ├────&gt; <a href="ncurses_programs/basics/acs_vars.c"><code>acs_vars.c</code></a>            – Ejemplo de Variables ACS_
  ├────&gt; <a href="ncurses_programs/basics/hello_world.c"><code>hello_world.c</code></a>         – Simple programa "Hola Mundo"
  ├────&gt; <a href="ncurses_programs/basics/init_func_example.c"><code>init_func_example.c</code></a>   – Ejemplo de funciones de inicialización
  ├────&gt; <a href="ncurses_programs/basics/key_code.c"><code>key_code.c</code></a>            – Muestra el código de la tecla pulsada
  ├────&gt; <a href="ncurses_programs/basics/mouse_menu.c"><code>mouse_menu.c</code></a>          – Un menú accesible con el ratón
  ├────&gt; <a href="ncurses_programs/basics/other_border.c"><code>other_border.c</code></a>        – Muestra el uso de otras funciones de borde
  │                                 – rt de box ()
  ├────&gt; <a href="ncurses_programs/basics/printw_example.c"><code>printw_example.c</code></a>      – Ejemplo muy simple de printw()
  ├────&gt; <a href="ncurses_programs/basics/scanw_example.c"><code>scanw_example.c</code></a>       – Ejemplo muy simple de getstr()
  ├────&gt; <a href="ncurses_programs/basics/simple_attr.c"><code>simple_attr.c</code></a>         – Un programa que puede imprimir archivos c con
  │                                 – comentarios en atributo
  ├────&gt; <a href="ncurses_programs/basics/simple_color.c"><code>simple_color.c</code></a>        – Un simple ejemplo que muestra colores
  ├────&gt; <a href="ncurses_programs/basics/simple_key.c"><code>simple_key.c</code></a>          – Un menú accesible con las teclas de flecha
  │                                 – ARRIBA, ABAJO
  ├────&gt; <a href="ncurses_programs/basics/temp_leave.c"><code>temp_leave.c</code></a>          – Demostracion de salida temporal del modo curses
  ├────&gt; <a href="ncurses_programs/basics/win_border.c"><code>win_border.c</code></a>          – Muestra creación de ventanas y bordes
  └────&gt; <a href="ncurses_programs/basics/with_chgat.c"><code>with_chgat.c</code></a>          – chgat() ejemplo de uso
</p>

<p>
<a href="ncurses_programs/forms">forms</a>
  ┬
  ├────&gt; <a href="ncurses_programs/forms/form_attrib.c"><code>form_attrib.c</code></a>     – Uso de atributos de campo
  ├────&gt; <a href="ncurses_programs/forms/form_options.c"><code>form_options.c</code></a>    – Uso de opciones de campo
  ├────&gt; <a href="ncurses_programs/forms/form_simple.c"><code>form_simple.c</code></a>     – Un ejemplo sencillo de formulario
  └────&gt; <a href="ncurses_programs/forms/form_win.c"><code>form_win.c</code></a>        – Demo de ventanas asociadas a formularios
</p>

<p>
<a href="ncurses_programs/menus">menus</a>
  ┬
  ├────&gt; <a href="ncurses_programs/menus/menu_attrib.c"><code>menu_attrib.c</code></a>        – Uso de atributos <code>menu</code>
  ├────&gt; <a href="ncurses_programs/menus/menu_item_data.c"><code>menu_item_data.c</code></a>     – Uso de funciones <code>item_name()</code> etc..
  ├────&gt; <a href="ncurses_programs/menus/menu_multi_column.c"><code>menu_multi_column.c</code></a>    Crear menús múlti columna
  ├────&gt; <a href="ncurses_programs/menus/menu_scroll.c"><code>menu_scroll.c</code></a>        – Demuestra capacidad de desplazamiento en menús
  ├────&gt; <a href="ncurses_programs/menus/menu_simple.c"><code>menu_simple.c</code></a>        – Un sencillo menú accesible por las flechas
  ├────&gt; <a href="ncurses_programs/menus/menu_toggle.c"><code>menu_toggle.c</code></a>        – Crea menús de multiples valores y explica
  │                                – <code>REQ_TOGGLE_ITEM</code>
  ├────&gt; <a href="ncurses_programs/menus/menu_userptr.c"><code>menu_userptr.c</code></a>       – Uso del puntero del usuario
  └────&gt; <a href="ncurses_programs/menus/menu_win.c"><code>menu_win.c</code></a>           – Demo de ventanas asociadas a menús
</p>

<p>
<a href="ncurses_programs/panels">panels</a>
  ┬
  ├────&gt; <a href="ncurses_programs/panels/panel_browse.c"><code>panel_browse.c</code></a>    – Panel de navegación a través de pestañas.
  │                             – Uso de puntero de usuario
  ├────&gt; <a href="ncurses_programs/panels/panel_hide.c"><code>panel_hide.c</code></a>      – Ocultación y despliegue de paneles
  ├────&gt; <a href="ncurses_programs/panels/panel_resize.c"><code>panel_resize.c</code></a>    – Mover y cambiar el tamaño de los paneles
  └────&gt; <a href="ncurses_programs/panels/panel_simple.c"><code>panel_simple.c</code></a>    – Un ejemplo de panel sencillo
</p>

<p>
<a href="ncurses_programs/perl">perl</a>
  ┬
  └────&gt; <a href="ncurses_programs/perl/"><code>01-10.pl</code></a>    – Equivalentes Perl de los diez primeros programas de ejemplo
</p>

</div>

<p>
Hay un Makefile de nivel superior en el directorio principal. Este
construye todos los archivos y pone los ejecutables listos para su
uso en el directorio <a href="ncurses_programs/demo/exe">demo/exe</a>. También puede construir los
programas selectivamente mediante el make del directorio
correspondiente. Cada directorio contiene un archivo README
explicando el propósito de cada archivo c en el directorio.
</p>

<p>
Para cada ejemplo, he incluido el nombre de ruta relativo al al
directorio de ejemplos.
</p>

<p>
Si prefiere navegar por los distintos programas, apunte su navegador para
<a href="http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs/">http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs/</a>
</p>

<p>
Todos los programas son liberados bajo la misma licencia usada para
ncurses (estilo MIT). Esto le da la capacidad de hacer cualquier
cosa ademas de reclamar todo como suyo. Siéntase libre de
utilizarlos en sus programas, según convenga.
</p>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">16. Otros formatos del documento</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Esta guía también está disponible en otros formatos varios en el
sitio <a href="http://tldp.org/">tldp.org</a>. Aquí están los enlaces a otros formatos de este
documento.
</p>
</div>
<div id="outline-container-sec-2-6-1" class="outline-4">
<h4 id="sec-2-6-1">1.6.1. Formatos de fácil acceso desde tldp.org</h4>
<div class="outline-text-4" id="text-2-6-1">
<ul class="org-ul">
<li><a href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/pdf/NCURSES-Programming-HOWTO.pdf">Acrobat PDF Format</a>
</li>

<li><a href="http:/www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/ps/NCURSES-Programming-HOWTO.ps.gz">PostScript Format</a>
</li>

<li><a href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html/NCURSES-Programming-HOWTO-html.tar.gz">In Multiple HTML pages</a>
</li>

<li><a href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html_single/NCURSES-Programming-HOWTO.html">In One big HTML format</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-2" class="outline-4">
<h4 id="sec-2-6-2">1.6.2. Construcción desde codigo fuente</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
Si los enlaces anteriores están rotos o si quieres experimentar
con sgml sigue leyendo.
</p>

<ul class="org-ul">
<li>El codigo fuente y los programas en tar y gzip, estan
disponibles en

<p>
<a href="http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/NCURSES-HOWTO/NCURSES-Programming-HOWTO.sgml">http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/NCURSES-HOWTO/NCURSES-Programming-HOWTO.sgml</a>
</p>

<p>
<a href="http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/NCURSES-HOWTO/ncurses_programs.tar.gz">http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/NCURSES-HOWTO/ncurses_programs.tar.gz</a>
</p>
</li>
</ul>

<ul class="org-ul">
<li>Descomprimir <code>ncurses_programs.tar.gz</code> con

<div class="org-src-container">

<pre class="src src-sh">tar zxvf ncurses_programs.tar.gz
</pre>
</div>
</li>
</ul>

<ul class="org-ul">
<li>Utilice jade para crear varios formatos. Por ejemplo, si desea
crear los múltiples archivos html, utilizaría

<div class="org-src-container">

<pre class="src src-sh">jade -t sgml -i html -d &lt;path to docbook html stylesheet&gt; NCURSES-Programming-HOWTO.sgml
</pre>
</div>
</li>
</ul>

<ul class="org-ul">
<li>Para obtener el pdf, primero hay que crear un único archivo html
del HOWTO con

<div class="org-src-container">

<pre class="src src-sh">jade -t sgml -i html -d &lt;path to docbook html stylesheet&gt; -V nochunks NCURSES-Programming-HOWTO.sgml &gt; NCURSES-ONE-BIG-FILE.html
</pre>
</div>
</li>
</ul>

<ul class="org-ul">
<li>A continuación, utilizar htmldoc para conseguir el archivo pdf

<div class="org-src-container">

<pre class="src src-sh">htmldoc --size universal -t pdf --firstpage p1 -f &lt;output file name.pdf&gt; NCURSES-ONE-BIG-FILE.html
</pre>
</div>
</li>
</ul>

<ul class="org-ul">
<li>Para ps, utilizaría

<div class="org-src-container">

<pre class="src src-sh">htmldoc --size universal -t ps --firstpage p1 -f &lt;output file name.ps&gt; NCURSES-ONE-BIG-FILE.html
</pre>
</div>
</li>
</ul>

<p>
Véa <a href="http://www.tldp.org/LDP/LDP-Author-Guide/">LDP Author guide</a> para más detalles. Si todo lo demas falla,
envíeme un correo a <a href="mailto:ppadala@gmail.com">ppadala@gmail.com</a>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">1.7. Créditos</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Doy las gracias a <a href="mailto:sharath_1@usa.net">Sharath</a> y Emre Akbas por ayudarme con algunas
secciones.  La introducción fue escrita inicialmente por
sharath. La Reescribí con algunos extractos tomados de su trabajo
inicial. Emre ayudó a escribir las secciones printw y scanw.
</p>

<p>
Los equivalentes Perl de los programas de ejemplo son aportados por
<a href="mailto:Aratnaweera@virtusa.com">Anuradha Ratnaweera</a>.
</p>

<p>
Luego viene <a href="mailto:parimi@ece.arizona.edu">Ravi Parimi</a>, mi querido amigo, que ha estado en este
proyecto antes de escribir ni una línea. Constantemente me
bombardeado con sugerencias y a revisado pacientemente todo el
texto. Él también comprobo cada programa en Linux y Solaris.
</p>
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">1.8. Lista de deseos</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Esta es la lista de deseos, en orden de prioridad. Si tienes un
deseo o quieres trabajar completando alguno, <a href="mailto:ppadala@gmail.com">enviame</a> un correo.
</p>

<ul class="org-ul">
<li>Añadir ejemplos de últimas partes de la sección de formularios.
</li>
</ul>

<ul class="org-ul">
<li>Preparar una demo que muestre todos los programas y permitir al
usuario navegar a través de la descripción de cada
programa. Dejar compilar a el usuario y ver el programa en
acción. Preferentemente una interfaz basada en diálogo.
</li>
</ul>

<ul class="org-ul">
<li>Agregar información de depuración. Cosas <code>_tracef</code>, <code>_tracemouse</code>.
</li>
</ul>

<ul class="org-ul">
<li>Acceso a termcap, terminfo usando las funciones proporcionadas
por el paquete ncurses.
</li>
</ul>

<ul class="org-ul">
<li>Trabajar en dos terminales simultáneamente.
</li>
</ul>

<ul class="org-ul">
<li>Añadir más cosas a la sección varios.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">1.9. Derechos de autor</h3>
<div class="outline-text-3" id="text-2-9">
<p>
Copyright © 2001 by Pradeep Padala.
</p>

<p>
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, distribute with modifications,
sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the
following conditions:
</p>

<p>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</p>

<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</p>

<p>
Except as contained in this notice, the name(s) of the above
copyright holders shall not be used in advertising or otherwise to
promote the sale, use or other dealings in this Software without
prior written authorization.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">2. Hola Mundo!!!</h2>
<div class="outline-text-2" id="text-3">
<p>
Bienvenido al mundo de curses. Antes de sumergimos en la libreria y
mirar en sus diversas características, vamos a escribir un programa
simple y decir hola al mundo.
</p>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">2.1. Compilar con la librería NCURSES</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Para utilizar las funciones de la libreria ncurses, usted tiene que
incluir ncurses.h en sus programas. Para enlazar el programa con
ncurses la bandera -lncurses debe ser agregada.
</p>

<pre class="example">
#include &lt;ncurses.h&gt;
.
.
.

compilacion y enlace: gcc &lt;archivo de programa&gt; -lncurses
</pre>

<p>
<a href="ncurses_programs/basics/hello_world.c"><b>Ejemplo 1. El Programa Hello World !!!</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

int main()
{
  initscr();                      /* Inicia el modo curses          */
  printw("Hello World !!!");      /* Imprime Hello World            */
  refresh();                      /* Imprimirlo en la pantalla real */
  getch();                        /* Esperar entrada de usuario     */
  endwin();                       /* Terminar el modo curses        */

  return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">2.2. Disección</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Las programa anterior inmprime "Hello World !!!" a la pantalla y
termina. Este programa muestra cómo inicializar curses, manipular
la pantalla y finalizar el modo curses. Vamos a diseccionar línea
por línea.
</p>
</div>
<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">2.2.1. Acerca de initscr()</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
La funcion initscr() inicializa el terminal en modo de curses. En
algunas implementaciones, se borra la pantalla y presenta una
pantalla en blanco. Para cualquier manipulación de pantalla
utilizando el paquete curses este ha de ser llamado primero. Esta
función inicializa el sistema curses y asigna memoria para la
ventana actual (llamanda <code>stdscr</code>) y algunas otras estructuras de
datos. En casos extremos esta función puede fallar por falta de
memoria para almacenar las estructuras de datos de la libreria
curses.
</p>

<p>
Una vez hecho esto, podemos hacer una variedad de inicializaciones
para personalizar nuestros ajustes a curses. Estos detalles serán
explicados <a href="#INIT">Más adelante</a>.
</p>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">2.2.2. La misteriosa refresh()</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
La siguiente línea <code>printw</code> imprime la cadena "Hello World !!!" en
el pantalla. Esta función es análoga al <code>printf</code> normal en todos
aspectos excepto que imprime los datos en una ventana llamada
<code>stdscr</code> en las coordenadas (y,x) actuales. Al inicio nuestras
coordenadas actuales están en 0,0 la cadena se imprime en la
esquina izquierda de la ventana.
</p>

<p>
Esto nos lleva al misterioso <code>refresh()</code>. Cuando llamamos a
<code>printw</code> los datos se escriben realmente a una ventana imaginaria,
esto no actualiza la pantalla todavía. El trabajo de <code>printw</code> es
actualizar algunas banderas y estructuras de datos y escribir los
datos a el buffer correspondiente a <code>stdscr</code>. Con el fin de
mostrar esto en pantalla, deberá llamar a <code>refresh()</code> y decirle al
sistema de curses que debe volcar el contenido en pantalla.
</p>

<p>
La filosofía detrás de todo esto es permitir al programador hacer
varias actualizaciones en la pantalla o ventana imaginaria y hacer
un refresco una vez terminada toda la actualización de pantalla.
<code>refresh()</code> comprueba la ventana y actualiza sólo la porción que
ha cambiado. Esto mejora el rendimiento y también ofrece una mayor
flexibilidad. Pero a veces es frustrante para los principiantes.
Un error común cometido por los principiantes es olvidar llamar a
<code>refresh()</code> después de que hacer algunas actualizacions mediante
funciones de clase <code>printw()</code>. A veces todavía lo olvido añadir :-)
</p>
</div>
</div>
<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3">2.2.3. Acerca de endwin()</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Y, finalmente, no se olvide poner fin al modo curses. De lo
contrario su terminal puede comportarse de forma extraña después
de cerrar el programa. <code>endwin()</code> libera la memoria tomada por el
sub-sistema de curses y sus estructuras de datos y pone el
terminal en modo normal. Esta función debe ser llamada después de
que haya terminado con el modo de curses.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">3. Los detalles sangrientos</h2>
<div class="outline-text-2" id="text-4">
<p>
Ahora que hemos visto cómo escribir un programa sencillo vamos a
entrar en detalles. Hay muchas funciones que ayudan a personalizar
lo que se ve en pantalla y muchas características que pueden tener
un uso completo.
</p>

<p>
Aquí vamos&#x2026;
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">4. Inicialización                                                   <a id="INIT" name="INIT"></a></h2>
<div class="outline-text-2" id="text-5">
<p>
Ahora sabemos que para inicializar el sistema curses la funcion
<code>initscr()</code> ha de ser llamada. Hay funciones que pueden ser llamadas
después de esta inicialización para personalizar nuestra sesión de
curses. Podemos cuestionar al sistema curses para configurar el
terminal en modo raw o inicializar el color o el ratón, etc .. Vamos
a discutir algunas de las funciones que normalmente se llaman
inmediatamente después de <code>initscr()</code>;
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">4.1. Funciones de inicialización</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">4.1.1. <code>raw()</code> and <code>cbreak()</code></h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
Normalmente, el terminal maneja buffers de caracteres que el
usuario escribe hasta que se encuentra una línea nueva o retorno
de carro. Pero la mayoria de programas requiere que los caracteres
estén disponibles tan pronto como los escribe el usuario. Las dos
funciones anteriores se utilizan para desactivar el buffer de
línea. La diferencia entre estas dos funciones es la forma en que
los caracteres de control como suspender (CTRL-Z), interrumpir y
quitar (CTRL-C) se pasan al programa. En el modo <code>raw()</code> los
caracteres pasan directamente al programa sin generar una
señal. En el modo <code>cbreak()</code> estos caracteres de control son
interpretados como cualquier otro carácter por el controlador de
terminal. Personalmente prefiero usar <code>raw()</code> ya que puedo ejercer
un mayor control de lo que hace el usuario.
</p>
</div>
</div>

<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2">4.1.2. <code>echo()</code> and <code>noecho()</code></h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
Estas funciones controlan el eco de caracteres generados por el
usuario al terminal. <code>noecho()</code> desactiva el eco. La posible razón
para hacer esto es mejorar el control sobre el eco o suprimir el
eco innecesario al tomar la entrada del usuario mediante funciones
<code>getch()</code>. La mayor parte de los programas interactivos llaman a
<code>noecho()</code> en la inicialización y realizan el eco de caracteres de
manera controlada. Esto le da al programador la flexibilidad de
imprimir caracteres en cualquier lugar en la ventana sin
actualizar las coordenadas actuales (y, x).
</p>
</div>
</div>

<div id="outline-container-sec-5-1-3" class="outline-4">
<h4 id="sec-5-1-3">4.1.3. <code>keypad()</code></h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
Este es mi función de inicialización favorita. Habilita la lectura
de teclas de función como F1, F2, teclas de direccion, etc. Casi
todos los programa interactivos permiten esto, Las teclas de
dirección son una parte importante de cualquier interfaz de
usuario. Coloque <code>keypad(stdscr, TRUE)</code> para habilitar esta
función en la pantalla (<code>stdscr</code>). Usted aprenderá más sobre
gestión de teclas en secciones posteriores de este documento.
</p>
</div>
</div>

<div id="outline-container-sec-5-1-4" class="outline-4">
<h4 id="sec-5-1-4">4.1.4. <code>halfdelay()</code></h4>
<div class="outline-text-4" id="text-5-1-4">
<p>
Esta función, aunque no se utiliza muy a menudo, en ocaciones
suele ser de utilidad. <code>halfdelay()</code> es llamada para activar el
modo de espera medio, que es similar al modo <code>cbreak()</code> en el que
los caracteres escritos estan disponibles de inmediato para el
programa. Sin embargo, espera 'X' décimas de segundo por la
entrada y luego devuelve <code>ERR</code>, si no hay entrada disponible. 'X'
es el valor de tiempo de espera pasado a la función <code>halfdelay()</code>.
Esta función es útil cuando se pide entrada al usuario, y si no
responde en cierto tiempo, podemos hacer algo más. Un ejemplo
posible es un tiempo de espera en la solicitud de contraseña.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">4.2. Otras funciones de inicialización</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Hay algunas funciones más que se llaman en la inicialización para
personalizar el comportamiento de curses. No se utilizan tan
ampliamente como las mencionadas anteriormente. Algunas de estas se
explican donde es apropiado.
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">4.3. Un ejemplo</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Vamos a escribir un programa que permitirá aclarar el uso de éstas
funciones.
</p>

<p>
<a href="ncurses_programs/basics/init_func_example.c"><b>Ejemplo 2. Funciones de inicialización</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

int main()
{   int ch;

  initscr();                      /* Inicia el modo curses            */
  raw();                          /* Desactiva buffer de linea        */
  keypad(stdscr, TRUE);           /* Obtener F1, F2 etc..d            */
  noecho();                       /* Sin echo() al hacer getch        */

  printw("Pulse cualquier caracter para verlo remarcado\n");
  ch = getch();                   /* Si no ha llamado a raw() tenemos
                                   * que pulsar enter antes que que
                                   * que llegue al programa           */
  if(ch == KEY_F(1))              /* sin habilitar keypad esto no     */
    printw("F1 Key pressed");     /* llegara a nosotros               */
                                  /* Sin noecho() algunos feos
                                   * caracteres de escape podrian ser
                                   * impresos en pantalla             */
  else
    {   printw("La tecla pulsada es ");
        attron(A_BOLD);
        printw("%c", ch);
        attroff(A_BOLD);
    }
  refresh();                      /* Imprime en la pantalla real      */
  getch();                        /* Espera entrada de usuario        */
  endwin();                       /* Termina modo curses              */

  return 0;
}
</pre>
</div>

<p>
Este programa se explica por sí mismo. Pero hago uso de funciones
que aun no se han explicado. La función <code>getch()</code> se utiliza para
obtener un caracter del usuario. Es equivalente un <code>getchar()</code>
normal excepto que puede deshabilitar el buffer de línea para
evitar &lt;enter&gt; después de la entrada. Para más información sobre
<code>getch()</code> y lectura de teclas eche un vistazo a la seccion <a href="#KEYS">gestion
de teclado</a>. Las funciones <code>attron</code> y <code>attroff</code> se utilizan para
cambiar y desactivar algunos atributos respectivamente. En el
ejemplo son usadas para imprimir el carácter en negrita. Estas
funciones se explican en detalle más adelante.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">5. Una indicacion acerca de las Ventanas</h2>
<div class="outline-text-2" id="text-6">
<p>
Antes de sumergirse en las innumerables funciones de ncurses,
permítanme aclarar algunas cosas acerca de las ventanas. Las
ventanas se explican en detalle en la siguientes <a href="#WINDOWS">secciones</a>
</p>

<p>
Una ventana es una pantalla imaginaria definida por el sistema de
curses. una ventana no significa una ventana bordeada que por lo
general se ven en plataformas Win9X. Cuando inicializa curses, se
crea una ventana por defecto llamada <code>stdscr</code> que representa su
pantalla de 80x25 (o el tamaño de ventana en el que se está
ejecutando). Si está realizando tareas simples como imprimir algunas
cadenas, lectura de entrada, etc., puede utilizar con seguridad esta
única ventana para todos los propósitos. También se pueden crear
ventanas y llamar a funciones que trabajan de forma explícita en una
ventana especificada.
</p>

<p>
Por ejemplo, si usted llama a
</p>

<div class="org-src-container">

<pre class="src src-c">printw("Hola ahi !!!");
refresh();
</pre>
</div>

<p>
Imprime la cadena en <code>stdscr</code> en la posicion actual del cursor. Del
mismo modo la llamada a <code>refresh()</code>, funciona sólo en <code>stdscr</code>.
</p>

<p>
Digamos que ha creado <a href="#WINDOWS">ventanas</a> entonces tiene que llamar a
una función con una 'w' añadida a la función habitual.
</p>

<div class="org-src-container">

<pre class="src src-c">wprintw(win, "Hola ahi !!!");
wrefresh(win);
</pre>
</div>

<p>
Como se verá en el resto del documento, Los nombres de funcione
siguen la misma convención. Para cada función por lo general hay
tres funciones más.
</p>

<div class="org-src-container">

<pre class="src src-c">printw(string);           /* Imprime en stdscr en la posicion actual del cursor */
mvprintw(y, x, string);   /* Mueve a (y, x) luego imprime la cadena             */
wprintw(win, string);     /* Imprime en la ventana win en la actual posicion    */
                          /* del cursor en la ventana                           */
mvwprintw(win, y, x, string);  /* Mueve a las coordenadas (y, x) relativas      */
                               /* a la ventana y luego imprime                  */
</pre>
</div>

<p>
Por lo general, las funciones sin-w son macros que se expanden a la
correspondiente funcion-w con <code>stdscr</code> como parámetro de ventana.
</p>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">6. Funciones de Salida</h2>
<div class="outline-text-2" id="text-7">
<p>
Supongo que no puede esperar más para ver algo de acción. De nuevo a
nuestra odisea de funciones. Ahora que curses esta inicializado,
vamos a interactuar con el mundo.
</p>

<p>
Hay tres clases de funciones que se pueden utilizar para manejar la
salida en la pantalla.
</p>

<ol class="org-ol">
<li>Clase <code>addch()</code>: Imprimir carácter individual con atributos
</li>
</ol>

<ol class="org-ol">
<li>Clase <code>printw()</code>: Imprimir salida con formato similar a
<code>printf()</code>
</li>
</ol>

<ol class="org-ol">
<li>Clase <code>addstr()</code>: Imprimir cadenas
</li>
</ol>

<p>
Estas funciones se pueden utilizar indistintamente y es cuestión de
estilo elegir la clase a utilizar. Veamos cada una a detalle.
</p>
</div>
<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">6.1. Clase de funciones <code>addch()</code></h3>
<div class="outline-text-3" id="text-7-1">
<p>
Estas funciones colocan un solo carácter en la posicion del cursor
y avanzan la posición del cursor. Puede dar el carácter a imprimir
pero por lo general se utilizan para imprimir un caracter con
algunos atributos. Los atributos se explican a detalle en
posteriores <a href="#ATTRIB">secciones</a> del documento. Si un caracter está asociado a
un atributo (negrita, vídeo inverso, etc.), cuando curses imprime
el carácter, este se imprime con ese atributo.
</p>

<p>
A fin de combinar un caracter con algunos atributos, tiene dos
Opciones:
</p>

<ul class="org-ul">
<li>con el operador OR enmascarar un solo caracter y la macro del
atributo deseado. Estas macros de atributos se encuentran en el
archivo de cabecera <code>ncurses.h</code>. Por ejemplo, si desea imprimir
un carácter <code>ch</code> (de tipo char) negrita y subrayado, llamaría a
<code>addch()</code> de la siguiente manera.

<div class="org-src-container">

<pre class="src src-c">addch(ch | A_BOLD | A_UNDERLINE);
</pre>
</div>
</li>
</ul>

<ul class="org-ul">
<li>Mediante funciones como <code>attrset()</code>, <code>attron()</code>, <code>attroff()</code>.
Estas funciones se explican en la sección <a href="#ATTRIB">Attributos</a>. Brevemente,
se pueden manipular los atributos actuales de una ventana
dada. Una vez establecidos, el carácter impreso está asociado con
los atributos hasta que se desactivan.
</li>
</ul>


<p>
Adicionalmente, <code>curses</code> proporciona algunos caracteres especiales
para gráficos basados ​​en caracteres. Puede dibujar tablas, líneas
horizontales o verticales, etc. Puede encontrar todos los
caracteres disponibles en el archivo de cabecera <code>ncurses.h</code>.
Intente buscando macros que inicien con <code>ACS_</code> en dicho archivo.
</p>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">6.2. <code>mvaddch()</code>, <code>waddch()</code> y <code>mvwaddch()</code></h3>
<div class="outline-text-3" id="text-7-2">
<p>
<code>mvaddch()</code> se utiliza para mover el cursor a un punto dado, y
luego imprimir. Por tanto, las llamadas:
</p>

<div class="org-src-container">

<pre class="src src-c">move(row,col);    /* mueve el cursor a la enesima fila y enesima columna */
addch(ch);
</pre>
</div>

<p>
puede ser reemplazado por
</p>

<div class="org-src-container">

<pre class="src src-c">mvaddch(row,col,ch);
</pre>
</div>

<p>
<code>waddch()</code> es similar a <code>addch()</code>, excepto que añade un carácter a
una ventana dada. (Tenga en cuenta que <code>addch()</code> añade un carácter
a la ventana <code>stdscr</code>.)
</p>

<p>
De manera similar la función <code>mvwaddch()</code> se utiliza para añadir un
carácter a la ventana dada en las coordenadas dadas.
</p>

<p>
Ahora, estamos familiarizados con la función de salida basico
<code>addch()</code>. Pero, si queremos imprimir una cadena, sera muy molesto
imprimirla carácter a carácter. Afortunadamente, <code>ncurses</code> provee
funciones similares a <code>printf</code> y <code>puts</code>.
</p>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">6.3. Clase de funciones <code>printw()</code></h3>
<div class="outline-text-3" id="text-7-3">
<p>
Estas funciones son similares a <code>printf()</code> con la capacidad añadida
de imprimir en cualquier posición de la pantalla.
</p>
</div>
<div id="outline-container-sec-7-3-1" class="outline-4">
<h4 id="sec-7-3-1">6.3.1. <code>printw()</code> y <code>mvprintw</code></h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
Estas dos funciones operan similar a <code>printf()</code>. <code>mvprintw()</code> se
utiliza para mover el cursor a una posición y luego imprimir. Si
quiere puede mover el cursor y luego imprimir utilizando la
función <code>printw()</code>, primero utilice <code>move()</code> y luego <code>printw()</code>
aunque no veo ningún punto para evitar el uso de <code>mvprintw()</code>, la
flexibilidad de manejo es tuya.
</p>
</div>
</div>
<div id="outline-container-sec-7-3-2" class="outline-4">
<h4 id="sec-7-3-2">6.3.2. <code>wprintw()</code> y <code>mvwprintw</code></h4>
<div class="outline-text-4" id="text-7-3-2">
<p>
Estas dos funciones son similares a las de dos de arriba, excepto
que imprimen en la correspondiente ventana dada como argumento.
</p>
</div>
</div>
<div id="outline-container-sec-7-3-3" class="outline-4">
<h4 id="sec-7-3-3">6.3.3. <code>vwprintw()</code></h4>
<div class="outline-text-4" id="text-7-3-3">
<p>
Esta función es similar a <code>vprintf()</code>. Se puede utilizar para
imprimir un número variable de argumentos.
</p>
</div>
</div>
<div id="outline-container-sec-7-3-4" class="outline-4">
<h4 id="sec-7-3-4">6.3.4. Un ejemplo sencillo de <code>printw</code></h4>
<div class="outline-text-4" id="text-7-3-4">
<p>
<a href="ncurses_programs/basics/printw_example.c"><b>Ejemplo 3. Un ejemplo sencillo de printw</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;              /* ncurses.h incluye stdio.h            */
#include &lt;string.h&gt;

int main()
{
  char mesg[]="Solo una cadena";  /* mensage que aparecera en pantalla     */
  int row,col;                    /* para guardar el numero de filas y     *
                                   * el numero de columnas de la pantalla  */
  initscr();                      /* inicia el modo curses                 */
  getmaxyx(stdscr,row,col);       /* obtiene el numero de filas y columnas */
  mvprintw(row/2,(col-strlen(mesg))/2,"%s",mesg);
                                  /* imprime el mensaje en el centro de la pantalla */
  mvprintw(row-2,0,"Esta pantalla tiene %d filas y %d rolumnas\n",row,col);
  printw("Prueba redimencionar la ventana(si es posible) y corre el programa nuevamente");
  refresh();
  getch();
  endwin();

  return 0;
}
</pre>
</div>

<p>
El Programa anterior demuestra lo fácil que es utilizar <code>printw</code>.
Simplemente pase las coordenadas y el mensaje a mostrar en
pantalla, y luego haga lo que quiera.
</p>

<p>
El programa anterior introduce una nueva función <code>getmaxyx()</code>, una
macro definida en <code>ncurses.h</code>. Entrega el número de columnas y el
número de filas en una ventana dada. <code>getmaxyx()</code> hace esto
actulalizando las variables que le son dadas. Ya que <code>getmaxyx()</code>
no es una función no pase punteros en ella, solo entregue dos
variables entero.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4">6.4. clase de funciones <code>addstr()</code></h3>
<div class="outline-text-3" id="text-7-4">
<p>
<code>addstr()</code> se utiliza para poner una cadena de caracteres en una
ventana determinada. Esta función es similar a llamar a <code>addch()</code>
una vez por cada carácter de una cadena dada. Esto es cierto para
todas las funciones de salida. Hay otras funciones de esta familia
como <code>mvaddstr()</code>, <code>mvwaddstr()</code> y <code>waddstr()</code>, que obedecen la
convención de nomenclatura de curses. (por ejemplo <code>mvaddstr()</code> es
similar a las respectivas llamadas <code>move()</code> y luego <code>addstr()</code>.)
Otra de las funciones de esta familia es <code>addnstr()</code>, que
adicionalmente toma un parámetro entero (llamado <code>n</code>). Esta función
pone almenos <code>n</code> caracteres en el pantalla. Si <code>n</code> es negativo,
entonces se añadirá toda la cadena.
</p>
</div>
</div>
<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5">6.5. Una plabra de advertencia</h3>
<div class="outline-text-3" id="text-7-5">
<p>
Todas estas funciones toman en sus argumentos la coordenada <code>y</code>
primero y <code>x</code> despues. Un error común de los principiantes es pasar
<code>x</code>, <code>y</code> en ese orden. Si está haciendo demasiadas manipulaciones
de coordenadas (y, x), considere dividir la pantalla en ventanas y
manipular cada una por separado. Las ventanas se explican en la
sección <a href="#WINDOWS">Ventanas</a>.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">7. Funciones de entrada</h2>
<div class="outline-text-2" id="text-8">
<p>
Bueno, la impresión sin toma de entrada, es aburrida. Veamos las
funciones que nos permiten tomar la entrada de usuario. Estas
funciones también pueden ser divididas en tres categorías.
</p>

<ol class="org-ol">
<li>Clase <code>getch()</code>: Obtener un caracter
</li>
</ol>

<ol class="org-ol">
<li>Clase <code>scanw()</code>: Obtener entrada con formato
</li>
</ol>

<ol class="org-ol">
<li>Clase <code>getstr()</code>: Obtener cadenas
</li>
</ol>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">7.1. clase de funciones <code>getch()</code></h3>
<div class="outline-text-3" id="text-8-1">
<p>
Estas funciones leen un solo carácter de la terminal. Pero hay
varios hechos sutiles a considerar. Por ejemplo, si no utiliza la
función <code>cbreak()</code>, curses no leerán sus caracteres de entrada
forma continua, solo empezara a leerlos sólo después de encontrar
un caracter de nueva linea o un EOF. Con el fin de evitar esto,
debe utilizarse la funcion <code>cbreak()</code> para que los caracteres están
disponibles a su prograba inmediatamente. Otra función muy
utilizada es <code>noecho()</code>. Como el nombre sugiere, cuando esta
función es activada (usada), los caracteres pulsados por el usuario
no se mostrarán en la pantalla. Las dos funciones <code>cbreak()</code> y
<code>noecho()</code> son ejemplos típicos de gestión del teclado. Las
funciones de este género se explican en la sección <i>gestion del
teclado</i>.
</p>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">7.2. clase de funciones <code>scanw()</code></h3>
<div class="outline-text-3" id="text-8-2">
<p>
Estas funciones son similares a <code>scanf()</code> con la capacidad añadida
de conseguir la entrada desde cualquier lugar de la pantalla.
</p>
</div>
<div id="outline-container-sec-8-2-1" class="outline-4">
<h4 id="sec-8-2-1">7.2.1. <code>scanw()</code> y <code>mvscanw</code></h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
El uso de estas funciones es similar al de <code>sscanf()</code>, donde la
línea a escanear es proporcionada por la funcien <code>wgetstr()</code>. Es
decir, estas funciones llaman a la funcion <code>wgetstr()</code> (explicada
más adelante) y utilizan la línea resultante de un escaneo.
</p>
</div>
</div>
<div id="outline-container-sec-8-2-2" class="outline-4">
<h4 id="sec-8-2-2">7.2.2. <code>wscanw()</code> y <code>mvwscanw()</code></h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
Estas son similares a las dos funciones anteriores excepto que
leen desde una ventana, que se suministra como uno de los
argumentos a estas funciones.
</p>
</div>
</div>
<div id="outline-container-sec-8-2-3" class="outline-4">
<h4 id="sec-8-2-3">7.2.3. <code>vwscanw()</code></h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
Esta función es similar a <code>vscanf()</code>. Se puede utilizar cuando se
va a escanear una número variable de argumentos.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">7.3. Clase de funciones <code>getstr()</code></h3>
<div class="outline-text-3" id="text-8-3">
<p>
Estas funciones se utilizan para obtener cadenas desde la terminal.
Esencialmente, esta función realiza la misma tarea que la que se
lograría con una serie de llamadas a <code>getch()</code> hasta recibir nueva
línea, retorno de carro, o fin de archivo. La cadena de caracteres
resultante es apuntada por <code>str</code>, El cual es un puntero a carácter
proporcionado por el usuario.
</p>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4">7.4. Algunos ejemplos</h3>
<div class="outline-text-3" id="text-8-4">
<p>
<a href="ncurses_programs/basics/scanw_example.c"><b>Ejemplo 4. Un ejemplo sencillo de scanw</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;                   /* ncurses.h incluye stdio.h             */
#include &lt;string.h&gt;

int main()
{
  char mesg[]="Ingrese una cadena: ";  /* mensaje a mostrar en pantalla         */
  char str[80];
  int row,col;                         /* para almacenar el numera de filas y   *
                                        * el numero de columnas de pantalla     */
  initscr();                           /* inicia el modo curses                 */
  getmaxyx(stdscr,row,col);            /* obtiene el numero de filas y columnas */
  mvprintw(row/2,(col-strlen(mesg))/2,"%s",mesg);
                                 /* imprime el mensaje al centro de la pantalla */
  getstr(str);
  mvprintw(LINES - 2, 0, "Ha ingresado: %s", str);
  getch();
  endwin();

  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">8. Atributos                                                        <a id="ATTRIB" name="ATTRIB"></a></h2>
<div class="outline-text-2" id="text-9">
<p>
Hemos visto un ejemplo de cómo se pueden utilizar atributos para
imprimir caracteres con algunos efectos especiales. Cuando los
atributos se establecen con prudencia, pueden presentar información
de manera sencilla y comprensible. El siguiente programa toma un
archivo C como entrada e imprime el archivo con comentarios en
negrita. Escanea a través del código.
</p>

<p>
<a href="ncurses_programs/basics/simple_attr.c"><b>Ejemplo 5. Un ejemplo sencillo de atributos</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">/* pager functionality by Joseph Spainhour" &lt;spainhou@bellsouth.net&gt; */
#include &lt;ncurses.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{
  int ch, prev, row, col;
  prev = EOF;
  FILE *fp;
  int y, x;

  if(argc != 2)
    {
      printf("Usage: %s &lt;a c file name&gt;\n", argv[0]);
      exit(1);
    }
  fp = fopen(argv[1], "r");
  if(fp == NULL)
    {
      perror("Cannot open input file");
      exit(1);
    }
  initscr();                               /* inicia el modo curses                */
  getmaxyx(stdscr, row, col);              /* obtiene los limites de pantalla      */
  while((ch = fgetc(fp)) != EOF)           /* lee el archivo hasta alcanzar el fin */
    {
      getyx(stdscr, y, x);                 /* obtiene posicion actual del cursor   */
      if(y == (row - 1))                   /* estamos al final de la pantalla      */
        {
          printw("&lt;-Press Any Key-&gt;");     /* pide una pulsacion al usuario        */
          getch();
          clear();                         /* limpia la pantalla                   */
          move(0, 0);                      /* comienza al inicio de la pantalla    */
        }
      if(prev == '/' &amp;&amp; ch == '*')         /* sololamente cuando es / y *
                                            * cambia a negrita                     */
        {
          attron(A_BOLD);                  /* activa negrita                       */
          getyx(stdscr, y, x);             /* obtiene posicion actual del cursor   */
          move(y, x - 1);                  /* retrocede un espacio                 */
          printw("%c%c", '/', ch);         /* La impresion real sucede aqui       */
        }
      else
        printw("%c", ch);
      refresh();
      if(prev == '*' &amp;&amp; ch == '/')
        attroff(A_BOLD);                   /* apagar una vez se ha alcanzado *
                                            * y luego /                            */
      prev = ch;
    }

  printw("&lt;-Press Any Key-&gt;");
  getch();

  endwin();                                /* Fin del modo curses                  */
  fclose(fp);
  return 0;
}
</pre>
</div>

<p>
No se inquiete con toda esa inicialización y otras mierdas.
Concéntrese en el bucle while. Se lee cada carácter en el archivo y
se busca el patrón <code>/*</code>. Una vez visto el patrón, cambia el atributo
a BOLD con <code>attron()</code>. Cuando se obtiene el patrón <code>*/</code> se desactiva
mediante <code>attroff()</code>.
</p>

<p>
El programa anterior también nos presenta dos funciones útiles
<code>getyx()</code> y <code>move()</code>. La primera función obtiene las coordenadas
actuales del cursor en las variables <code>y</code>, <code>x</code>. Ya que <code>getyx()</code> es
una macro no tenemos que pasar punteros a variables. La función
<code>move()</code> mueve el cursor a las coordenadas que le son dadas.
</p>

<p>
El programa anterior es realmente muy simple ya que no hace mucho.
Con estas líneas se podría escribir un programa más útil que lea un
archivo C, lo analice e imprima en diferentes colores. Podría
incluso extenderlo a otros lenguajes.
</p>
</div>
<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">8.1. Los detalles</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Entremos en más detalles sobre los atributos. Las funciones
<code>attron()</code>, <code>attroff()</code>, <code>attrset()</code>, y sus funciones hermanas
<code>attr_get()</code> etc&#x2026; se utilizan para encender/apagar atributos,
obtener atributos y dar una presetracion colorida.
</p>

<p>
Las funciones <code>attron</code> y <code>attroff</code> toman una máscara de bits de
atributos para encenderlos o apagarlos, respectivamente. Los
siguientes atributos de video, definidos en <code>&lt;curses.h&gt;</code> pueden ser
pasados a estas funciones.
</p>

<pre class="example">
A_NORMAL         Visualizacion normal (sin resaltar)
A_STANDOUT       Mejor modo del terminal para resaltado
A_UNDERLINE      Subrayado
A_REVERSE        Video inverso
A_BLINK          Intermitente
A_DIM            Mitad de brillo
A_BOLD           Brillo extra o negrita
A_PROTECT        Modo protegido
A_INVIS          En modo Invisible o en blanco
A_ALTCHARSET     Juego de caracteres alternativo
A_CHARTEXT       Mascara de bits para extraer el caracter
COLOR_PAIR(n)    Par de color numero /n/
</pre>

<p>
El último es el más colorido :-) Los colores se explican en las
<a href="#color">secciones siguentes</a>.
</p>

<p>
Con OR(|) podemos poner cualquier número de los atributos
anteriores para obtener un efecto combinado. Si querías vídeo
inverso con caracteres parpadeantes puedes usar
</p>

<div class="org-src-container">

<pre class="src src-c">attron(A_REVERSE | A_BLINK);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">8.2. <code>attron()</code> vs <code>attrset()</code></h3>
<div class="outline-text-3" id="text-9-2">
<p>
Entonces ¿cuál es la diferencia entre <code>attron()</code> y <code>attrset()</code>?
<code>attrset</code> establece los atributos de la ventana mientras que
<code>attron</code> simplemente enciende el atributo que le es dado. Así
<code>attrset()</code> anula totalmente los atributos que la ventana tenía
anteriormente y establece nuevos atributos. Del mismo modo
<code>attroff()</code> simplemente se apaga el atributo que se le da como
argumento. Esto nos da la flexibilidad de gestiónar los atributos
facilmente. Pero si se utilizan descuidadamente puede perder la
pista de que atributos tiene la ventana y distorsionar la
pantalla. Esto es especialmente cierto cuando maneja menús con
colores y resaltado. Así que determine una política constante y
adhierase a ella. Siempre puede utilizar <code>standend()</code> (que es
equivalente a <code>attrset(A_NORMAL)</code>) para apagar todos los atributos
y regresar al modo normal.
</p>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">8.3. <code>attr_get()</code></h3>
<div class="outline-text-3" id="text-9-3">
<p>
La función <code>attr_get()</code> obtiene los atributos y colores actuales de
la ventana. Aunque tal vez la utilice tan a menudo como las
funciones anteriores, es útil para escanear áreas de la pantalla.
Digamos que queríamos realizar alguna actualización compleja en la
pantalla y no estamos seguros de cuales atributos estan asociados a
cada carácter. En ese caso puede utilizadar esta función en
conjunto con <code>attrset</code> o <code>attron</code> para producir el efecto deseado.
</p>
</div>
</div>
<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4">8.4. funciones <code>attr_</code></h3>
<div class="outline-text-3" id="text-9-4">
<p>
Hay una serie de funciones como <code>attr_set()</code>, <code>attr_on</code>,
etc.. Estas son similares a las funciones anteriores, excepto que
toman parámetros de tipo <code>attr_t</code>.
</p>
</div>
</div>
<div id="outline-container-sec-9-5" class="outline-3">
<h3 id="sec-9-5">8.5. funciones <code>wattr</code></h3>
<div class="outline-text-3" id="text-9-5">
<p>
Para cada una de las funciones anteriores tenemos una función
correspondiente con 'w', que opera en una ventana en
particular. Las funciones anteriores operar en <code>stdscr</code>.
</p>
</div>
</div>
<div id="outline-container-sec-9-6" class="outline-3">
<h3 id="sec-9-6">8.6. funciones <code>chgat()</code></h3>
<div class="outline-text-3" id="text-9-6">
<p>
La función <code>chgat()</code> aparece al final de la página man <code>curs_attr</code>.
En realidad, es una utilidad. Puede utilizar esta función para
establecer los atributos de un grupo de caracteres sin moverse.
Con ello quiero decir !!! sin mover el cursor :-) Esto cambia los
atributos de un determinado número de caracteres a partir de la
ubicación actual del cursor.
</p>

<p>
Pasando <code>-1</code> como numero de caracteres actualiza hasta el final de
línea. Si desea cambiar los atributos a los caracteres de la
posición actual hasta el fin de línea, sólo utilice:
</p>

<div class="org-src-container">

<pre class="src src-c">chgat(-1, A_REVERSE, 0, NULL);
</pre>
</div>

<p>
Esta función es útil cuando se cambian los atributos de caracteres
que ya estan en pantalla. Valla al caracter desde el que desea
cambiar y modifique el atributo.
</p>

<p>
Las otras funciones <code>wchgat()</code>, <code>mvchgat()</code>, <code>mvwchgat()</code> se
comportan de manera similar excepto que las funciones "w" operan en
un ventana concreta. Las funciones mv primero mueven el cursor y a
continuación realizan el trabajo dado. <code>chgat</code> en realidad es una
macro que se sustituye por <code>wchgat()</code> con <code>stdscr</code> como ventana. La
mayor parte de las funciones de sin "w" son macros.
</p>

<p>
<a href="ncurses_programs/basics/with_chgat.c"><b>Ejemplo 6. Ejemplo de uso para chgat()</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

int main(int argc, char *argv[])
{   initscr();                      /* Inicia el modo curses            */
  start_color();                    /* Inicia la funcionalidad de color */

  init_pair(1, COLOR_CYAN, COLOR_BLACK);
  printw("Una gran cadena en la que no importa que escribir ");
  mvchgat(0, 0, -1, A_BLINK, 1, NULL);
  /*
   * Los primeros dos parametros especifican la posicion para empezar
   * El tercer parametro es el numero de caracteres a acutalizal, -1
   * quiere decir hasta fin de linea
   * El cuarto parametro es el attributo para el caracter
   * El quinto parametro es el indice de color. Este idice se obtiene
   * con init_pair() utilice 0 si no quiere ningun color
   * El sexto es siempre NULL
   */
  refresh();
  getch();
  endwin();                         /* Fin de modo curses               */
  return 0;
}
</pre>
</div>

<p>
Este ejemplo también nos introduce en el mundo de color de curses.
Los colores serán explicadas en detalle más adelante. Utilice 0
para ningún color.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">9. Ventanas                                                         <a id="WINDOWS" name="WINDOWS"></a></h2>
<div class="outline-text-2" id="text-10">
<p>
Las ventanas forman el concepto más importante en curses. Has visto
la ventana estándar <code>stdscr</code> en la cual todas funciones anteriores
operan de forma implícita. Ahora para hacer el diseño incluso de una
GUI sencilla, recurriremos al uso de ventanas. La principal razón
para utilizar ventanas es para manipular partes de la pantalla por
separado, abtenietdo asi un mejor redimiento, actualizando sólo las
ventanas que necesitan cambiar y para un diseño mejor. Yo diría que
la última razón es la más importante para utilizar ventanas. Usted
siempre debe luchar por un diseño de sus programas mejor y más fácil
de gestionar. Si esta escribiendo grandes y complejas GUIs esto es
de fundamental importancia antes de empezar a hacer cualquier cosa.
</p>
</div>
<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">9.1. Lo basico</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Puede crear una ventana llamando a la función <code>newwin()</code>. Esto en
realidad no crea nada en la pantalla. Asigna memoria a una
estructura para manipular la ventana y actualiza la estructura con
los datos relativos a la ventana como su tamaño, inicioy, iniciox
etc.. De ahí que en curses, una ventana sea sólo una abstracción
imaginaria de una ventana, que se puede manipular independiente de
las demás partes de la pantalla. La funcion <code>newwin()</code> devuelve un
puntero a la estructura <code>WINDOW</code>, el cual puede pasar a funciones
relacionadas con ventanas como <code>wprintw()</code> etc.. Finalmente la
ventana puede ser destruida con <code>delwin()</code>. Esto libera la memoria
asociada con la estructura <code>WINDOW</code>.
</p>
</div>
</div>
<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2">9.2. Que haya una Ventana !!!</h3>
<div class="outline-text-3" id="text-10-2">
<p>
Lo divertido es, crear una ventana y no poder verla. Comencemos
mostrando la ventana. La función <code>box()</code> sirve para dibujar un
borde alrededor de la ventana. Vamos a explorar esta y otras
funciones con más detalle en este ejemplo.
</p>

<p>
<a href="ncurses_programs/basics/win_border.c"><b>Ejemplo 7. Borde en ventana</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

WINDOW *create_newwin(int height, int width, int starty, int startx);
void destroy_win(WINDOW *local_win);

int main(int argc, char *argv[])
{ WINDOW *my_win;
  int startx, starty, width, height;
  int ch;

  initscr();                      /* Inicia el modo curses              */
  cbreak();                       /* Desactivar el buffer de linea
                                   * pasarme todo a mi                  */
  keypad(stdscr, TRUE);           /* Para habilitar F1                  */

  height = 3;
  width = 10;
  starty = (LINES - height) / 2;  /* Calculo para colocar al centro     */
  startx = (COLS - width) / 2;    /* de la ventana                      */
  printw("Pulse F1 para salir");
  refresh();
  my_win = create_newwin(height, width, starty, startx);

  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case KEY_LEFT:
            destroy_win(my_win);
            my_win = create_newwin(height, width, starty, --startx);
            break;
        case KEY_RIGHT:
          destroy_win(my_win);
          my_win = create_newwin(height, width, starty, ++startx);
          break;
        case KEY_UP:
          destroy_win(my_win);
          my_win = create_newwin(height, width, --starty, startx);
          break;
        case KEY_DOWN:
          destroy_win(my_win);
          my_win = create_newwin(height, width, ++starty, startx);
          break;
        }
    }

  endwin();                       /* Fin del modo curses                */
  return 0;
}

WINDOW *create_newwin(int height, int width, int starty, int startx)
{ WINDOW *local_win;

  local_win = newwin(height, width, starty, startx);
  box(local_win, 0, 0);           /* 0, 0 pone los caracteres por
                                   * defecto para las lineas vertical
                                   * y horizontal                       */
  wrefresh(local_win);            /* Muestra la caja                    */

  return local_win;
}

void destroy_win(WINDOW *local_win)
{
  /* box(local_win, ' ', ' '); : Esto no produce el resultado deseado
   * de borrar la ventana. Deja las cuatro esquinas como un feo residuo
   * de la ventana.
   */
  wborder(local_win, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ');
  /* Los parametros tomados son
   * 1. win: la ventana sobre la que operar
   * 2. ls: caracter a utilizar para el lado izquierdo de la ventana
   * 3. rs: caracter a utilizar para el lado derecho de la ventana
   * 4. ts: caracter a utilizar para el lado superior de la ventana
   * 5. bs: caracter a utilizar para el lado inferior de la ventana
   * 6. tl: caracter a utilizar para la esquina superior isquierda de la ventana
   * 7. tr: caracter a utilizar para la esquina superior derecha de la ventana
   * 8. bl: caracter a utilizar para la esquina inferior izquierda de la ventana
   * 9. br: caracter a utilizar para la esquina inferior derecha de la ventana
   */
  wrefresh(local_win);
  delwin(local_win);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3">9.3. Explicación</h3>
<div class="outline-text-3" id="text-10-3">
<p>
No grites. Sé que es un ejemplo grande. Pero tengo que explicar
algunas cosas importantes aquí :-). Este programa crea una ventana
rectangular que se puede mover con las teclas de flecha izquierda,
derecha, arriba y abajo. Con la creacion y destruccion repetida de
ventanas cuando el usuario presiona una tecla. No valla más allá de
los límites de la pantalla. La comprobación de estos límites se
deja como un ejercicio para el lector. Vamos a diseccionar línea
por línea.
</p>

<p>
El funcion <code>create_newwin()</code> crea una ventana con <code>newwin()</code> y
muestra un borde alrededor con <code>box()</code>. La función <code>destroy_win()</code>
primero borra la ventana de pantalla pintando un borde con el
caracter ' ' y luego llama a <code>delwin()</code> para liberar la memoria.
Dependiendo de la tecla que el usuario presiona, se cambia <code>starty</code>
o <code>startx</code> y se crea una nueva ventana.
</p>

<p>
Como puede ver en <code>destroy_win</code>, he usado <code>wborder()</code> en lugar de
<code>box()</code>. La razón está escrita en los comentarios (Te lo
perdiste. Lo se. Lee el codigo :-)). <code>wborder()</code> dibuja un borde
alrededor de la ventana con los caracteres dados para las 4
esquinas y las 4 líneas. Para decirlo claramente, si llama a
<code>wborder()</code> como a continuación:
</p>

<div class="org-src-container">

<pre class="src src-c">wborder(win, '|', '|', '-', '-', '+', '+', '+', '+');
</pre>
</div>

<p>
se produce algo como
</p>

<pre class="example">
+------------+
|            |
|            |
|            |
|            |
|            |
|            |
+------------+
</pre>
</div>
</div>
<div id="outline-container-sec-10-4" class="outline-3">
<h3 id="sec-10-4">9.4. Las otras cosas en el ejemplo</h3>
<div class="outline-text-3" id="text-10-4">
<p>
También puede ver que en los ejemplos anteriores, he utilizado las
variables <code>COLS</code> y <code>LINES</code> que se inicializan con el tamaño de
pantalla después de llamar a <code>initscr()</code>. Pueden ser útiles para
obtener las dimensiones de la pantalla y para localizar las
cordenadas al centro de la pantalla. Como siempre la función
<code>getch()</code> obtiene informacion del teclado y de acuerdo a esta se
hace el trabajo correspondiente. Este tipo de switch-case es muy
común en todos los programas basados en GUI.
</p>
</div>
</div>
<div id="outline-container-sec-10-5" class="outline-3">
<h3 id="sec-10-5">9.5. Otras funciones de Borde</h3>
<div class="outline-text-3" id="text-10-5">
<p>
El programa anterior es muy ineficiente ya que a cada pulsación, se
destruye una ventana y se crea otra. Así que vamos a escribir un
programa más eficiente que utiliza otras funciones relacionadas con
bordes.
</p>

<p>
El siguiente programa utiliza <code>mvhline()</code> y <code>mvvline()</code> para lograr
un efecto similar. Estas dos funciones son simples. Crean un línea
horizontal o vertical de la longitud especificada en la posición
especificada.
</p>

<p>
<a href="ncurses_programs/basics/other_border.c"><b>Ejemplo 8. Más funciones de borde</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

typedef struct _win_border_struct {
  chtype  ls, rs, ts, bs,
    tl, tr, bl, br;
} WIN_BORDER;

typedef struct _WIN_struct {
  int startx, starty;
  int height, width;
  WIN_BORDER border;
} WIN;

void init_win_params(WIN *p_win);
void print_win_params(WIN *p_win);
void create_box(WIN *win, bool flag);

int main(int argc, char *argv[])
{ WIN win;
  int ch;

  initscr();                      /* Inicia el modo curses           */
  start_color();                  /* Inicia la fucionalidad de color */
  cbreak();                       /* Desactivar el buffer de linea,
                                   * pasarme todo a mi               */
  keypad(stdscr, TRUE);           /* Necesario para habilitar F1     */
  noecho();
  init_pair(1, COLOR_CYAN, COLOR_BLACK);

  /* Inicializa los parametros de ventana */
  init_win_params(&amp;win);
  print_win_params(&amp;win);

  attron(COLOR_PAIR(1));
  printw("Pulse F1 para salir");
  refresh();
  attroff(COLOR_PAIR(1));

  create_box(&amp;win, TRUE);
  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case KEY_LEFT:
            create_box(&amp;win, FALSE);
            --win.startx;
            create_box(&amp;win, TRUE);
            break;
        case KEY_RIGHT:
          create_box(&amp;win, FALSE);
          ++win.startx;
          create_box(&amp;win, TRUE);
          break;
        case KEY_UP:
          create_box(&amp;win, FALSE);
          --win.starty;
          create_box(&amp;win, TRUE);
          break;
        case KEY_DOWN:
          create_box(&amp;win, FALSE);
          ++win.starty;
          create_box(&amp;win, TRUE);
          break;
        }
    }
  endwin();                       /* Fin del modo curses             */
  return 0;
}
void init_win_params(WIN *p_win)
{
  p_win-&gt;height = 3;
  p_win-&gt;width = 10;
  p_win-&gt;starty = (LINES - p_win-&gt;height)/2;
  p_win-&gt;startx = (COLS - p_win-&gt;width)/2;

  p_win-&gt;border.ls = '|';
  p_win-&gt;border.rs = '|';
  p_win-&gt;border.ts = '-';
  p_win-&gt;border.bs = '-';
  p_win-&gt;border.tl = '+';
  p_win-&gt;border.tr = '+';
  p_win-&gt;border.bl = '+';
  p_win-&gt;border.br = '+';

}
void print_win_params(WIN *p_win)
{
#ifdef _DEBUG
  mvprintw(25, 0, "%d %d %d %d", p_win-&gt;startx, p_win-&gt;starty,
           p_win-&gt;width, p_win-&gt;height);
  refresh();
#endif
}
void create_box(WIN *p_win, bool flag)
{ int i, j;
  int x, y, w, h;

  x = p_win-&gt;startx;
  y = p_win-&gt;starty;
  w = p_win-&gt;width;
  h = p_win-&gt;height;

  if(flag == TRUE)
    { mvaddch(y, x, p_win-&gt;border.tl);
      mvaddch(y, x + w, p_win-&gt;border.tr);
      mvaddch(y + h, x, p_win-&gt;border.bl);
      mvaddch(y + h, x + w, p_win-&gt;border.br);
      mvhline(y, x + 1, p_win-&gt;border.ts, w - 1);
      mvhline(y + h, x + 1, p_win-&gt;border.bs, w - 1);
      mvvline(y + 1, x, p_win-&gt;border.ls, h - 1);
      mvvline(y + 1, x + w, p_win-&gt;border.rs, h - 1);

    }
  else
    for(j = y; j &lt;= y + h; ++j)
      for(i = x; i &lt;= x + w; ++i)
        mvaddch(j, i, ' ');

  refresh();

}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">10. Colores                                                         <a id="color" name="color"></a></h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">10.1. Lo basico</h3>
<div class="outline-text-3" id="text-11-1">
<p>
La vida parece aburrida sin colores. curses tiene un buen mecanismo
para el manejo de colores. Vamos a entrar de lleno con un pequeño
programa.
</p>

<p>
<a href="ncurses_programs/basics/simple_color.c"><b>Ejemplo 9. Un ejemplo simple de color</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ncurses.h&gt;

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string);
int main(int argc, char *argv[])
{ initscr();                /* Inica el modo curses     */
  if(has_colors() == FALSE)
    { endwin();
      printf("Tu terminar no soporta color\n");
      exit(1);
    }
  start_color();            /* Inicia el color          */
  init_pair(1, COLOR_RED, COLOR_BLACK);

  attron(COLOR_PAIR(1));
  print_in_middle(stdscr, LINES / 2, 0, 0, "Viola !!! En color ...");
  attroff(COLOR_PAIR(1));
  getch();
  endwin();
}
void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  mvwprintw(win, y, x, "%s", string);
  refresh();
}
</pre>
</div>

<p>
Como puede ver, para empezar a utilizar el color, primero debe
llamar a la función <code>start_color()</code>. Después de eso, puede utilizar
las capacidades de color de su terminal utilizando distintas
funciones. Pasa averiguar si un terminal tiene capacidades de color
o no, puede utilizar la funcion <code>has_colors()</code>, que devuelve
<code>FALSE</code> si el terminal no soporta color.
</p>

<p>
curses inicializa todos los colores admitidos por el terminal
cuando llama a <code>start_color()</code>. Estos estan accesibles mediante
constantes como <code>COLOR_BLACK</code>, etc. Ahora para realizar un manejo
efectivo de colores, debe definir pares. Los colores siempre se
utilizan en pares. Esto significa hacer uso de la función
<code>init_pair()</code> para definir el color de el frente y el fondo para un
numero de pares deseado. Después los pares pueden ser utilizados
como un atributo normal con la funcion <code>COLOR_PAIR()</code>. Esto puede
parecer incómodo al inicio. Pero esta elegante solución nos permite
gestionar pares de colores muy facilmente. Para apreciarlo, mire el
codigo fuente de "dialog", una utilidad para mostrar cuadros de
diálogo en scripts de shell. Los desarrolladores definen todas las
combinaciones de color que se podiran necesitar y son inicializas
al inicio. Esto fácilita establecer atributos y acceder a parejas
ya definidas como constantes.
</p>

<p>
Los siguientes colores están definidos en <code>curses.h</code>. Usted puede
hacer uso de estos como parámetros para las distintas funciones de
color.
</p>

<pre class="example">
COLOR_BLACK   0
COLOR_RED     1
COLOR_GREEN   2
COLOR_YELLOW  3
COLOR_BLUE    4
COLOR_MAGENTA 5
COLOR_CYAN    6
COLOR_WHITE   7
</pre>
</div>
</div>
<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2">10.2. Cambio en Definiciones de Color</h3>
<div class="outline-text-3" id="text-11-2">
<p>
Puede utilizar la función <code>init_color()</code> para cambiar los valores
RGB definidos por curses inicialmente. Digamos que quiere aligerar
la intensidad del color rojo para una minúscula. Entonces puede
utilizar esta función como
</p>

<div class="org-src-container">

<pre class="src src-c">init_color(COLOR_RED, 700, 0, 0);
/* param 1     : nombre de color
 * param 2, 3, 4 : contenido rgb min = 0, max = 1000 */
</pre>
</div>

<p>
Si el terminal no puede cambiar las definiciones de color, la
función devuelve <code>ERR</code>. Puede utilizar la función
<code>can_change_color()</code> para conocer si el terminal tiene la capacidad
de cambiar el contenido de color o no. El contenido rgb se escala
de 0 a 1000. Inicialmente <code>COLOR_RED</code> es definido con un contenido
de 1,000(r), 0(g), 0(b).
</p>
</div>
</div>
<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3">10.3. Contenido en color</h3>
<div class="outline-text-3" id="text-11-3">
<p>
Puede utilizar las funciones <code>color_content()</code> y <code>pair_content()</code>
para conocer el contenido de color y la combinacion de frente y
fondo de un par.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">11. Comunicandonos con el teclado                                   <a id="KEYS" name="KEYS"></a></h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1">11.1. Lo basico</h3>
<div class="outline-text-3" id="text-12-1">
<p>
Ningun GUI está completo sin una fuerte interfaz de usuario y para
interactuar con el usuario, un programa curses debe ser sensible a
la pulsacion de teclas o las acciones del ratón realizadas por el
usuario. Vamos a tratar con las teclas primero.
</p>

<p>
Como se ha visto en casi todos los ejemplos anteriores, es muy
fácil obtener la entrada de teclado del usuario. Una manera simple
de conseguir pulsaciones del teclado es utilizar la funcion
<code>getch()</code>.  El modo <code>cbreak</code> debe estar habilitado para leer las
teclas individualmente en lugar de lineas completas de texto (que
por lo general terminan con un retorno de carro). Debe habilitar
<code>keypad</code> para obtener las teclas de funcion, flecha, etc. Vea la
sección <a href="#INIT">Inicialización</a> para más detalles.
</p>

<p>
<code>getch()</code> devuelve un entero correspondiente a la tecla pulsada. Si
es un caracter normal, el valor entero será equivalente a el
caracter. De lo contrario, devuelve un número que pueda ser
igualado con las constantes definidas en <code>curses.h</code>. Por ejemplo,
si el usuario presiona F1, el entero devuelto es 265. Esto se puede
comprobar con la macro <code>KEY_F()</code> defina en <code>curses.h</code>. Esto vuelve
la lectura portáble y fácil de manejar.
</p>

<p>
Por ejemplo, si llama a <code>getch()</code> como
</p>

<div class="org-src-container">

<pre class="src src-c">int ch;
ch = getch();
</pre>
</div>

<p>
<code>getch()</code> esperará a que el usuario presione una tecla, (a menos
que especique un tiempo de espera) y cuando el usuario pulsa una
tecla, se devuelve el entero correspondiente . A continuación,
puede comprobar el valor correspondiente devuelto con las
constantes definidas en <code>curses.h</code> contra las teclas que deseadas.
</p>

<p>
El siguiente fragmento de código hara ese trabajo.
</p>

<div class="org-src-container">

<pre class="src src-c">if(ch == KEY_LEFT)
  printw("Left arrow is pressed\n");
</pre>
</div>

<p>
Vamos a escribir un pequeño programa que crea un menú navegable con
las flechas arriba y abajo.
</p>
</div>
</div>
<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2">11.2. Ejemplo simple de uso de teclado</h3>
<div class="outline-text-3" id="text-12-2">
<p>
<a href="ncurses_programs/basics/simple_key.c"><b>Ejemplo 10. Uso sencillo del teclado</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;stdio.h&gt;
#include &lt;ncurses.h&gt;

#define WIDTH  30
#define HEIGHT 10

int startx = 0;
int starty = 0;

char *choices[] = {
  "Eleccion 1",
  "Eleccion 2",
  "Eleccion 3",
  "Eleccion 4",
  "Salir",
};
int n_choices = sizeof(choices) / sizeof(char *);
void print_menu(WINDOW *menu_win, int highlight);

int main()
{ WINDOW *menu_win;
  int highlight = 1;
  int choice = 0;
  int c;

  initscr();
  clear();
  noecho();
  cbreak();   /* Buffer de linea desactivado. Pasar de todo */
  startx = (80 - WIDTH) / 2;
  starty = (24 - HEIGHT) / 2;

  menu_win = newwin(HEIGHT, WIDTH, starty, startx);
  keypad(menu_win, TRUE);
  mvprintw(0, 0, "Utilice las flechas para ir arriba y abajo, Presione enter para elegir");
  refresh();
  print_menu(menu_win, highlight);
  while(1)
    { c = wgetch(menu_win);
      switch(c) {
        case KEY_UP:
          if(highlight == 1)
            highlight = n_choices;
          else
            --highlight;
          break;
        case KEY_DOWN:
          if(highlight == n_choices)
            highlight = 1;
          else
            ++highlight;
          break;
        case 10:
          choice = highlight;
          break;
        default:
          mvprintw(24, 0, "Caracter presionado = %3d Ojala se imprima como '%c'", c, c);
          refresh();
          break;
        }
      print_menu(menu_win, highlight);
      if(choice != 0) /* El usuario eligio salir del bucle infinito */
        break;
    }
  mvprintw(23, 0, "Elegiste la opcion %d con la cadena %s\n", choice, choices[choice - 1]);
  clrtoeol();
  refresh();
  getch();
  endwin();
  return 0;
}

void print_menu(WINDOW *menu_win, int highlight)
{
  int x, y, i;

  x = 2;
  y = 2;
  box(menu_win, 0, 0);
  for(i = 0; i &lt; n_choices; ++i)
    {   if(highlight == i + 1) /* Resalta lo opcion actual */
        { wattron(menu_win, A_REVERSE);
          mvwprintw(menu_win, y, x, "%s", choices[i]);
          wattroff(menu_win, A_REVERSE);
        }
      else
        mvwprintw(menu_win, y, x, "%s", choices[i]);
      ++y;
    }
  wrefresh(menu_win);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">12. Interfaz con el ratón</h2>
<div class="outline-text-2" id="text-13">
<p>
Ahora hemos visto cómo obtener informacion del teclado, hagamos los
mismo desde el ratón. Por lo general, cada interfaz de usuario
permite al usuario interactuar con ambos, teclado y ratón.
</p>
</div>
<div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1">12.1. Lo basico</h3>
<div class="outline-text-3" id="text-13-1">
<p>
Antes de hacer cualquier otra cosa, los eventos que desea recibir
deben ser habilitados con <code>mousemask()</code>.
</p>

<div class="org-src-container">

<pre class="src src-c">mousemask( mmask_t newmask,    /* Los eventos que quiere escuchar  */
           mmask_t *oldmask ); /* La anterior mascara de eventos   */
</pre>
</div>

<p>
El primer parámetro de la función anterior es una máscara de bits
de los eventos que le gustaría escuchar. Por defecto, todos los
eventos están apagados. La máscara de bits <code>ALL_MOUSE_EVENTS</code> se
puede utilizar para obtener todos los eventos.
</p>

<p>
Las siguientes son todas las máscaras de eventos:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Name</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>BUTTON1_PRESSED</code></td>
<td class="left">boton 1 del mouse abajo</td>
</tr>

<tr>
<td class="left"><code>BUTTON1_RELEASED</code></td>
<td class="left">boton 1 del mouse arriba</td>
</tr>

<tr>
<td class="left"><code>BUTTON1_CLICKED</code></td>
<td class="left">boton 1 del mouse clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON1_DOUBLE_CLICKED</code></td>
<td class="left">boton 1 del mouse doble clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON1_TRIPLE_CLICKED</code></td>
<td class="left">boton 1 del mouse triple clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON2_PRESSED</code></td>
<td class="left">boton 2 del mouse abajo</td>
</tr>

<tr>
<td class="left"><code>BUTTON2_RELEASED</code></td>
<td class="left">boton 2 del mouse arriba</td>
</tr>

<tr>
<td class="left"><code>BUTTON2_CLICKED</code></td>
<td class="left">boton 2 del mouse clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON2_DOUBLE_CLICKED</code></td>
<td class="left">boton 2 del mouse doble clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON2_TRIPLE_CLICKED</code></td>
<td class="left">boton 2 del mouse triple clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON3_PRESSED</code></td>
<td class="left">boton 3 del mouse abajo</td>
</tr>

<tr>
<td class="left"><code>BUTTON3_RELEASED</code></td>
<td class="left">boton 3 del mouse arriba</td>
</tr>

<tr>
<td class="left"><code>BUTTON3_CLICKED</code></td>
<td class="left">boton 3 del mouse clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON3_DOUBLE_CLICKED</code></td>
<td class="left">boton 3 del mouse doble clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON3_TRIPLE_CLICKED</code></td>
<td class="left">boton 3 del mouse triple clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON4_PRESSED</code></td>
<td class="left">boton 4 del mouse abajo</td>
</tr>

<tr>
<td class="left"><code>BUTTON4_RELEASED</code></td>
<td class="left">boton 4 del mouse up</td>
</tr>

<tr>
<td class="left"><code>BUTTON4_CLICKED</code></td>
<td class="left">boton 4 del mouse clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON4_DOUBLE_CLICKED</code></td>
<td class="left">boton 4 del mouse doble clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON4_TRIPLE_CLICKED</code></td>
<td class="left">boton 4 del mouse triple clic</td>
</tr>

<tr>
<td class="left"><code>BUTTON_SHIFT</code></td>
<td class="left">se pulso shift durante el cambio de estado del boton</td>
</tr>

<tr>
<td class="left"><code>BUTTON_CTRL</code></td>
<td class="left">se pulso control durante el cambio de estado del boton</td>
</tr>

<tr>
<td class="left"><code>BUTTON_ALT</code></td>
<td class="left">se pulso alt durante el cambio de estado del boton</td>
</tr>

<tr>
<td class="left"><code>ALL_MOUSE_EVENTS</code></td>
<td class="left">informa todos los cambios de estados</td>
</tr>

<tr>
<td class="left"><code>REPORT_MOUSE_POSITION</code></td>
<td class="left">informa movimiento del mouse</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2">12.2. Obtención de eventos</h3>
<div class="outline-text-3" id="text-13-2">
<p>
Una vez que una clase de eventos de ratón se ha habilitado, las
funciones de clase <code>getch()</code> devuelven <code>KEY_MOUSE</code> cada vez que
sucede un evento de ratón. En ese caso, el evento de ratón puede
ser recuperado con <code>getmouse()</code>.
</p>

<p>
El código es aproximadamente así:
</p>

<div class="org-src-container">

<pre class="src src-c">MEVENT event;
ch = getch();
if(ch == KEY_MOUSE)
  if(getmouse(&amp;event) == OK)
    .    /* Hacer algo con el evento */
    .
    .
</pre>
</div>

<p>
<code>getmouse()</code> devuelve el evento en el puntero que se le da. Es un
estructura que contiene
</p>

<div class="org-src-container">

<pre class="src src-c">typedef struct
{
  short id;         /* ID para distinguir multiples dispositivos */
  int x, y, z;      /* coordenadas del evento   */
  mmask_t bstate;   /* bits de estado del boton */
}
</pre>
</div>

<p>
<code>bstate</code> es la variable que mayor nos interesa. Informa el estado
del botón del ratón.
</p>

<p>
Luego, con un fragmento de código como el siguiente, podemos
averiguar lo sucedido.
</p>

<div class="org-src-container">

<pre class="src src-c">if(event.bstate &amp; BUTTON1_PRESSED)
  printw("Boton izquierdo presionado");
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-13-3" class="outline-3">
<h3 id="sec-13-3">12.3. Poniendo todo junto</h3>
<div class="outline-text-3" id="text-13-3">
<p>
Esta es más o menos la interfaz con el ratón. Vamos a crear el
mismo menú y permitir la interacción del ratón. Para hacer las
cosas más simples, se elimina el manejo del teclado.
</p>

<p>
<a href="ncurses_programs/basics/mouse_menu.c"><b>Ejemplo 11. Acceder al menú con el ratón !!!</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;
#include &lt;string.h&gt;

#define WIDTH  30
#define HEIGHT 10

int startx = 0;
int starty = 0;

char *choices[] = {     "Opcion 1",
                        "Opcion 2",
                        "Opcion 3",
                        "Opcion 4",
                        "Salir",
};

int n_choices = sizeof(choices) / sizeof(char *);

void print_menu(WINDOW *menu_win, int highlight);
void report_choice(int mouse_x, int mouse_y, int *p_choice);

int main()
{ int c, choice = 0;
  WINDOW *menu_win;
  MEVENT event;

  /* Inicializa curses */
  initscr();
  clear();
  noecho();
  cbreak();   // Deshabilitar buffer de linea. Pasar todo

  /* Trata de poner la ventana al centro de la pantalla */
  startx = (80 -  WIDTH) / 2;
  starty = (24 - HEIGHT) / 2;

  attron(A_REVERSE);
  mvprintw(23, 1, "Click en Salir para terminar (Funciona mejor en una consola virtual)");
  refresh();
  attroff(A_REVERSE);

  /* Imprime el menu por primera vez */
  menu_win = newwin(HEIGHT, WIDTH, starty, startx);
  print_menu(menu_win, 1);
  /* necesitamos habilitar las teclas de "funcion",
     KEY_MOUSE forma parte de ellas */
  keypad( menu_win, TRUE );
  /* Optener todos los eventos del raton */
  mousemask(ALL_MOUSE_EVENTS, NULL);

  while(1)
    { c = wgetch(menu_win);
      switch(c)
        {   case KEY_MOUSE:
            if(getmouse(&amp;event) == OK)
              { /* Cuando el usuario presiona el boton izquierdo del mouse */
                if(event.bstate &amp; BUTTON1_PRESSED)
                  { report_choice(event.x + 1, event.y + 1, &amp;choice);
                    if(choice == -1) // Opcion de salida
                      goto end;
                    mvprintw(22, 1, "La opcion elegida : %d La cadena elegida es \"%10s\"", choice, choices[choice - 1]);
                    refresh();
                  }
              }
            print_menu(menu_win, choice);
            break;
        }
    }
 end:
  endwin();
  return 0;
}


void print_menu(WINDOW *menu_win, int highlight)
{
  int x, y, i;

  x = 2;
  y = 2;
  box(menu_win, 0, 0);
  for(i = 0; i &lt; n_choices; ++i)
    { if(highlight == i + 1)
      { wattron(menu_win, A_REVERSE);
        mvwprintw(menu_win, y, x, "%s", choices[i]);
        wattroff(menu_win, A_REVERSE);
      }
      else
        mvwprintw(menu_win, y, x, "%s", choices[i]);
      ++y;
    }
  wrefresh(menu_win);
}

/* Informa la opcion de acuerdo a la posicion del mouse */
void report_choice(int mouse_x, int mouse_y, int *p_choice)
{ int i,j, choice;

  i = startx + 2;
  j = starty + 2;

  for(choice = 0; choice &lt; n_choices; ++choice)
    if(mouse_y == j + choice &amp;&amp; mouse_x &gt;= i &amp;&amp;
       mouse_x &lt;= i + strlen(choices[choice]))
      { if(choice == n_choices - 1)
        *p_choice = -1;
        else
          *p_choice = choice + 1;
        break;
      }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-13-4" class="outline-3">
<h3 id="sec-13-4">12.4. Funciones varias</h3>
<div class="outline-text-3" id="text-13-4">
<p>
Puede utilizar las funciones <code>mouse_trafo()</code> y <code>wmouse_trafo()</code>
para convertir las cordenadas del ratón en coordenadas relativas a
la pantalla. Vea la pagina de manual <a href="man/curs_mouse.3x.html"><code>curs_mouse(3X)</code></a> para más
detalles.
</p>

<p>
La función mouseinterval establece el tiempo máximo (en milesimas
de segundo) que puede transcurrir entre eventos de presion y
liberación para que puedan ser reconocidos como un clic. Esta
función devuelve el valor del intervalo anterior. El valor
predeterminado es una quinta parte de un segundo.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">13. Manipulación de Pantalla</h2>
<div class="outline-text-2" id="text-14">
<p>
En esta sección, veremos algunas funciones, que nos permiten manejar
la pantalla de manera eficiente para escribir algunos programas
fantasticos. Esto es especialmente importante en la escritura de
juegos.
</p>
</div>
<div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1">13.1. funciones <code>getyx()</code></h3>
<div class="outline-text-3" id="text-14-1">
<p>
La función <code>getyx()</code> se utiliza para descubrir las coordenadas
actuales del cursor. Se colocaran las coordenadas de los valores
<code>x</code> e <code>y</code> en los argumentos dados. Ya que <code>getyx()</code> es una macro no
tiene que pasar la dirección de las variables. Se le puede llamar
como
</p>

<div class="org-src-container">

<pre class="src src-c">getyx(win, y, x);
/* win : puentero a ventana
 * y, x: se colocaran las coordenadas y, x en estas variables
 */
</pre>
</div>

<p>
La función <code>getparyx()</code> obtiene las coordenadas iniciales de la sub
ventana con respecto a la ventana principal. Esto algunas veces es
útil para actualizar una sub ventana. Cuando se diseñan cosas
asombrosas como menús múltiples, debido a la dificultad de
almacenar las posiciones del menú, las coordenadas de la opcion
principal etc. Una solución simple a este problema, es la creación
de menús en ventanas secundarias y luego localizar las coordenadas
iniciales de los menús utilizando <code>getparyx()</code>.
</p>

<p>
Las funciones <code>getbegyx()</code> y <code>getmaxyx()</code> almacenan el inicio y las
coordenadas maximas de la ventana actual. Estas funciones son
útiles de la misma manera que la anterior en el manejo eficaz de
ventanas y sub ventanas.
</p>
</div>
</div>
<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2">13.2. Volcado de Pantalla</h3>
<div class="outline-text-3" id="text-14-2">
<p>
Cuando se escriben juegos, en ocaciones es necesario almacenar el
estado de la pantalla y restaurarlo de nuevo al mismo estado. Puede
utilizar la función <code>scr_dump()</code> para volcar los contenidos de la
pantalla al archivo dado como argumento. Más tarde se puede
restaurare con la función <code>scr_restore</code>. Con estas dos simples
funciones pueden mantener el manejo eficiente en un juego de
movimiento rapido con cambios de escenarios.
</p>
</div>
</div>
<div id="outline-container-sec-14-3" class="outline-3">
<h3 id="sec-14-3">13.3. Volcado de Ventana</h3>
<div class="outline-text-3" id="text-14-3">
<p>
Puede utilizar las funciones <code>putwin()</code> y <code>getwin()</code>, para guardar
y restaurar ventanas. <code>putwin()</code> coloca el estado actual de la
ventana en un archivo, que puede ser restaurado posteriormente por
<code>getwin()</code>.
</p>

<p>
Puede utilizar la función <code>copywin()</code> para copiar por completo una
ventana en otra ventana. Toma las ventanas de origen y destino como
parámetros y de acuerdo con el rectángulo especificado, copia la
región rectangular desde la ventana origen hasta la ventana
destino. El último parámetro especifica si desea sobrescribir o
simplemente superponer el contenido en la ventana destino. Si este
argumento es cierto, entonces la copia es no destructiva.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">14. Características diversas</h2>
<div class="outline-text-2" id="text-15">
<p>
Ahora ya conoces suficientes características para escribir un buen
programa curses. Aqui estan algunas funciones auxiliares útiles en
varios casos. Vamos a ir de cabeza a algunas de ellas.
</p>
</div>
<div id="outline-container-sec-15-1" class="outline-3">
<h3 id="sec-15-1">14.1. <code>curs_set()</code></h3>
<div class="outline-text-3" id="text-15-1">
<p>
Puede utilizar esta función para hacer el cursor invisible. Los
parámetros aceptados por esta funcion son.
</p>

<pre class="example">
0 : invisible
1 : normal
2 : muy visible.
</pre>
</div>
</div>
<div id="outline-container-sec-15-2" class="outline-3">
<h3 id="sec-15-2">14.2. Dejar Temporalmente el modo curses</h3>
<div class="outline-text-3" id="text-15-2">
<p>
En algunas ocaciones puede buscar volver temporalmente al cooked
mode(modo normal de linea de buffer). En tal caso, primero tendrás
que guardar los modos tty con una llamada a <code>def_prog_mode()</code> y
luego llamar a <code>endwin()</code> para finalizar el modo de curses. Esto te
dejará en el el modo tty original. Una vez que haya terminado,
llamara a <code>reset_prog_mode()</code> para volver al modo curses. Esta
función devuelve el tty al estado almacenada por <code>def_prog_mode()</code>.
Luego de un <code>refreth()</code>, estára de vuelta en el modo de curses.  He
aquí un ejemplo que muestra la secuencia de cosas por hacer.
</p>

<p>
<a href="ncurses_programs/basics/temp_leave.c"><b>Ejemplo 12. Dejando Temporalmente el Modo curses</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  initscr();                      /* Iniciar el modo curses                 */
  printw("Hola mundo !!!\n");     /* Imprime Hola mundo                     */
  refresh();                      /* Imprimir en la pantalla real           */
  getch();                        /* Esperar                                */
  def_prog_mode();                /* Guardar los modos tty                  */
  endwin();                       /* Finalizar curnes temporalmente         */
  system("/bin/sh");              /* Realizar cualquier cosa en modo cooked */
  reset_prog_mode();              /* Regresar al modo tty previo            */
                                  /* almacenado por def_prog_mode()         */
  refresh();                      /* refresh() restaura los contenidos      */
                                  /* en pantalla                            */
  printw("Otra Cadena\n");        /* De nuevo utilizar curses al maximo     */
  refresh();                      /* de sus capacidades                     */
  getch();                        /* Esperar                                */
  endwin();                       /* Finalizar el modo curses               */

  return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-15-3" class="outline-3">
<h3 id="sec-15-3">14.3. Variables <code>ACS_</code></h3>
<div class="outline-text-3" id="text-15-3">
<p>
Si alguna vez has programado en DOS, debes conocer acerca de este
ingenioso juego de caracteres extendidos. Estos son imprimibles
sólo en algunos terminales. Las funciones como <code>box()</code> utilizan
estos caracteres. Todas estas variables comienzan con <b>ACS</b>
significando el conjunto de caracteres alternativo. Es posible que
haya observado mi uso de estos caracteres en algunos de los
programas anteriores. El siguiente ejemplo que muestra todos los
caracteres.
</p>

<p>
<a href="ncurses_programs/basics/acs_vars.c"><b>Ejemplo 13. Variables ACS</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

int main()
{
  initscr();

  printw("Upper left corner           "); addch(ACS_ULCORNER ); printw("\n");
  printw("Lower left corner           "); addch(ACS_LLCORNER ); printw("\n");
  printw("Lower right corner          "); addch(ACS_LRCORNER ); printw("\n");
  printw("Tee pointing right          "); addch(ACS_LTEE     ); printw("\n");
  printw("Tee pointing left           "); addch(ACS_RTEE     ); printw("\n");
  printw("Tee pointing up             "); addch(ACS_BTEE     ); printw("\n");
  printw("Tee pointing down           "); addch(ACS_TTEE     ); printw("\n");
  printw("Horizontal line             "); addch(ACS_HLINE    ); printw("\n");
  printw("Vertical line               "); addch(ACS_VLINE    ); printw("\n");
  printw("Large Plus or cross over    "); addch(ACS_PLUS     ); printw("\n");
  printw("Scan Line 1                 "); addch(ACS_S1       ); printw("\n");
  printw("Scan Line 3                 "); addch(ACS_S3       ); printw("\n");
  printw("Scan Line 7                 "); addch(ACS_S7       ); printw("\n");
  printw("Scan Line 9                 "); addch(ACS_S9       ); printw("\n");
  printw("Diamond                     "); addch(ACS_DIAMOND  ); printw("\n");
  printw("Checker board (stipple)     "); addch(ACS_CKBOARD  ); printw("\n");
  printw("Degree Symbol               "); addch(ACS_DEGREE   ); printw("\n");
  printw("Plus/Minus Symbol           "); addch(ACS_PLMINUS  ); printw("\n");
  printw("Bullet                      "); addch(ACS_BULLET   ); printw("\n");
  printw("Arrow Pointing Left         "); addch(ACS_LARROW   ); printw("\n");
  printw("Arrow Pointing Right        "); addch(ACS_RARROW   ); printw("\n");
  printw("Arrow Pointing Down         "); addch(ACS_DARROW   ); printw("\n");
  printw("Arrow Pointing Up           "); addch(ACS_UARROW   ); printw("\n");
  printw("Board of squares            "); addch(ACS_BOARD    ); printw("\n");
  printw("Lantern Symbol              "); addch(ACS_LANTERN  ); printw("\n");
  printw("Solid Square Block          "); addch(ACS_BLOCK    ); printw("\n");
  printw("Less/Equal sign             "); addch(ACS_LEQUAL   ); printw("\n");
  printw("Greater/Equal sign          "); addch(ACS_GEQUAL   ); printw("\n");
  printw("Pi                          "); addch(ACS_PI       ); printw("\n");
  printw("Not equal                   "); addch(ACS_NEQUAL   ); printw("\n");
  printw("UK pound sign               "); addch(ACS_STERLING ); printw("\n");

  refresh();
  getch();
  endwin();

  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16">15. Otras librerias</h2>
<div class="outline-text-2" id="text-16">
<p>
Además de la libreria curses, hay algunas librerias en modo texto,
que proporcionan una mayor funcionalidad y un montón de
características. Las siguientes secciones describen tres librerias
estándar que normalmente se distribullen junto a curses.
</p>
</div>
</div>
<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17">16. Libreria Panel</h2>
<div class="outline-text-2" id="text-17">
<p>
Ahora que eres competente en curses, buscaras hacer algo grande.
Como crear una gran cantidad de ventanas superpuestas para dar un
aspecto profesional tipo ventana. Por desgracia, esto se hace
dificil de manejar en poco tiempo. Las actualizaciones múltiples, te
sumergiran en una pesadilla. Las ventanas superpuestas generan
manchas, cada vez que olvida actualizar las ventanas en el orden
correcto.
</p>

<p>
No caiga en la desesperacion. Hay una solución elegante
proporcionada en la libreria Parel. En palabras de los
desarrolladores de ncurses
</p>

<div class="italic">
<p>
Cuando el diseño de su interfaz es tal que las ventanas pueden
sumergirse más profundamente en la pila de visibilidad o saltar a
la cima en tiempo de ejecución, puede ser tedioso y difícil
mantener un resultado de forma correcta. Para eso esta la librería
panel.
</p>

</div>

<p>
Si tiene muchas ventanas superpuestas, la libreria panel es el
camino a seguir. Es obvia la necesidad de realizar una serie de
<code>wnoutrefresh()</code>, <code>doupdate()</code> y aliviar la carga de hacerlo
correctamente (abajo arriba). La libreria mantiene información sobre
el orden de las ventanas, su superposición y en consecuencia
actualiza la pantalla correctamente. Así que ¿por qué esperar?
Echemos un vistazo de cerca a los paneles.
</p>
</div>
<div id="outline-container-sec-17-1" class="outline-3">
<h3 id="sec-17-1">16.1. Lo basico</h3>
<div class="outline-text-3" id="text-17-1">
<p>
Un objeto panel es una ventana que se trata implícitamente como
parte de una baraja incluyendo a todos los otros objetos panel. La
baraja se trata como una pila con un panel superior que es
completamente visible y los otros paneles pueden o no ser
oscurecidos respecto a sus posiciones. Asi que La idea básica es
crear una pila de paneles superpuestos y utilizal la libreria panel
para desplegarlos correctamente. Hay una función similar a
<code>refresh()</code> que, cuando es llamada, despliega los paneles en el
orden correcto. Se proporcionan funciones para ocultar o mostrar
paneles, mover paneles, cambiar su tamaño, etc.. El problema de
superposicion es gestionado por la libreria panel durante todas las
llamadas a estas funciones.
</p>

<p>
El flujo general de un programa panel es el siguiente:
</p>

<ol class="org-ol">
<li>Crear las ventanas (con <code>newwin()</code>) que seran ligadas a paneles.
</li>
</ol>

<ol class="org-ol">
<li>Cree paneles con el ordend de visibilidad elegido. Apilarlos de
acuerdo con la visibilidad deseada. La función <code>new_panel()</code> se
utiliza para crear paneles.
</li>
</ol>

<ol class="org-ol">
<li>Llame a <code>update_panels()</code> para escribir los paneles en la
pantalla virtual en el orden correcto de visibilidad. llame a
<code>doupdate()</code> para mostrarlo en pantalla.
</li>
</ol>

<ol class="org-ol">
<li>Manipule los paneles con <code>show_panel()</code>, <code>hide_panel()</code>,
<code>move_panel()</code> etc. Haga uso de funciones auxiliares como
<code>panel_hidden()</code> y <code>panel_window()</code>. Haga uso del puntero de
usuario para almacenar datos personalizados para un
panel. Utilice las funciones <code>set_panel_userptr()</code> y
<code>panel_userptr()</code> para establecer y obtener el puntero de
usuario de un panel.
</li>
</ol>

<ol class="org-ol">
<li>Cuando haya terminado de utilizar el panel llame a <code>del_panel()</code>
      para eliminar el panel.
</li>
</ol>


<p>
Hagamos los conceptos claros, con algunos programas. El siguiente
es un sencillo programa que crea 3 paneles superpuestos y les
muestra en la pantalla.
</p>
</div>
</div>
<div id="outline-container-sec-17-2" class="outline-3">
<h3 id="sec-17-2">16.2. Compilación con la Librería Panel</h3>
<div class="outline-text-3" id="text-17-2">
<p>
Para utilizar las funciones de la libreria panel, tiene que incluir
<code>panel.h</code> y vincular el programa a la dicha libreria con la bandera
<code>-lpanel</code> junto con <code>-lncurses</code> en ese orden.
</p>

<pre class="example">
#include &lt;panel.h&gt;
.
.
.

compilacion y enlace: gcc &lt;fichero del programa&gt; -lpanel -lncurses
</pre>

<p>
<a href="ncurses_programs/panels/panel_simple.c"><b>Ejemplo 14. Panel conceptos basicos</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;panel.h&gt;

int main()
{ WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  int lines = 10, cols = 40, y = 2, x = 4, i;

  initscr();
  cbreak();
  noecho();

  /* Creacion de ventanas para los paneles */
  my_wins[0] = newwin(lines, cols, y, x);
  my_wins[1] = newwin(lines, cols, y + 1, x + 5);
  my_wins[2] = newwin(lines, cols, y + 2, x + 10);

  /*
   * Creacion de bordes alrededor de las ventanas para ver el efecto
   * de los paneles
   */
  for(i = 0; i &lt; 3; ++i)
    box(my_wins[i], 0, 0);

  /* Unir un panel a cada ventana */      /* ordenar de abajo hacia arriba  */
  my_panels[0] = new_panel(my_wins[0]);   /* agregar 0, orden: stdscr-0     */
  my_panels[1] = new_panel(my_wins[1]);   /* agregar 1, orden: stdscr-0-1   */
  my_panels[2] = new_panel(my_wins[2]);   /* agregar 2, orden: stdscr-0-1-2 */

  /* Actualizar en orden de apilamiento. El 2nd panel estara en la cima     */
  update_panels();

  /* Mostrar en la pantalla */
  doupdate();

  getch();
  endwin();
}
</pre>
</div>

<p>
Como se puede ver, el programa anterior sigue un flujo simple. Las
ventanas se crean con <code>newwin()</code> y luego son unidas a paneles con
<code>new_panel()</code>. La pila de paneles se actualiza, a medida que
agregamos un panel después otro. Para mostrarlos en pantalla
llamamos a <code>update_panels()</code> y <code>doupdate()</code>.
</p>
</div>
</div>
<div id="outline-container-sec-17-3" class="outline-3">
<h3 id="sec-17-3">16.3. Navegacion en Paneles de Ventana</h3>
<div class="outline-text-3" id="text-17-3">
<p>
El siguiente es un ejemplo un poco complicado. Este programa crea 3
ventanas que se puede rotar ciclicamente mediante el uso de <i>tab</i>.
Echa un vistazo al código.
</p>

<p>
<a href="ncurses_programs/panels/panel_browse.c"><b>Ejemplo 15. Navegacion en Paneles de Ventana</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;panel.h&gt;
#include &lt;string.h&gt;

#define NLINES 10
#define NCOLS 40

void init_wins(WINDOW **wins, int n);
void win_show(WINDOW *win, char *label, int label_color);
void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

int main()
{ WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  PANEL  *top;
  int ch;

  /* Inicializa curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Inicializa todos los colores */
  init_pair(1, COLOR_RED,   COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_BLUE,  COLOR_BLACK);
  init_pair(4, COLOR_CYAN,  COLOR_BLACK);

  init_wins(my_wins, 3);

  /* Unir un panel a cada ventana */      /* Ordenar de abajo hacia arriba  */
  my_panels[0] = new_panel(my_wins[0]);   /* Agregar 0, orden: stdscr-0     */
  my_panels[1] = new_panel(my_wins[1]);   /* Agregar 1, orden: stdscr-0-1   */
  my_panels[2] = new_panel(my_wins[2]);   /* Agregar 2, orden: stdscr-0-1-2 */

  /* Crear el puntero de usuario al siguiente panel */
  set_panel_userptr(my_panels[0], my_panels[1]);
  set_panel_userptr(my_panels[1], my_panels[2]);
  set_panel_userptr(my_panels[2], my_panels[0]);

  /* Actualizar el orden de apilamiento. El 2nd panel estara en la parte superior */
  update_panels();

  /* Mostrar en la pantalla */
  attron(COLOR_PAIR(4));
  mvprintw(LINES - 2, 0, "Utilice tab para navegar a traves de las ventanas (F1 para Salir)");
  attroff(COLOR_PAIR(4));
  doupdate();

  top = my_panels[2];
  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case 9:
            top = (PANEL *)panel_userptr(top);
            top_panel(top);
            break;
        }
      update_panels();
      doupdate();
    }
  endwin();
  return 0;
}

/* Coloca todas las ventanas */
void init_wins(WINDOW **wins, int n)
{ int x, y, i;
  char label[80];

  y = 2;
  x = 10;
  for(i = 0; i &lt; n; ++i)
    { wins[i] = newwin(NLINES, NCOLS, y, x);
      sprintf(label, "Ventana Numero %d", i + 1);
      win_show(wins[i], label, i + 1);
      y += 3;
      x += 7;
    }
}

/* Muestra la ventana con un borde y una etiqueta */
void win_show(WINDOW *win, char *label, int label_color)
{ int startx, starty, height, width;

  getbegyx(win, starty, startx);
  getmaxyx(win, height, width);

  box(win, 0, 0);
  mvwaddch(win, 2, 0, ACS_LTEE);
  mvwhline(win, 2, 1, ACS_HLINE, width - 2);
  mvwaddch(win, 2, width - 1, ACS_RTEE);

  print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
}

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-17-4" class="outline-3">
<h3 id="sec-17-4">16.4. Utilizando punteros de usuario</h3>
<div class="outline-text-3" id="text-17-4">
<p>
En el ejemplo anterior utilice punteros de usuario para obtener la
siguiente ventana en el ciclo. Podemos vincular información
personalizada al panel especificando un puntero de usuario, que
puede apuntar a cualquier información desea almacenar. En este caso
guardé el puntero al siguiente panel en el ciclo. El puntero de
usuario de un panel se puede establecer con la función
<code>set_panel_userptr()</code>. Se puede acceder a dicha informacion
mediante la función <code>panel_userptr()</code> que devolverá el puntero de
usuario de el panel dado como argumento. Después localizar el
siguiente panel en el ciclo se establece en la cima con la función
<code>top_panel()</code>. Esta función trae a el panel dado como argumento a
la parte superior de la pila de paneles.
</p>
</div>
</div>
<div id="outline-container-sec-17-5" class="outline-3">
<h3 id="sec-17-5">16.5. Mover y Redimensionar Paneles</h3>
<div class="outline-text-3" id="text-17-5">
<p>
Puede utilizar la función <code>move_panel()</code> para mover un panel a la
posicion deseada. Esto no cambia la posición del panel en la
pila. Asegúrese utilizar <code>move_panel()</code> en lugar de <code>mvwin()</code> en la
ventana asociada a el panel.
</p>

<p>
Cambiar el tamaño de un panel es ligeramente complejo. No hay una
función directa para cambiar el tamaño de la ventana asociada a un
un panel. Una solución para cambiar el tamaño de un panel es crear
una nueva ventana con el tamaño deseado, cambie la ventana asociada
a el panel utilizando <code>replace_panel()</code>. No olvides borrar la
ventana anterior. Puede obtener la ventana asociada con un panel
mediante el uso de la función <code>panel_window()</code>.
</p>

<p>
El siguiente programa muestra estos conceptos, en suposicion es un
programa sencillo. Como es costumbre, puede rotar entre ventanas
con &lt;TAB&gt;. Para cambiar el tamaño o mover el panel activo presione
"r" por "resize", 'm' para mover. A continuación, utilice las
teclas de flecha para cambiar el tamaño o mover a la forma deseada
y pulse enter para terminar el cambio. En ejemplo hace uso de los
datos del usuario para obtener los datos necesarios para hacer las
operaciones.
</p>

<p>
<a href="ncurses_programs/panels/panel_resize.c"><b>Ejemplo 16. Mover y Redimencionar un Panel</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;panel.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct _PANEL_DATA {
  int x, y, w, h;
  char label[80];
  int label_color;
  PANEL *next;
} PANEL_DATA;

#define NLINES 10
#define NCOLS 40

void init_wins(WINDOW **wins, int n);
void win_show(WINDOW *win, char *label, int label_color);
void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);
void set_user_ptrs(PANEL **panels, int n);

int main()
{ WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  PANEL_DATA  *top;
  PANEL *stack_top;
  WINDOW *temp_win, *old_win;
  int ch;
  int newx, newy, neww, newh;
  int size = FALSE, move = FALSE;

  /* Inicializar curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Inicializar todos los colores */
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_BLUE, COLOR_BLACK);
  init_pair(4, COLOR_CYAN, COLOR_BLACK);

  init_wins(my_wins, 3);

  /* Unir un panel a cada ventana */      /* Ordenar de abajo hacia arriba  */
  my_panels[0] = new_panel(my_wins[0]);   /* Agregar 0, orden: stdscr-0     */
  my_panels[1] = new_panel(my_wins[1]);   /* Agregar 1, orden: stdscr-0-1   */
  my_panels[2] = new_panel(my_wins[2]);   /* Agregar 2, orden: stdscr-0-1-2 */

  set_user_ptrs(my_panels, 3);

  /* Actualizar el orden de apilamiento. El 2nd panel estara en la parte superior */
  update_panels();

  /* Mostrar en la pantalla */
  attron(COLOR_PAIR(4));
  mvprintw(LINES - 3, 0, "Use 'm' para mover, 'r' para redimencionar");
  mvprintw(LINES - 2, 0, "Use tab para navegar a traves de las ventanas (F1 para Salir)");
  attroff(COLOR_PAIR(4));
  doupdate();

  stack_top = my_panels[2];
  top = (PANEL_DATA *)panel_userptr(stack_top);
  newx = top-&gt;x;
  newy = top-&gt;y;
  neww = top-&gt;w;
  newh = top-&gt;h;
  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case 9:     /* Tab */
            top = (PANEL_DATA *)panel_userptr(stack_top);
            top_panel(top-&gt;next);
            stack_top = top-&gt;next;
            top = (PANEL_DATA *)panel_userptr(stack_top);
            newx = top-&gt;x;
            newy = top-&gt;y;
            neww = top-&gt;w;
            newh = top-&gt;h;
            break;
        case 'r':   /* Redimencion */
          size = TRUE;
          attron(COLOR_PAIR(4));
          mvprintw(LINES - 4, 0, "Ingrese dimencion: Use las teclas de flecha y pulse &lt;ENTER&gt; para redimencionar");
          refresh();
          attroff(COLOR_PAIR(4));
          break;
        case 'm':   /* Movimiento  */
          attron(COLOR_PAIR(4));
          mvprintw(LINES - 4, 0, "Ingrese movimiento: Use las teclas de flecha y pulse &lt;ENTER&gt; para mover");
          refresh();
          attroff(COLOR_PAIR(4));
          move = TRUE;
          break;
        case KEY_LEFT:
          if(size == TRUE)
            { --newx;
              ++neww;
            }
          if(move == TRUE)
            --newx;
          break;
        case KEY_RIGHT:
          if(size == TRUE)
            { ++newx;
              --neww;
            }
          if(move == TRUE)
            ++newx;
          break;
        case KEY_UP:
          if(size == TRUE)
            { --newy;
              ++newh;
            }
          if(move == TRUE)
            --newy;
          break;
        case KEY_DOWN:
          if(size == TRUE)
            { ++newy;
              --newh;
            }
          if(move == TRUE)
            ++newy;
          break;
        case 10:    /* Enter */
          move(LINES - 4, 0);
          clrtoeol();
          refresh();
          if(size == TRUE)
            { old_win = panel_window(stack_top);
              temp_win = newwin(newh, neww, newy, newx);
              replace_panel(stack_top, temp_win);
              win_show(temp_win, top-&gt;label, top-&gt;label_color);
              delwin(old_win);
              size = FALSE;
            }
          if(move == TRUE)
            { move_panel(stack_top, newy, newx);
              move = FALSE;
            }
          break;

        }
      attron(COLOR_PAIR(4));
      mvprintw(LINES - 3, 0, "Use 'm' para mover, 'r' para redimencionar");
      mvprintw(LINES - 2, 0, "Use tab para navegar a traves de las ventanas (F1 para Salir)");
      attroff(COLOR_PAIR(4));
      refresh();
      update_panels();
      doupdate();
    }
  endwin();
  return 0;
}

/* Colocar todas las ventanas */
void init_wins(WINDOW **wins, int n)
{ int x, y, i;
  char label[80];

  y = 2;
  x = 10;
  for(i = 0; i &lt; n; ++i)
    { wins[i] = newwin(NLINES, NCOLS, y, x);
      sprintf(label, "Ventana Numero %d", i + 1);
      win_show(wins[i], label, i + 1);
      y += 3;
      x += 7;
    }
}

/* Establece la estructura PANEL_DATA para paneneles individualmente */
void set_user_ptrs(PANEL **panels, int n)
{ PANEL_DATA *ptrs;
  WINDOW *win;
  int x, y, w, h, i;
  char temp[80];

  ptrs = (PANEL_DATA *)calloc(n, sizeof(PANEL_DATA));

  for(i = 0;i &lt; n; ++i)
    { win = panel_window(panels[i]);
      getbegyx(win, y, x);
      getmaxyx(win, h, w);
      ptrs[i].x = x;
      ptrs[i].y = y;
      ptrs[i].w = w;
      ptrs[i].h = h;
      sprintf(temp, "Ventana numero %d", i + 1);
      strcpy(ptrs[i].label, temp);
      ptrs[i].label_color = i + 1;
      if(i + 1 == n)
        ptrs[i].next = panels[0];
      else
        ptrs[i].next = panels[i + 1];
      set_panel_userptr(panels[i], &amp;ptrs[i]);
    }
}

/* Muestra la ventana con un borde y una etiqueta */
void win_show(WINDOW *win, char *label, int label_color)
{ int startx, starty, height, width;

  getbegyx(win, starty, startx);
  getmaxyx(win, height, width);

  box(win, 0, 0);
  mvwaddch(win, 2, 0, ACS_LTEE);
  mvwhline(win, 2, 1, ACS_HLINE, width - 2);
  mvwaddch(win, 2, width - 1, ACS_RTEE);

  print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
}

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</pre>
</div>

<p>
Concéntrese en el bucle <code>while</code> principal. Una vez que se descubre
que tecla se ha pulsado, se toma la accion correspondiente. Si se
presiona 'r' se inicia el modo de tamaño. Después de esto, los
nuevos tamaños se actualizan a medida que el usuario presiona las
teclas de flecha. Cuando el usuario pulsa &lt;ENTER&gt; termina la
presente selección y el panel cambia de tamaño utilizando el
concepto explicado anteriormente. Dentro del modo de tamaño el
programa no muestra cómo se redimensiona la ventana. Se deja como
ejercicio para el lector imprimir un borde de puntos mientras se
cambia el tamaño a una nueva posición.
</p>

<p>
Cuando el usuario presiona 'm' inicia el modo de movimiento. Esto
es un poco más simple que el cambio de tamaño. Cuando pulsa las
teclas de flecha se actualiza la nueva posición y al presionar
&lt;ENTER&gt; el panel es movido llamando a la función <code>move_panel()</code>.
</p>

<p>
En este programa los datos de usuario representados como
<code>PANEL_DATA</code>, juega papel muy importante en la búsqueda de la
información asociada a un panel. Como está escrito en los
comentarios, <code>PANEL_DATA</code> almacena el tamaño del panel, la
etiqueta, color de la etiqueta y un puntero al siguiente panel en
el ciclo.
</p>
</div>
</div>
<div id="outline-container-sec-17-6" class="outline-3">
<h3 id="sec-17-6">16.6. Ocultar y Mostrar Paneles</h3>
<div class="outline-text-3" id="text-17-6">
<p>
Un panel se puede ocultar mediante el uso de la función
<code>hide_panel()</code>. Esta función simplemente lo quita de la pila de
paneles, de esta forma lo oculta en pantalla cuando llama a
<code>update_panels()</code> y <code>doupdate()</code>. Esto no destruye la estructura
<code>PANEL</code> asociada con el panel oculto. Puede mostrar nuevamente el
panel utilizando la funcion <code>show_panel()</code>.
</p>

<p>
El siguiente programa muestra como ocultar paneles. Pulse 'a' o 'b'
o 'c' para mostrar u ocultar la primera, segunda y tercera ventana
respectivamente. Se utilizan los datos de usuario con la pequeña
variable <code>hide</code>, que realiza un seguimiento de si la ventana está
oculta o no. Por alguna razón la función <code>panel_hidden()</code> que
indica si un panel está oculto o no, no está funcionando. Un
informe de error fue también presentado por Michael Andres <a href="http://www.geocrawler.com/archives/3/344/1999/9/0/2643549/">aqui</a>
</p>

<p>
<a href="ncurses_programs/panels/panel_hide.c"><b>Ejemplo 17. Ocultar y Mostrar Paneles</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;panel.h&gt;
#include &lt;string.h&gt;

typedef struct _PANEL_DATA {
  int hide;   /* TRUE si el panel esta oculto */
}PANEL_DATA;

#define NLINES 10
#define NCOLS 40

void init_wins(WINDOW **wins, int n);
void win_show(WINDOW *win, char *label, int label_color);
void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

int main()
{ WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  PANEL_DATA panel_datas[3];
  PANEL_DATA *temp;
  int ch;

  /* Inicializar curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Inicializar todos los colores */
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_BLUE, COLOR_BLACK);
  init_pair(4, COLOR_CYAN, COLOR_BLACK);

  init_wins(my_wins, 3);

  /* Unir un panel a cada ventana */      /* Ordenar de abajo hacia arriba  */
  my_panels[0] = new_panel(my_wins[0]);   /* Agregar 0, orden: stdscr-0     */
  my_panels[1] = new_panel(my_wins[1]);   /* Agregar 1, orden: stdscr-0-1   */
  my_panels[2] = new_panel(my_wins[2]);   /* Agregar 2, orden: stdscr-0-1-2 */

  /* Inicializa datos de panel diciendo que no hay nada oculto */
  panel_datas[0].hide = FALSE;
  panel_datas[1].hide = FALSE;
  panel_datas[2].hide = FALSE;

  set_panel_userptr(my_panels[0], &amp;panel_datas[0]);
  set_panel_userptr(my_panels[1], &amp;panel_datas[1]);
  set_panel_userptr(my_panels[2], &amp;panel_datas[2]);

  /* Actualizar el orden de apilamiento. El 2nd panel estara en la parte superior */
  update_panels();

  /* Mostrar en la pantalla */
  attron(COLOR_PAIR(4));
  mvprintw(LINES - 3, 0, "Mostrar u ocultar una ventana con 'a'(primer ventana)  'b'(segunda ventana)  'c'(tercer ventana)");
  mvprintw(LINES - 1, 0, "F1 para salir");

  attroff(COLOR_PAIR(4));
  doupdate();

  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case 'a':
            temp = (PANEL_DATA *)panel_userptr(my_panels[0]);
            if(temp-&gt;hide == FALSE)
              { hide_panel(my_panels[0]);
                temp-&gt;hide = TRUE;
              }
            else
              { show_panel(my_panels[0]);
                temp-&gt;hide = FALSE;
              }
            break;
        case 'b':
          temp = (PANEL_DATA *)panel_userptr(my_panels[1]);
          if(temp-&gt;hide == FALSE)
            { hide_panel(my_panels[1]);
              temp-&gt;hide = TRUE;
            }
          else
            { show_panel(my_panels[1]);
              temp-&gt;hide = FALSE;
            }
          break;
        case 'c':
          temp = (PANEL_DATA *)panel_userptr(my_panels[2]);
          if(temp-&gt;hide == FALSE)
            { hide_panel(my_panels[2]);
              temp-&gt;hide = TRUE;
            }
          else
            {   show_panel(my_panels[2]);
              temp-&gt;hide = FALSE;
            }
          break;
        }
      update_panels();
      doupdate();
    }
  endwin();
  return 0;
}

/* Colocar todas las ventanas */
void init_wins(WINDOW **wins, int n)
{ int x, y, i;
  char label[80];

  y = 2;
  x = 10;
  for(i = 0; i &lt; n; ++i)
    { wins[i] = newwin(NLINES, NCOLS, y, x);
      sprintf(label, "Ventana Numero %d", i + 1);
      win_show(wins[i], label, i + 1);
      y += 3;
      x += 7;
    }
}

/* Muestra la ventana con un borde y una etiqueta */
void win_show(WINDOW *win, char *label, int label_color)
{ int startx, starty, height, width;

  getbegyx(win, starty, startx);
  getmaxyx(win, height, width);

  box(win, 0, 0);
  mvwaddch(win, 2, 0, ACS_LTEE);
  mvwhline(win, 2, 1, ACS_HLINE, width - 2);
  mvwaddch(win, 2, width - 1, ACS_RTEE);

  print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
}

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-17-7" class="outline-3">
<h3 id="sec-17-7">16.7. Funciones <code>panel_above()</code> y <code>panel_below()</code></h3>
<div class="outline-text-3" id="text-17-7">
<p>
Puede utilizar las funciones <code>panel_above()</code> y <code>panel_below()</code> para
averiguar el panel superiar e inferiar a un panel. Si el argumento
de estas funciones es <code>NULL</code>, devuelven un puntero al panel
inferior y superior, respectivamente.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18">17. Libreria Menu</h2>
<div class="outline-text-2" id="text-18">
<p>
La libreria menu proporciona una buena extensión al curses básico, a
través de esta se pueden crear menús. Proporciona un conjunto de
funciones para crear menús. Pero tiene que personalizarce para dar
un aspecto más agradable, con colores etc. Entremos a los detalles.
</p>

<p>
Un menú es una visualización de pantalla que ayuda al usuario a
elegir un cierto subconjunto de un conjunto dado de elementos. Para
ponerlo simple, un menú es una colección de elementos de los que se
pueden elegir uno o más elementos. Algunos lectores podrían no ser
conscientes de la capacidad de seliccion de elementos multiples.  La
libreria menu ofrece funcionalidad para escribir menús de los cuales
es usuario puede elegir más de un elemento. Esto se trata en una
sección posterior. Ahora es el momento para algunas nociones.
</p>
</div>
<div id="outline-container-sec-18-1" class="outline-3">
<h3 id="sec-18-1">17.1. Lo basico</h3>
<div class="outline-text-3" id="text-18-1">
<p>
Para crear menús, primero debe crear elementos, y luego colocar el
menú en la pantalla. Después de eso, todo el procesamiento de las
respuestas del usuario es hecho en una función elegante llamada
<code>menu_driver()</code> que es el caballo de trabajo de cualquier programa
de menú.
</p>

<p>
El flujo general de control de un programa de menú se parece a
esto.
</p>

<ol class="org-ol">
<li>Inicializar curses
</li>
</ol>

<ol class="org-ol">
<li>Cree elementos usando <code>new_item()</code>. Puede especificar un nombre
y una descripción de los elementos.
</li>
</ol>

<ol class="org-ol">
<li>Crear el menú con <code>new_menu()</code> especificando los elementos que
se agregaran a este.
</li>
</ol>

<ol class="org-ol">
<li>Publicar el menú con <code>menu_post()</code> y refrescar la pantalla.
</li>
</ol>

<ol class="org-ol">
<li>Procesar las las peticiones de los usuarios con un bucle y hacer
las actualizaciones necesarias al menú con <code>menu_driver</code>.
</li>
</ol>

<ol class="org-ol">
<li>Quitar el menú con <code>menu_unpost()</code>
</li>
</ol>

<ol class="org-ol">
<li>Liberar la memoria asignada al menú con <code>free_menu()</code>
</li>
</ol>

<ol class="org-ol">
<li>Liberar la memoria asignada a los elementos con <code>free_item()</code>
</li>
</ol>

<ol class="org-ol">
<li>Finalizar curses
</li>
</ol>


<p>
Vamos a ver un programa que imprime un menú sencillo y actualiza la
selección actual con las teclas de flecha arriba, abajo.
</p>
</div>
</div>
<div id="outline-container-sec-18-2" class="outline-3">
<h3 id="sec-18-2">17.2. Compilación con la Libreria Menú</h3>
<div class="outline-text-3" id="text-18-2">
<p>
Para utilizar las funciones de libreria de menu, tiene que incluir
<code>menu.h</code> y enlazar el programa con la libreria menu mediante la
bandera <code>-lmenu</code> debe ser añadido junto con <code>-lncurses</code> en ese
orden.
</p>

<pre class="example">
#include &lt;menu.h&gt;
.
.
.

compilacion y enlace: gcc &lt;fichero del programa&gt; -lmenu -lncurses
</pre>

<p>
<a href="ncurses_programs/menus/menu_simple.c"><b>Ejemplo 18. Conceptos básicos de Menu</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;stdlib.h&gt;
#include &lt;curses.h&gt;
#include &lt;menu.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Eleccion 1",
  "Eleccion 2",
  "Eleccion 3",
  "Eleccion 4",
  "Salir",
};

int main()
{ ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;


  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));

  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);
  my_items[n_choices] = (ITEM *)NULL;

  my_menu = new_menu((ITEM **)my_items);
  mvprintw(LINES - 2, 0, "F1 para Salir");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1))
    {   switch(c)
        {   case KEY_DOWN:
            menu_driver(my_menu, REQ_DOWN_ITEM);
            break;
        case KEY_UP:
          menu_driver(my_menu, REQ_UP_ITEM);
          break;
        }
    }

  free_item(my_items[0]);
  free_item(my_items[1]);
  free_menu(my_menu);
  endwin();
}
</pre>
</div>

<p>
Este programa demuestra los conceptos básicos que intervienen en la
creación de un menú con libreria menu. Primero creamos los
elementos mediante <code>new_item()</code> y luego los agregamos al menu con
la funcion <code>new_menu()</code>. Después de publicar el menu y actualizar
la pantalla, inicia el bucle principal de procesamiento. Se lee la
entrada del usuario y se toma la acción correspondiente. La función
<code>menu_driver()</code> es el principal caballo de trabajo del sistema de
menus. El segundo parámetro para esta función dice lo que hay que
hacer con el menu. De acuerdo con el parámetro, <code>menu_driver()</code>
hace la tarea correspondiente. El valor puede ser ya sea una
solicitud de navegación, un carácter ASCII, o una clave especial
<code>KEY_MOUSE</code> asociada a un evento de ratón.
</p>

<p>
<code>menu_driver</code> acepta las siguientes solicitudes de navegación.
</p>

<pre class="example">
REQ_LEFT_ITEM      	 Mover un elemento a la izquierda.
REQ_RIGHT_ITEM     	 Mover un elemento a la derecha.
REQ_UP_ITEM        	 Mover un elemento hacia arriba.
REQ_DOWN_ITEM      	 Mover un elemento hacia abajo.
REQ_SCR_ULINE      	 Desplácese una línea arriba.
REQ_SCR_DLINE      	 Desplácese una línea abajo.
REQ_SCR_DPAGE      	 Desplazarse una página hacia arriba.
REQ_SCR_UPAGE      	 Desplazarse una página hacia abajo.
REQ_FIRST_ITEM     	 Mover al primer elemento.
REQ_LAST_ITEM      	 Mover al último elemento.
REQ_NEXT_ITEM      	 Mover al siguiente elemento.
REQ_PREV_ITEM      	 Mover al elemento anterior.
REQ_TOGGLE_ITEM    	 Seleccionar/deseleccionar un elemento.
REQ_CLEAR_PATTERN  	 Borrar el buffer de patrones menu.
REQ_BACK_PATTERN   	 Eliminar el carácter anterior desde el buffer de patrones.
REQ_NEXT_MATCH     	 Mover al elemento siguiente que coincida con el patron.
REQ_PREV_MATCH     	 Mover al elemento anterior que coincida con el patron.
</pre>

<p>
No se deje abrumar por el número de opciones. Vamos a verlos
lentamente una tras otro. Las opciones de interés en este ejemplo
son <code>REQ_UP_ITEM</code> y <code>REQ_DOWN_ITEM</code>. Estas dos opciones son pasadas
a <code>menu_driver</code>, que actualiza el elemento actual a un elemento
hacia arriba o hacia abajo, respectivamente.
</p>
</div>
</div>
<div id="outline-container-sec-18-3" class="outline-3">
<h3 id="sec-18-3">17.3. Menu Driver: El caballo de trabajo del sistema de menus</h3>
<div class="outline-text-3" id="text-18-3">
<p>
Como se ha visto en el ejemplo anterior, <code>menu_driver</code> juega un
papel importante en la actualización del menu. Es muy importante
comprender las diversas opciones y lo que hacen. Como se ha
explicado, el segundo parámetro de <code>menu_driver()</code> puede ser una
solicitud de navegación, un carácter imprimible o una clave
<code>KEY_MOUSE</code>. Vamos a analizar las diferentes solicitudes de
navegación.
</p>

<ul class="org-ul">
<li><code>REQ_LEFT_ITEM</code> y <code>REQ_RIGHT_ITEM</code>

<p>
Se puede visualizar un menu con varias columnas de más de un
ítem. Esto se realiza mediante la funcion <code>menu_format()</code>. Cuando
se muestra un menu de columnas múltiples estas peticiones hacen
que <code>menu_driver</code> de menu mueva la eleccion actual a la izquierda
o la derecha.
</p>
</li>

<li><code>REQ_UP_ITEM</code> and <code>REQ_DOWN_ITEM</code>

<p>
Estas dos opciones se han visto en el ejemplo anterior. Cuando se
pasan estas opciones, hacen que <code>menu_driver</code> mueva la eleccion
actual un elemento hacia arriba o hacia abajo.
</p>
</li>

<li>Opciones <code>REQ_SCR_*</code>

<p>
Las cuatro opciones <code>REQ_SCR_ULINE</code>, <code>REQ_SCR_DLINE</code>,
<code>REQ_SCR_DPAGE</code>, <code>REQ_SCR_UPAGE</code> están relacionadas con el
desplazamiento. Si no se pueden mostrar todos los elementos de el
menu en la subventana menu, el menu es desplazable. Estas
solicitudes se pueden pasar a <code>menu_driver</code> para realizar el
desplazamiento, ya sea por línea o por pagina hacia arriba o
hacia abajo respectivamente.
</p>
</li>

<li><code>REQ_FIRST_ITEM</code>, <code>REQ_LAST_ITEM</code>, <code>REQ_NEXT_ITEM</code> and
<code>REQ_PREV_ITEM</code>

<p>
Estas solicitudes se explica por sí mismas.
</p>
</li>

<li><code>REQ_TOGGLE_ITEM</code>

<p>
Quando se pasa esta solicitud, se alterna la selección actual.
Solo se utiliza esta opción en un menu de valores múltiples. Para
utilizar esta solicitud la opción <code>O_ONEVALUE</code> debe estar
apagada. Esta opción puede ser apagar o encender con
<code>set_menu_opts()</code>.
</p>
</li>
</ul>

<ul class="org-ul">
<li><i>Solicitud por Patrones</i>

<p>
Cada menu tiene una buffer de patrones asociado, que se utiliza
para encontrar la coincidencia más cercana a los caracteres ASCII
introducidos por el usuario. Siempre que se pasan caracteres
ASCII a <code>menu_driver</code>, se colocan el el buffer de patrones. Este
inteta encontrar la coincida más cercana con el patrón en la
lista de elementos y mueve la seleccion a ese elemento. La
solicitud <code>REQ_CLEAR_PATTERN</code> limpia el buffer de patrones. La
solicitud <code>REQ_BACK_PATTERN</code> borra el carácter anterior en el
buffer de patrones. En caso de que el patrón coincida con mas de
un elemento se puede rotar por los elementos coincidentes con
<code>REQ_NEXT_MATCH</code> y <code>REQ_PREV_MATCH</code> que mueven la selección a la
conicidencia siguiente y anterior, respectivamente.
</p>
</li>
</ul>

<ul class="org-ul">
<li><i>Solicitudes del raton</i>

<p>
En caso de solicitudes <code>KEY_MOUSE</code>, de acuerdo con la posición
del ratón se toma una acción en consecuencia. La acción a tomar
se explica en la página man como,
</p>

<blockquote>
<p>
Si el segundo argumento es la clave especial <code>KEY_MOUSE</code>, el
evento de ratón asociado se traduce en una de las anteriores
solicitudes pre-definidas. Actualmente, solo se manejan los
clics en la ventana de usuario (por ejemplo, dentro del área de
visualización del menu o la decoracion de ventana). Si hace
clic sobre la zona de visualizacion del menu, se genera un
<code>REQ_SCR_ULINE</code>, con doble clic se genera <code>REQ_SCR_UPAGE</code> y con
triple clic <code>REQ_FIRST_ITEM</code>. Si hace clic por debajo de la
zona de visualización del menu, se genera un <code>REQ_SCR_DLINE</code>,
un doble clic <code>REQ_SCR_DPAGE</code> y un triple click genera
<code>REQ_LAST_ITEM</code>.  Si hace clic en un elemento dentro del área
de visualización del menu, el cursor del menu se coloca en
dicho elemento.
</p>
</blockquote>
</li>
</ul>


<p>
Cada una de las solicitudes anteriores se explicará en las
siguientes líneas con varios ejemplos siempre que sea apropiado.
</p>
</div>
</div>
<div id="outline-container-sec-18-4" class="outline-3">
<h3 id="sec-18-4">17.4. Ventanas de Menu</h3>
<div class="outline-text-3" id="text-18-4">
<p>
Cada menu creado se asocia con una ventana y una sub ventana. La
ventana menu muestra cualquier título o borde asociado con el
menu. La ventana submenu muestra los elementos del menu actualmente
disponible para su selección. Pero no especificamos ninguna ventana
o subventana en el ejemplo. Cuando no se especifica una ventana,
<code>stdscr</code> se toma como la ventana principal y, el sistema de menus
calcula el tamaño requerido de la subventana para la visualización
de elementos. A continuación se muestran los elementos en la
subventana. Asi que vamos a jugar con estas ventanas, mostrado un
menu con un borde y un título.
</p>

<p>
<a href="ncurses_programs/menus/menu_win.c"><b>Ejemplo 19. Uso de Ventanas Menu</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;menu.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Opcion 1",
  "Opcion 2",
  "Opcion 3",
  "Opcion 4",
  "Salir",
  (char *)NULL,
};

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

int main()
{ ITEM **my_items;
  int c;
  MENU *my_menu;
  WINDOW *my_menu_win;
  int n_choices, i;

  /* Inicializa curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);

  /* Crea los elementos */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);

  /* Crea el menu */
  my_menu = new_menu((ITEM **)my_items);

  /* Crea la ventana que sera asociada con el menu */
  my_menu_win = newwin(10, 40, 4, 4);
  keypad(my_menu_win, TRUE);

  /* Establece la ventana principal y la subventana */
  set_menu_win(my_menu, my_menu_win);
  set_menu_sub(my_menu, derwin(my_menu_win, 6, 38, 3, 1));

  /* Establece la marca del menu con la cadena " * " */
  set_menu_mark(my_menu, " * ");

  /* Imprime un margen alrededor de la ventana pricipal e imprime el titulo */
  box(my_menu_win, 0, 0);
  print_in_middle(my_menu_win, 1, 0, 40, "Mi Menu", COLOR_PAIR(1));
  mvwaddch(my_menu_win, 2, 0, ACS_LTEE);
  mvwhline(my_menu_win, 2, 1, ACS_HLINE, 38);
  mvwaddch(my_menu_win, 2, 39, ACS_RTEE);
  mvprintw(LINES - 2, 0, "F1 para Salir");
  refresh();

  /* Publica el menu */
  post_menu(my_menu);
  wrefresh(my_menu_win);

  while((c = wgetch(my_menu_win)) != KEY_F(1)){
    switch(c){
    case KEY_DOWN:
      menu_driver(my_menu, REQ_DOWN_ITEM);
      break;
    case KEY_UP:
      menu_driver(my_menu, REQ_UP_ITEM);
      break;
    }
    wrefresh(my_menu_win);
  }

  /* remueve el menu y libera toda la memoria tomada */
  unpost_menu(my_menu);
  free_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  endwin();
}

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</pre>
</div>

<p>
En este ejemplo se crea un menu con un título, margen, una
fantastica línea separa el título y los elementos. Como puede ver,
con el fin de unir una ventana a un menu se utiliza la función
<code>set_menu_win()</code>. A continuación agregamos tambien la ventana
secundaria. Esto despliega los elementos en la subventana. También
puede establecer la cadena de marca que se muestra a la izquierda
del elemento seleccionado con <code>set_menu_mark()</code>.
</p>
</div>
</div>
<div id="outline-container-sec-18-5" class="outline-3">
<h3 id="sec-18-5">17.5. Desplazamiento en Menus</h3>
<div class="outline-text-3" id="text-18-5">
<p>
Si la subventana dada no es lo suficientemente grande para mostrar
todo los elementos, el menu serán desplazable. Cuando se está en el
último elemento de la lista actual, si envía <code>REQ_DOWN_ITEM</code>, sera
traducido como <code>REQ_SCR_DLINE</code> y el menu se desplaza un elemento.
Puede pasar manualmente operaciones <code>REQ_SCR_</code> para realizar el
desplazamiento. Veamos cómo se puede realizar.
</p>

<p>
<a href="ncurses_programs/menus/menu_scroll.c"><b>Ejemplo 20. Menu con Desplazamiento</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;curses.h&gt;
#include &lt;menu.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Opcion 1",
  "Opcion 2",
  "Opcion 3",
  "Opcion 4",
  "Opcion 5",
  "Opcion 6",
  "Opcion 7",
  "Opcion 8",
  "Opcion 9",
  "Opcion 10",
  "Salir",
  (char *)NULL,
};

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

int main(){
  ITEM **my_items;
  int c;
  MENU *my_menu;
  WINDOW *my_menu_win;
  int n_choices, i;

  /* Inicializa curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_CYAN, COLOR_BLACK);

  /* Crea los elementos */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);

  /* Crea el menu */
  my_menu = new_menu((ITEM **)my_items);

  /* Crea la ventana que sera asociada con el menu */
  my_menu_win = newwin(10, 40, 4, 4);
  keypad(my_menu_win, TRUE);

  /* Establece la ventana principal y la subventana */
  set_menu_win(my_menu, my_menu_win);
  set_menu_sub(my_menu, derwin(my_menu_win, 6, 38, 3, 1));
  set_menu_format(my_menu, 5, 1);

  /* Establece la marca del menu con la cadena " * " */
  set_menu_mark(my_menu, " * ");

  /* Imprime un margen alrededor de la ventana pricipal e imprime el titulo */
  box(my_menu_win, 0, 0);
  print_in_middle(my_menu_win, 1, 0, 40, "Mi Menu", COLOR_PAIR(1));
  mvwaddch(my_menu_win, 2, 0, ACS_LTEE);
  mvwhline(my_menu_win, 2, 1, ACS_HLINE, 38);
  mvwaddch(my_menu_win, 2, 39, ACS_RTEE);

  /* Publica el menu */
  post_menu(my_menu);
  wrefresh(my_menu_win);

  attron(COLOR_PAIR(2));
  mvprintw(LINES - 2, 0, "Use PageUp y PageDown para desplazar una pagina de elementos abajo o arriba");
  mvprintw(LINES - 1, 0, "Las flechas para navegar (F1 Para Salir)");
  attroff(COLOR_PAIR(2));
  refresh();

  while((c = wgetch(my_menu_win)) != KEY_F(1)){
    switch(c){
    case KEY_DOWN:
      menu_driver(my_menu, REQ_DOWN_ITEM);
      break;
    case KEY_UP:
      menu_driver(my_menu, REQ_UP_ITEM);
      break;
    case KEY_NPAGE:
      menu_driver(my_menu, REQ_SCR_DPAGE);
      break;
    case KEY_PPAGE:
      menu_driver(my_menu, REQ_SCR_UPAGE);
      break;
    }
    wrefresh(my_menu_win);
  }

  /* Remueve el menu y libera toda la memoria tomada */
  unpost_menu(my_menu);
  free_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  endwin();
}

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color){
  int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</pre>
</div>

<p>
Este programa se explica por sí. En este ejemplo, el número de
opciones ha sido aumentado a diez, que es más grande que el tamaño
que nuestra subventana puede albergar (6 elementos). Este mensaje
tiene que ser transmitido explícitamente al sistema de menus con la
función <code>set_menu_format()</code>. Aquí especificamos el número de filas
y columnas que queremos que se muestren para una sola página.
Podemos especificar cualquier número de elementos a mostrar, en la
variable rows, si este es menor que la altura de la subventana. Si
la tecla presionada por el usuario es PAGE UP o PAGE DOWN, el menu
se desplaza una página debido a la las solicitudes (<code>REQ_SCR_DPAGE</code>
y <code>REQ_SCR_UPAGE</code>) dadas a <code>menu_driver()</code>.
</p>
</div>
</div>
<div id="outline-container-sec-18-6" class="outline-3">
<h3 id="sec-18-6">17.6. Menu de Multiples Columnas</h3>
<div class="outline-text-3" id="text-18-6">
<p>
En el ejemplo anterior se vio cómo utilizar la función
<code>set_menu_format()</code>. No mencioné lo que hace la variable <code>cols</code>
(tercer parámetro). Si la subventana es lo suficientemente amplia,
puede optar por mostrar más de un elemento por fila. Esto se puede
especificar en la variable <code>cols</code>. Para aclarar las cosas, El
siguiente ejemplo no muestra la descripcion de los elementos.
</p>

<p>
<a href="ncurses_programs/menus/menu_multi_column.c"><b>Ejemplo 21. Menu con Columnas Multiples</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;curses.h&gt;
#include &lt;menu.h&gt;
#include &lt;stdlib.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Opcion 1",  "Opcion 2",  "Opcion 3",  "Opcion 4",  "Opcion 5",
  "Opcion 6",  "Opcion 7",  "Opcion 8",  "Opcion 9",  "Opcion 10",
  "Opcion 11", "Opcion 12", "Opcion 13", "Opcion 14", "Opcion 15",
  "Opcion 16", "Opcion 17", "Opcion 18", "Opcion 19", "Opcion 20",
  "Salir",
  (char *)NULL,
};

int main(){
  ITEM **my_items;
  int c;
  MENU *my_menu;
  WINDOW *my_menu_win;
  int n_choices, i;

  /* Tnicializa curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_CYAN, COLOR_BLACK);

  /* Crea los elementos */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);

  /* Crea el menu */
  my_menu = new_menu((ITEM **)my_items);

  /* Configura la opcion del menu para no mostar la descripcion */
  menu_opts_off(my_menu, O_SHOWDESC);

  /* Crea la ventana que sera asociada al menu */
  my_menu_win = newwin(10, 70, 4, 4);
  keypad(my_menu_win, TRUE);

  /* Establece la vetana principal y la subventana */
  set_menu_win(my_menu, my_menu_win);
  set_menu_sub(my_menu, derwin(my_menu_win, 6, 68, 3, 1));
  set_menu_format(my_menu, 5, 3);
  set_menu_mark(my_menu, " * ");

  /* Imprime un margen alrededor de la ventana pricipal e imprime el titulo */
  box(my_menu_win, 0, 0);

  attron(COLOR_PAIR(2));
  mvprintw(LINES - 3, 0, "Use PageUp y PageDown para el desplazamiento");
  mvprintw(LINES - 2, 0, "Use Las flechas para navegar (F1 Para Salir)");
  attroff(COLOR_PAIR(2));
  refresh();

  /* Publica el menu */
  post_menu(my_menu);
  wrefresh(my_menu_win);

  while((c = wgetch(my_menu_win)) != KEY_F(1)){
    switch(c){
    case KEY_DOWN:
      menu_driver(my_menu, REQ_DOWN_ITEM);
      break;
    case KEY_UP:
      menu_driver(my_menu, REQ_UP_ITEM);
      break;
    case KEY_LEFT:
      menu_driver(my_menu, REQ_LEFT_ITEM);
      break;
    case KEY_RIGHT:
      menu_driver(my_menu, REQ_RIGHT_ITEM);
      break;
    case KEY_NPAGE:
      menu_driver(my_menu, REQ_SCR_DPAGE);
      break;
    case KEY_PPAGE:
      menu_driver(my_menu, REQ_SCR_UPAGE);
      break;
    }
    wrefresh(my_menu_win);
  }

  /* Remueve el menu y libera toda la memoria tomada */
  unpost_menu(my_menu);
  free_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  endwin();
}
</pre>
</div>

<p>
Ver la llamada a la función = set<sub>menu</sub><sub>format</sub>()=. Especifica el
número de columnas a ser 3, mostrando de este modo 3 artículos por fila. Tenemos
También apagado las descripciones que muestran con la función
menu<sub>opts</sub><sub>off</sub>()=. Hay par de funciones = set<sub>menu</sub><sub>opts</sub>()=,
menu<sub>opts</sub><sub>on</sub>()= y = menu<sub>opts</sub>()= que se pueden utilizar para manipular
opciones de menu. Las siguientes opciones de menu se pueden especificar.
</p>

<dl class="org-dl">
<dt> <code>O_ONEVALUE</code>   </dt><dd>Solo un elemento puede seleccionarse para este
menu.
</dd>

<dt> <code>O_SHOWDESC</code>   </dt><dd>Mostrar las descripciones de los elementos
cuando el menu es publicado.
</dd>

<dt> <code>O_ROWMAJOR</code>   </dt><dd>Mostrar el menu en orden de importancia de las
filas.
</dd>

<dt> <code>O_IGNORECASE</code> </dt><dd>Ignorar el caso en cuando el patron coincida.
</dd>

<dt> <code>O_SHOWMATCH</code>  </dt><dd>Mueve el cursor dentro del nombre del elemento,
mientras el patron coincide.
</dd>

<dt> <code>O_NONCYCLIC</code>  </dt><dd>No rotar entre el siguiente/anterior elemento,
solicitar por por el otro extremo del menu.
</dd>
</dl>


<p>
Todas las opciones están habilitadas de forma predeterminada. Puede
cambiar los atributos específicos a encendido o apagado con las
funciones <code>menu_opts_on()</code> y <code>menu_opts_off()</code>. También puede
utilizar <code>set_menu_opts()</code> para especificar directamente las
opciones. El argumento para esta función debe ser un valor OR de
algunas de las constantes anteriores. Puede utilazar la función
<code>menu_opts()</code> para optener las opciones actuales de un menu.
</p>
</div>
</div>
<div id="outline-container-sec-18-7" class="outline-3">
<h3 id="sec-18-7">17.7. Menu de Valores Multiples</h3>
<div class="outline-text-3" id="text-18-7">
<p>
Tal vez se pregunte lo que ocurre si apaga la opción <code>O_ONEVALUE</code>.
Esto crea un menu de valores multiples. Eso significa que se puede
seleccionar más de un elemento. Esto nos lleva a la solicitud
<code>REQ_TOGGLE_ITEM</code>. Veamoslo en acción.
</p>

<p>
<a href="ncurses_programs/menus/menu_toggle.c"><b>Ejemplo 22. Menu de Valores Multiples</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;curses.h&gt;
#include &lt;menu.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Opcion 1",
  "Opcion 2",
  "Opcion 3",
  "Opcion 4",
  "Opcion 5",
  "Opcion 6",
  "Opcion 7",
  "Salir",
};

int main(){
  ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;

  /* Inicializa curses */
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Inicializa elementos */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);
  my_items[n_choices] = (ITEM *)NULL;

  my_menu = new_menu((ITEM **)my_items);

  /* Crea el menu de valores multiples */
  menu_opts_off(my_menu, O_ONEVALUE);

  mvprintw(LINES - 3, 0, "Use &lt;SPACE&gt; para seleccionar o deseleccionar un elemento.");
  mvprintw(LINES - 2, 0, "&lt;ENTER&gt; para ver los elementos seleccionados(F1 Para Salir)");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1)){
    switch(c){
    case KEY_DOWN:
      menu_driver(my_menu, REQ_DOWN_ITEM);
      break;
    case KEY_UP:
      menu_driver(my_menu, REQ_UP_ITEM);
      break;
    case ' ':
      menu_driver(my_menu, REQ_TOGGLE_ITEM);
      break;
    case 10:    /* Enter */
      { char temp[200];
        ITEM **items;

        items = menu_items(my_menu);
        temp[0] = '\0';
        for(i = 0; i &lt; item_count(my_menu); ++i)
          if(item_value(items[i]) == TRUE){
            strcat(temp, item_name(items[i]));
            strcat(temp, " ");
          }
        move(20, 0);
        clrtoeol();
        mvprintw(20, 0, temp);
        refresh();
      }
      break;
    }
  }

  free_item(my_items[0]);
  free_item(my_items[1]);
  free_menu(my_menu);
  endwin();
}
</pre>
</div>

<p>
Menos mal, un montón de nuevas funciones. Vamos a tomar una tras
otra.  En primer lugar, <code>REQ_TOGGLE_ITEM</code>. En un menu de valores
multiples, se debe permitir a el usuario seleccionar o anular más
de un elemento. La solicitud <code>REQ_TOGGLE_ITEM</code> alterna la selección
actual. En esto caso cuando se pulsa espacio se envia la solicitud
<code>REQ_TOGGLE_ITEM</code> a <code>menu_driver</code> para conseguir el resultado.
</p>

<p>
Ahora, cuando el usuario presiona &lt;ENTER&gt; se muestran los elementos
actualmente seleccionados. Primero debemos encontrar los elementos
asociados con el menu empleando la función <code>menu_items()</code>. A
continuación, recorrer los elementos para saber si el elemento se
selecciona o no. La función <code>item_value()</code> devuelve <code>TRUE</code> si el
elemento se ha seleccionado. La función <code>item_count()</code> devuelve el
número de elementos en el menu. El objeto nombre se puede optener
con <code>item_name()</code>. También puede optener la descripción asociado
con un elemento utilizando <code>item_description()</code>.
</p>
</div>
</div>
<div id="outline-container-sec-18-8" class="outline-3">
<h3 id="sec-18-8">17.8. Opciones de Menu</h3>
<div class="outline-text-3" id="text-18-8">
<p>
Bueno, a estas alturas ya debe estar buscando alguna diferencia en
su menu, con un montón de funcionalidades. Lo sé. Quiere Colores
!!!. Quiere crear menus agradables similares a las de aquellos
<a href="http://www.jersey.net/~debinjoe/games/">juegos dos</a> en modo texto. Puede utilizar las funciones
<code>set_menu_fore()</code> y <code>set_menu_back()</code> para cambiar el atributo de
los elementos seleccionados y no seleccionados. Los nombres son
engañosos. No cambian el primer plano o el fondo del menu lo cual
los haria menos utiles.
</p>

<p>
Puede utilizar la función <code>set_menu_grey()</code> para establecer el
atributo de pantalla para los elementos no seleccionables en el
menu. Esto nos lleva a la interesante opción para un unico elemento
<code>O_SELECTABLE</code>. Podemos apagar dicha opcion con la función
<code>item_opts_off()</code> y luego el elemento deja de ser seleccionable.
Esto es parecido a atenuar un elemento en alquellos fantasticos
menus.  Vamos a poner estos conceptos en práctica con este ejemplo
</p>

<p>
<a href="ncurses_programs/menus/menu_attrib.c"><b>Ejemplo 23. Opciones del Menu</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;menu.h&gt;
#include &lt;stdlib.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Opcion 1",
  "Opcion 2",
  "Opcion 3",
  "Opcion 4",
  "Opcion 5",
  "Opcion 6",
  "Opcion 7",
  "Salir",
};

int main(){
  ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;

  /* Inicializa curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_MAGENTA, COLOR_BLACK);

  /* Inicializa los elementos */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);
  my_items[n_choices] = (ITEM *)NULL;
  item_opts_off(my_items[3], O_SELECTABLE);
  item_opts_off(my_items[6], O_SELECTABLE);

  /* Crea el menu */
  my_menu = new_menu((ITEM **)my_items);

  /* Establece el primer plano y el fondo del menu */
  set_menu_fore(my_menu, COLOR_PAIR(1) | A_REVERSE);
  set_menu_back(my_menu, COLOR_PAIR(2));
  set_menu_grey(my_menu, COLOR_PAIR(3));

  /* Post the menu */
  mvprintw(LINES - 3, 0, "Presione &lt;ENTER&gt; para ver la opcion seleccionada");
  mvprintw(LINES - 2, 0, "Flechas Arriba y Abajo para navegar (F1 para Salir)");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1)){
    switch(c){
    case KEY_DOWN:
      menu_driver(my_menu, REQ_DOWN_ITEM);
      break;
    case KEY_UP:
      menu_driver(my_menu, REQ_UP_ITEM);
      break;
    case 10: /* Enter */
      move(20, 0);
      clrtoeol();
      mvprintw(20, 0, "El elemento seleccionado es : %s",
               item_name(current_item(my_menu)));
      pos_menu_cursor(my_menu);
      break;
    }
  }

  unpost_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  free_menu(my_menu);
  endwin();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-18-9" class="outline-3">
<h3 id="sec-18-9">17.9. El conveniente Puntero de Usuario</h3>
<div class="outline-text-3" id="text-18-9">
<p>
Podemos asociar un puntero de usuario a cada elemento del
menu. Esto funciona de la misma forma que en los paneles. Esto no
es tocado por el sistema de menus. Puede almacenar cualquier cosa
en estos. Yo suelo utilizarlo para almacenar la función a ejecutar
cuando se elige la opcion de menu (Esta seleccionada y el usuario
pulsa &lt;ENTER&gt;);
</p>


<p>
<a href="ncurses_programs/menus/menu_userptr.c"><b>Ejemplo 24. Menu con Puntero de Usuario</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;curses.h&gt;
#include &lt;menu.h&gt;
#include &lt;stdlib.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Opcion 1",
  "Opcion 2",
  "Opcion 3",
  "Opcion 4",
  "Opcion 5",
  "Opcion 6",
  "Opcion 7",
  "Salir",
};

void func(char *name);

int main(){
  ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;

  /* Inicializa curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_MAGENTA, COLOR_BLACK);

  /* Inicializa los elementos */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i){
    my_items[i] = new_item(choices[i], choices[i]);
    /* Establece el puntero de usuario */
    set_item_userptr(my_items[i], func);
  }
  my_items[n_choices] = (ITEM *)NULL;

  /* Crea el menu */
  my_menu = new_menu((ITEM **)my_items);

  /* Publica el menu */
  mvprintw(LINES - 3, 0, "Presione &lt;ENTER&gt; para ver la opcion seleccionada");
  mvprintw(LINES - 2, 0, "Flechas Arriba y Abajo para navegar (F1 para Salir)");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1)){
    switch(c){
    case KEY_DOWN:
      menu_driver(my_menu, REQ_DOWN_ITEM);
      break;
    case KEY_UP:
      menu_driver(my_menu, REQ_UP_ITEM);
      break;
    case 10: /* Enter */
      { ITEM *cur;
        void (*p)(char *);

        cur = current_item(my_menu);
        p = item_userptr(cur);
        p((char *)item_name(cur));
        pos_menu_cursor(my_menu);
        break;
      }
      break;
    }
  }

  unpost_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  free_menu(my_menu);
  endwin();
}

void func(char *name){
  move(20, 0);
  clrtoeol();
  mvprintw(20, 0, "El elemento seleccionado es : %s", name);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19">18. Libreria Form</h2>
<div class="outline-text-2" id="text-19">
<p>
Bien. Si usted ha visto esos formularios en páginas web que toman la
entrada del usuario y hacen varios tipos de cosas, puede que se
pregunte cómo crear formularios en pantalla en modo texto. Es
bastante difícil escribir esos elegantes formularios en ncurses
puro. La libreria form intenta proporcionar un marco de trabajo
básico para construir y mantener formularios con facilidad. Cuenta
con gran cantidad de características (funciones) que gestionan la
validación, expansión dinámica de campos, etc.. Veamos esto en pleno
desarrollo.
</p>

<p>
Un formulario es una colección de campos; Cada campo puede ser o
bien una etiqueta (texto estático) o un lugar de entrada de datos.
La libreria también proporciona funciones para dividir los
formularios en varias páginas.
</p>
</div>
<div id="outline-container-sec-19-1" class="outline-3">
<h3 id="sec-19-1">18.1. Lo basico</h3>
<div class="outline-text-3" id="text-19-1">
<p>
Los formularios se crean en la misma manera que los menus. Primero
se crean los campos relacionados con el formulario con
<code>new_field()</code>.  Puede configurar las opciones de los campos, de
manera que se pueden mostrar con ciertos atributos, validar el
contenido antes de perder el foco del campo etc.. A continuación,
los campos se agregan al formulario. Después de esto, el formulario
puede ser publicado y está listo para recibir entradas. En líneas
similares a <code>menu_driver()</code>, los formularios se manejan con
<code>form_driver()</code>. Podemos enviar solicitudes a <code>form_driver</code> para
mover el foco a un cierto campo, mover el cursor al final del campo
etc.. Después de que el usuario introduce los valores en los campos
y se termina la validación, su puede remover el formulario liberar
la menoria asignada.
</p>

<p>
El flujo de control general de un programa de formulario se vee
como esto.
</p>

<ol class="org-ol">
<li>Inicializar curses
</li>
</ol>

<ol class="org-ol">
<li>Crear campos utilizando <code>new_field()</code>. Puede especificar la
altura y anchura del campo, y su posición en el formulario.
</li>
</ol>

<ol class="org-ol">
<li>Crear los formularios con <code>new_form()</code> especificando los campos
a agregar.
</li>
</ol>

<ol class="org-ol">
<li>Publicar el formulario con <code>form_post()</code> y refrescar la
pantalla.
</li>
</ol>

<ol class="org-ol">
<li>Procesar las peticiones de usuarios con un bucle y hacer las
actualizaciones necesarias al formulario con <code>form_driver</code>.
</li>
</ol>

<ol class="org-ol">
<li>Remover  el menu con <code>form_unpost()</code>
</li>
</ol>

<ol class="org-ol">
<li>Liberar la memoria asignada al menu con <code>free_form()</code>
</li>
</ol>

<ol class="org-ol">
<li>Liberar la memoria asignada a los elementos con <code>free_field()</code>
</li>
</ol>

<ol class="org-ol">
<li>Finalizar curses
</li>
</ol>

<p>
Como puede ver, trabajar con la libreria form es muy similar a el
manejo de la libreria menu. Los siguientes ejemplos explorarán
diversos aspectos de procesamiento de formularios. Vamos a empezar
el viaje con un simple ejemplo. antes.
</p>
</div>
</div>
<div id="outline-container-sec-19-2" class="outline-3">
<h3 id="sec-19-2">18.2. Compilación con la Libreria Form</h3>
<div class="outline-text-3" id="text-19-2">
<p>
Para utilizar funciones de la libreria form, tiene que incluir
<code>form.h</code> y vincular el programa a la libreria con la bandera
<code>-lform</code> se debe añadir junto con <code>-lncurses</code> en ese orden.
</p>

<pre class="example">
#include &lt;form.h&gt;
.
.
.

compilacion y enlace: gcc &lt;fichero del programa&gt; -lform -lncurses
</pre>

<p>
<a href="ncurses_programs/forms/form_simple.c"><b>Ejemplo 25. Formularios Básicos</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;form.h&gt;

int main(){
  FIELD *field[3];
  FORM  *my_form;
  int ch;

  /* Inicializar curses */
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Inicializar los campos */
  field[0] = new_field(1, 10, 4, 18, 0, 0);
  field[1] = new_field(1, 10, 6, 18, 0, 0);
  field[2] = NULL;

  /* Establecer las opciones de campo */
  set_field_back(field[0], A_UNDERLINE);  /* Imprime una linea para la opcion */
  field_opts_off(field[0], O_AUTOSKIP);   /* No ir al siguente campo si este  */
                                          /* campo es llenado                 */
  set_field_back(field[1], A_UNDERLINE);
  field_opts_off(field[1], O_AUTOSKIP);

  /* Crear el formulario y publicarlo */
  my_form = new_form(field);
  post_form(my_form);
  refresh();

  mvprintw(4, 10, "Valor 1:");
  mvprintw(6, 10, "Valor 2:");
  refresh();

  /* Ciclo para optener solicitudes del usuario */
  while((ch = getch()) != KEY_F(1)){
    switch(ch){
    case KEY_DOWN:
      /* Ir al siguiente campo */
      form_driver(my_form, REQ_NEXT_FIELD);
      /* Ir al final del buffer actual */
      /* Deja en el ultimo caracter    */
      form_driver(my_form, REQ_END_LINE);
      break;
    case KEY_UP:
      /* Ir al campo anterior */
      form_driver(my_form, REQ_PREV_FIELD);
      form_driver(my_form, REQ_END_LINE);
      break;
    default:
      /* Si este es un caracter normal, se optiene */
      /* Imprime                                   */
      form_driver(my_form, ch);
      break;
    }
  }

  /* Remueve el formulario y libera la memoria */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}
</pre>
</div>

<p>
El ejemplo anterior es bastante sencillo. Se crean dos campos con
<code>new_field()</code>. <code>new_field()</code> toma altura, anchura, starty, startx,
número de filas fuera de la pantalla y el número de buffers de
trabajo adicional. El quinto argumento especifica cómo mostrar gran
parte del campo. Si es cero, todo el campo se muestra simpre de
otra manera el formulario será desplazable cuando el campo no
muestre partes de la entrada de usuario. La libreria de formularios
asigna un búfer por campo para almacenar los datos que el usuario
ingresa. Con el ultimo parametro de <code>new_field()</code> podemos
especificar si se almacena en buffers adicionales. Estos puede
utilizarse ​​para cualquier propósito.
</p>

<p>
Después de crear los campos, el atributo de fondo de ambos es
establecido como subrayado con <code>set_field_back()</code>. La opción
<code>AUTOSKIP</code> se desactiva usando <code>field_opts_off()</code>. Si esta opción
está activada, el foco se desplazará al siguiente campo en el
formulario una vez que el campo activo se llene por completo.
</p>

<p>
Después de colocar los campos en el formulario, se publica. Aquí,
se procesa la entrada de usuario en un bucle <code>while</code>, haciendo las
peticiones correspondientes a <code>form_driver</code>. Los detalles de todas
las solicitudes a <code>form_driver()</code> se explican más adelante.
</p>
</div>
</div>
<div id="outline-container-sec-19-3" class="outline-3">
<h3 id="sec-19-3">18.3. Jugando con Campos</h3>
<div class="outline-text-3" id="text-19-3">
<p>
Cada campo del formulario se asocia con una gran cantidad de
atributos. Estos se pueden manipular para conseguir el efecto
deseado y divertirse !!!. Asi que ¿por que esperar?
</p>
</div>
<div id="outline-container-sec-19-3-1" class="outline-4">
<h4 id="sec-19-3-1">18.3.1. Recuperar el Tamaño y Posicion del campo</h4>
<div class="outline-text-4" id="text-19-3-1">
<p>
Los parámetros dados a el momento de la creación de un campo
pueden ser recuperados con <code>field_info()</code>. Devuelve la altura,
anchura, starty, startx, número de filas fuera de la pantalla, y
el número buffers adicionales en los parámetros que le son dados.
Es una especie de <code>new_field()</code> inversa.
</p>

<div class="org-src-container">

<pre class="src src-c">int field_info(     FIELD *field,              /* campo a extraer datos                */
                    int *height, *int width,   /* tamaño de campo                      */
                    int *top, int *left,       /* esquina superior izquierda           */
                    int *offscreen,            /* numero de columnas fuera de pantalla */
                    int *nbuf);                /* numero de buffers de trabajo         */
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-19-3-2" class="outline-4">
<h4 id="sec-19-3-2">18.3.2. Mover el campo</h4>
<div class="outline-text-4" id="text-19-3-2">
<p>
Puede mover el campo a una posición diferente con <code>move_field()</code>.
</p>

<div class="org-src-container">

<pre class="src src-c">int move_field(    FIELD *field,              /* campo a modificar                */
                   int top, int left);        /* nueva esquina superior izquierda */
</pre>
</div>

<p>
Puede consultar la posición modificada <code>field_infor()</code>.
</p>
</div>
</div>
<div id="outline-container-sec-19-3-3" class="outline-4">
<h4 id="sec-19-3-3">18.3.3. Justificar un campo</h4>
<div class="outline-text-4" id="text-19-3-3">
<p>
Puede justificar un campo mediante la función <code>set_field_just()</code>.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_just(FIELD *field,       /* campo a modificar  */
                   int justmode);      /* modo de ajuste     */
int field_just(FIELD *field);          /* obtener el modo de justificacion de un campo */
</pre>
</div>

<p>
Los valores aceptados y devueltos para el modo de justificación
son <code>NO_JUSTIFICATION</code>, <code>JUSTIFY_RIGHT</code>, <code>JUSTIFY_LEFT</code>, o
<code>JUSTIFY_CENTER</code>.
</p>
</div>
</div>
<div id="outline-container-sec-19-3-4" class="outline-4">
<h4 id="sec-19-3-4">18.3.4. Atributos de Visualizacion del Campo</h4>
<div class="outline-text-4" id="text-19-3-4">
<p>
Como se ha visto, en el ejemplo anterior, se pueden establecer los
atributos de visualización del campo con <code>set_field_fore()</code> y
<code>set_field_back()</code>. Estas funciones establecen el atributo de
campo para el primer y segundo plano. También puede especificar un
carácter de relleno que llenará la porción restante del campo. El
carácter de relleno se establece con una llamada a
<code>set_field_pad()</code>. Este valor por defecto es espacio. Puede
utilizar las funciones <code>field_fore()</code>, <code>field_back</code>, <code>field_pad()</code>
para consultar los atributos de relleno, del primer y segundo
plano. El siguiente listado muestra el uso de estas funciones.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_fore(FIELD *field,        /* campo a modificar                 */
                   chtype attr);        /* atributo a establecer             */

chtype field_fore(FIELD *field);        /* campo a consultar                 */
                                        /* devuelve atributo de primer plano */

int set_field_back(FIELD *field,        /* campo a modificar                 */
                   chtype attr);        /* atributo a establecer             */

chtype field_back(FIELD *field);        /* campo a consultar                 */
                                        /* devuelve atributo de fondo        */

int set_field_pad(FIELD *field,         /* campo a modificar                */
                  int pad);             /* caracter de relleno a establecer */

chtype field_pad(FIELD *field);         /* campo a consultar                */
                                        /* devuelve el caracter de relleno */
</pre>
</div>

<p>
A pesar de que el uso de las funciones anteriores parece bastante
simple, utilizar de colores con <code>set_field_fore()</code> puede ser
frustrante al principio. Primero dejame explicar acerca de los
atributos de primer plano y fondo de un campo. El atributo de
primer plano está asociado con el caracter. Eso significa que un
carácter en el campo se imprime con el atributo que ha configurado
con <code>set_field_fore()</code>. El atributo de fondo es utilizado para
llenar el fondo del campo, si algún caracter está allí o
no. Entonces, ¿qué hay acerca de los colores? Los colores siempre
se definen en pares, ¿cuál es la manera correcta de mostrar
colores en los campos? He aquí un ejemplo para aclara el uso de
atributos de color.
</p>

<p>
<a href="ncurses_programs/forms/form_attrib.c"><b>Ejemplo 26. Atributos de Campo</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;form.h&gt;

int main(){
  FIELD *field[3];
  FORM  *my_form;
  int ch;

  /* Inicializa curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Inicializa unos pocos pares de color */
  init_pair(1, COLOR_WHITE, COLOR_BLUE);
  init_pair(2, COLOR_WHITE, COLOR_BLUE);

  /* Inicializa los campos */
  field[0] = new_field(1, 10, 4, 18, 0, 0);
  field[1] = new_field(1, 10, 6, 18, 0, 0);
  field[2] = NULL;

  /* Establece las opciones de campo */
  set_field_fore(field[0], COLOR_PAIR(1));     /* Coloca el campo con el fordo azul  */
  set_field_back(field[0], COLOR_PAIR(2));     /* y el frente blanco (los caracteres */
                                               /* son impresos en BLANCO             */
  field_opts_off(field[0], O_AUTOSKIP);        /* No ir al siguiente campo cuando    */
                                               /* este campo se llene por completo   */
  set_field_back(field[1], A_UNDERLINE);
  field_opts_off(field[1], O_AUTOSKIP);

  /* Crea el formulario y lo publica */
  my_form = new_form(field);
  post_form(my_form);
  refresh();

  set_current_field(my_form, field[0]);        /* Establece foco en campo coloreado  */
  mvprintw(4, 10, "Valor 1:");
  mvprintw(6, 10, "Valor 2:");
  mvprintw(LINES - 2, 0, "Utilice las teclas de flecha UP, DOWN para cambiar entre campos");
  refresh();

  /* Ciclo para optener solicitudes del usuario */
  while( (ch = getch()) != KEY_F(1) ){
    switch( ch ){
    case KEY_DOWN:
      /* Ir al siguiente campo */
      form_driver(my_form, REQ_NEXT_FIELD);
      /* Ir al final del buffer actual  */
      /* Deja en el ultimo caracter     */
      form_driver(my_form, REQ_END_LINE);
      break;
    case KEY_UP:
      /* Ir al campo anterior */
      form_driver(my_form, REQ_PREV_FIELD);
      form_driver(my_form, REQ_END_LINE);
      break;
    default:
      /* Si este es un caracter normal, se optiene */
      /* Imprime                                   */
      form_driver(my_form, ch);
      break;
    }
  }

  /* Remueve el formulario y libera la memoria */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}
</pre>
</div>


<p>
Juega con los pares de color y tratar de entender los atributos de
de fondo y primer plano. En mis programas cuando utilizo atributos
de color, por lo general estableco sólo el fondo con
<code>set_field_back()</code>. curses simplemente no permite definir
atributos de color individuales.
</p>
</div>
</div>
<div id="outline-container-sec-19-3-5" class="outline-4">
<h4 id="sec-19-3-5">18.3.5. Bits de Opcion de Campo</h4>
<div class="outline-text-4" id="text-19-3-5">
<p>
Hay también una gran colección de bits de opcion de campo que
puede configurar para controlar varios aspectos al procesar
formularios. Puede manipularlos con estas funciones:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_opts(FIELD *field,          /* campo a modificar          */
                   int attr);             /* atributo a establecer      */

int field_opts_on(FIELD *field,           /* campo a modificar          */
                  int attr);              /* atributo a encender        */

int field_opts_off(FIELD *field,          /* campo a modificar          */
                   int attr);             /* atributo a apagar          */

int field_opts(FIELD *field);             /* campo a consultar          */
</pre>
</div>

<p>
Puede utilizar la función <code>set_field_opts()</code> para establecer
directamente atributos de un campo o puede optar por
encender/apagar algunos atributos con <code>field_opts_on()</code> y
<code>field_opts_off()</code> . En cualquier momento puede consultar los
atributos de un campo con <code>field_opts()</code>. La siguiente es la lista
de opciones disponibles. De forma predeterminada, todas las
opciones están encedidas.
</p>

<dl class="org-dl">
<dt> <code>O_VISIBLE</code>  </dt><dd>Controla si el campo es visible en pantalla.
Puede ser utilizado al procesar el formulario
para ocultar o mostar campos en función del
valor de campos padre.
</dd>
</dl>

<dl class="org-dl">
<dt> <code>O_ACTIVE</code>   </dt><dd>Controla si el campo está activo durante el
procesamiento de formularios (es decir, se puede
visitar el formulario con las teclas de
navegación). Se puede utilizar para crear
etiquetas o campos derivados con valores de
buffer modificados por la aplicación, no el
usuario.
</dd>
</dl>

<dl class="org-dl">
<dt> <code>O_PUBLIC</code>   </dt><dd>Controla si se muestran los datos durante lo
entrada. Si se desactiva esta opción en un
campo, la libreria va a aceptar y editar datos
en ese campo, pero no se mostrarán y el cursor
no se moverá. Puede apagar el bit <code>O_PUBLIC</code>
para definir campos de contraseña.
</dd>
</dl>

<dl class="org-dl">
<dt> <code>O_EDIT</code>     </dt><dd>Controla si los datos del campo pueden ser
modificados. Cuando esta opción está
desactivada, fallaran todas las peticiones de
edición excepto <code>REQ_PREV_CHOICE</code> y
<code>REQ_NEXT_CHOICE</code>. Estos campos de sólo lectura
pueden ser útiles para mensajes de ayuda.
</dd>
</dl>

<dl class="org-dl">
<dt> <code>O_WRAP</code>     </dt><dd>Controla el ajuste de texto en campos
multi-linea. Normalmente, cuando cualquier
carácter o (espacio separador) palabra llega al
final de la línea actual, se envuelve la palabra
entera y salta a la línea siguiente (suponiendo
que la hay). Cuando esto opción está
desactivada, la palabra se dividirá atraves del
salto de línea.
</dd>
</dl>

<dl class="org-dl">
<dt> <code>O_BLANK</code>    </dt><dd>Controla la suprecion de caracteres. Cuando esta
opción está activa, al introducir un carácter en
la primera posición del campo se borra todo el
campo (excepto el caracter ingresado).
</dd>
</dl>

<dl class="org-dl">
<dt> <code>O_AUTOSKIP</code> </dt><dd>Controla el salto automático al siguiente campo
cuando el actual se llena. Normalmente, cuando
el usuario trata de ingresar mas datos en un
campo hasta llenarlo, la ubicación de edición
salta al siguiente campo. Cuando esta opción
está desactivada, el cursor cuelga al final del
campo. Esta opción se ignora en los campos
dinámicos que no han alcanzado su límite de
tamaño.
</dd>
</dl>

<dl class="org-dl">
<dt> <code>O_NULLOK</code>   </dt><dd>Controla si la validación se aplica a campos en
blanco. Normalmente, no es asi; el usuario puede
dejar un campo en blanco sin invocar la
comprobación de validación al salir. Si esta
opción está desactivada en un campo, la salida
invocará una comprobación de validación.
</dd>
</dl>

<dl class="org-dl">
<dt> <code>O_PASSOK</code>   </dt><dd>Controla si la validación ocurre en cada salida,
o sólo después de que el campo es
modificado. Normalmente es cierto esto
último. Ajustar <code>O_PASSOK</code> puede ser útil si su
funcion de validación puede cambiar durante el
tratamiento de formularios.
</dd>
</dl>

<dl class="org-dl">
<dt> <code>O_STATIC</code>   </dt><dd>Controla si el campo se fija a su dimensiones
iniciales. Si se desactiva, el campo se vuelve
dinámico y se extiende para adaptarse a los
datos introducidos.
</dd>
</dl>


<p>
Las opciones de un campo no se puede cambiar mientras el campo se
encuentra seleccionado. Sin embargo, se pueden cambiar las
opciones en los demas campos.
</p>

<p>
Los valores de las opciones son mascaras de bits y se pueden
componer con puertas logicas OR de manera obvia. Usted ha visto el
uso de apagar la opcion <code>O_AUTOSKIP</code>. El siguiente ejemplo aclara
uso de algunas opciones más. Las otras opciones se explicaran
cuando sea apropiado.
</p>

<p>
<a href="ncurses_programs/forms/form_options.c"><b>Ejemplo 27. Opciones de Campo</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;form.h&gt;

#define STARTX 15
#define STARTY 4
#define WIDTH 25

#define N_FIELDS 3

int main(){
  FIELD *field[N_FIELDS];
  FORM  *my_form;
  int ch, i;

  /* Inicializa curses */
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Inicializa los campos */
  for(i = 0; i &lt; N_FIELDS - 1; ++i)
    field[i] = new_field(1, WIDTH, STARTY + i * 2, STARTX, 0, 0);
  field[N_FIELDS - 1] = NULL;

  /* Establecer las opciones de campo */
  set_field_back(field[1], A_UNDERLINE);    /* Imprime una linea pora la opcion       */

  field_opts_off(field[0], O_ACTIVE);       /* Este campo es una etiqueta estatica    */
  field_opts_off(field[1], O_PUBLIC);       /* Este es un campo estilo contraseña     */
  field_opts_off(field[1], O_AUTOSKIP);     /* Evita entrar en algun otro campo       */
                                            /* despues de ingresar el ultimo caracter */

  /* Crea el formulario y lo publica */
  my_form = new_form(field);
  post_form(my_form);
  refresh();

  set_field_just(field[0], JUSTIFY_CENTER); /* Justificar al centro                   */
  set_field_buffer(field[0], 0, "Este es un campo estatico");

  /* Inicializa el campo  */
  mvprintw(STARTY, STARTX - 10, "Campo 1:");
  mvprintw(STARTY + 2, STARTX - 10, "Campo 2:");
  refresh();

  /* Ciclo para optener solicitudes del usuario */
  while( (ch = getch()) != KEY_F(1) ){
    switch( ch ){
    case KEY_DOWN:
      /* Ir al siguiente campo */
      form_driver(my_form, REQ_NEXT_FIELD);
      /* Ir al final del buffer actual */
      /* Deja en el ultimo caracter    */
      form_driver(my_form, REQ_END_LINE);
      break;
    case KEY_UP:
      /* Ir al campo anterior */
      form_driver(my_form, REQ_PREV_FIELD);
      form_driver(my_form, REQ_END_LINE);
      break;
    default:
      /* Si este es un caracter normal, se optiene */
      /* Imprime                                   */
      form_driver(my_form, ch);
      break;
    }
  }

  /* Remueve el formulario y libera la memoria */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}
</pre>
</div>

<p>
En este ejemplo, aunque inútil, muestra el uso de opciones. Si se
usan adecuadamente, puede presentar la información de manera muy
eficaz. El segundo campo es no <code>O_PUBLIC</code>, no muestra los
caracteres que se están escribiendo.
</p>
</div>
</div>
<div id="outline-container-sec-19-3-6" class="outline-4">
<h4 id="sec-19-3-6">18.3.6. Estado del Campo</h4>
<div class="outline-text-4" id="text-19-3-6">
<p>
El estado de campo especifica si el campo ha sido editado o
no. Inicialmente se establece en <code>FALSE</code> y cuando el usuario
escribe algo y los datos del buffer son modificados se convierte
en <code>TRUE</code>. Por lo tanto se puede consultar el estado de un campo
para saber si se ha modificado o no. Las siguientes funciones
pueden ayudar a esas operaciones.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_status(FIELD *field,      /* campo a modificar       */
                     int status);       /* estado a entablecer     */

int field_status(FIELD *field);         /* obtener estado de campo */
</pre>
</div>

<p>
Es mejor comprobar el estado de un campo sólo después de salir de
este, ya que los datos del buffer podrian no haber sido
actualizados aun, mientras la validacion no se ha teminado. Para
garantizar que es regresado el estado correcto, llamade a
<code>field_status()</code> ya sea (1) cuando termina la rutina de validacion
del campo, (2) a partir de la inicializacion o terminacion de los
campos o formularios, o (3) enseguida de que una solicitud
<code>REQ_VALIDATION</code> ha sido procesada por <code>form_driver()</code>.
</p>
</div>
</div>
<div id="outline-container-sec-19-3-7" class="outline-4">
<h4 id="sec-19-3-7">18.3.7. Puntero de Usuario de Campo</h4>
<div class="outline-text-4" id="text-19-3-7">
<p>
Cada estructura de campo contiene un puntero que puede ser
utilizado por el usuario para diversos fines. No es empleado por
la libreria form y puede ser utilizado por el usuario para
cualquier propósito. Las siguientes funciones establecen y
obtienen el puntero del usuario.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_userptr(FIELD *field,
                      char *userptr);   /* el puntero de usuario que desea asociar */
                                        /* con el campo                            */

char *field_userptr(FIELD *field);      /* obtener el puntero de usuario del campo */
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-19-3-8" class="outline-4">
<h4 id="sec-19-3-8">18.3.8. Campos de Tamaño Variable</h4>
<div class="outline-text-4" id="text-19-3-8">
<p>
Si quiere un campo que cambie su anchura dinámicamente, esta es la
característica que desea poner a pleno uso. Esto permite que el
usuario introdusca más datos que el tamaño original del campo y
deja crecer el campo. De acuerdo con la orientación del campo lo
hará desplazarse horizontal o verticalmente para incorporar los
nuevos datos.
</p>

<p>
Para obtener un campo con crecimiento dinámico, la debe apagar la
opción <code>O_STATIC</code>. Esto se puede hacer con
</p>

<div class="org-src-container">

<pre class="src src-c">field_opts_off(field_pointer, O_STATIC);
</pre>
</div>

<p>
Pero por lo general no es aconsejable permitir a un campo para
crecer infinitamente. Puede establecer un límite máximo para el
crecimiento con
</p>

<div class="org-src-container">

<pre class="src src-c">int set_max_field(FIELD *field,    /* Campo sabre el cual operar                 */
                  int max_growth); /* Crecimiento maximo permitido para el campo */
</pre>
</div>

<p>
La informacion de un campo con crecimiento dinamico se puede
recuperar utilizando
</p>

<div class="org-src-container">

<pre class="src src-c">int dynamic_field_info( FIELD *field,     /* campo sobre el cual operar   */
                        int   *prows,     /* numero de filas              */
                        int   *pcols,     /* number de columnas           */
                        int   *pmax)      /* maximo crecimiento permitido */
</pre>
</div>

<p>
Aunque <code>field_info</code> funciona como de costumbre, es aconsejable
utilizar esta función para obtener los atributos correctos de un
campo con crecimiento dinamico. Recordemos la rutina <code>new_field</code>
de libreria; un campo creado con la altura establecida en uno
define un campo de una sola línea. Un campo creado con una altura
mayor a uno define un campo de múltiples líneas.
</p>

<p>
Un campo de una línea con <code>O_STATIC</code> apagado (campo con
crecimiento dinamico) contendrá una sola fila fija, pero el número
de columnas puede aumentar si el usuario introduce más datos que
los fijados originalmente. El número de columnas mostradas
permanecerá fijo y los datos adicionales podran desplazarse
horizontalmente.
</p>

<p>
Un campo multilínea con <code>O_STATIC</code> apagado (campo con crecimiento
dinamico) contendrá un número fijo de columnas, pero el número de
filas puede aumentar si el usuario introduce más datos que los
fijados originalmnte. El número de filas que se muestra
permanecerá fijo y los datos adicionales podran desplazarse
verticalmente.
</p>

<p>
Los dos párrafos anteriores describen más o menos el
comportamiento de un campo dinamico. La forma en que se comportan
otras partes de libreria se describen a continuacion:
</p>

<ol class="org-ol">
<li>La opción de campo <code>O_AUTOSKIP</code> se ignorará si <code>O_STATIC</code> está
apagado y no se ha especificado un crecimiento máxima para el
campo. Actualmente, <code>O_AUTOSKIP</code> genera automaticamente una
solicitud <code>REQ_NEXT_FIELD</code> cuando el usuario escribe sobre la
posición del ultimo carácter de un campo. En un campo sin
crecimiento máximo especificado, no hay un último carácter. Si
se especifica un crecimiento máximo, la opcion <code>O_AUTOSKIP</code>
funcionará de forma normal si el campo ha crecido a su máximo
tamaño.
</li>
</ol>

<ol class="org-ol">
<li>Se ignora la justificación de campo si se ha apagado la opción
<code>O_STATIC</code>. Actualmente se puede utilizar, <code>set_field_just</code> con
<code>JUSTIFY_LEFT</code>, <code>JUSTIFY_RIGHT</code>, <code>JUSTIFY_CENTER</code> para los
contenidos de un campo de una línea. Un campo creciente de una
linea, por definición, crece y se desplaza horizontalmente y
puede contener más datos de los que se pueden justificar. El
retorno de <code>field_just</code> será <code>NO_JUSTIFICATION</code>.
</li>
</ol>

<ol class="org-ol">
<li>Sobrecargar <code>form_driver</code> con la solicitud <code>REQ_NEW_LINE</code>
operará de la misma manera independientemente de la opción
<code>O_NL_OVERLOAD</code> si la opción de campo <code>O_STATIC</code> está apagada y
no hay un crecimiento máximo especificado para el campo.
Actualmente, si la opción <code>O_NL_OVERLOAD</code> está encendida,
<code>REQ_NEW_LINE</code> genera implícitamente una solicitud
<code>REQ_NEXT_FIELD</code> si se llama desde la última línea de un
campo. Si una campo puede crecer sin límite, no hay última
línea, por lo que <code>REQ_NEW_LINE</code> nunca generará implícitamente
una solicitud <code>REQ_NEXT_FIELD</code>. Si se especifica un límite
máximo de crecimiento y se activa la opcion <code>O_NL_OVERLOAD</code>,
<code>REQ_NEW_LINE</code> sólo se generar <code>REQ_NEXT_FIELD</code> si el campo ha
crecido hasta su tamaño máximo y el usuario está en la última
línea.
</li>
</ol>

<ol class="org-ol">
<li>La funcion <code>dup_field</code> trabajara como de costumbre; duplicara el
campo, incluyendo el tamaño del búfer actual y el contenido del
campo. Cualquier crecimiento máximo especificado también se
duplicará.
</li>
</ol>

<ol class="org-ol">
<li>La llamada <code>link_field</code> funcionará como de costumbre; duplicara
todos los atributos de campo y compartira buffers con el campo
enlazado. Si la opcion de campo <code>O_STATIC</code> se cambia
posteriormente por buffers de campo compatidos, la reaccion del
sistema a un intento de introducir más datos en el campo
actualmente fijo dependerá de la configuración de la opción en
el campo actual.
</li>
</ol>

<ol class="org-ol">
<li>La llamada <code>field_info</code> funcionará como de costumbre; la
variable <code>nrow</code> contendrá el valor de la llamada original a
<code>new_field</code>. El usuario debe utilizar <code>dynamic_field_info</code>,
descrito anteriormente, para consultar el tamaño actual del
buffer.
</li>
</ol>


<p>
Algunos de los puntos anteriores tienen sentido sólo después de
explicar <code>form_driver</code>. Cosa que buscaremos hacer en próximas
secciones.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-19-4" class="outline-3">
<h3 id="sec-19-4">18.4. Ventanas de Formulario</h3>
<div class="outline-text-3" id="text-19-4">
<p>
El concepto de ventana de formulario es más o menos similar al de
ventana de menu. Cada formulario está asociada con una ventana
principal y una sub ventana. La ventana principal del formulario
muestra cualquier título o borde asociado o lo que sea que desee.
La sub ventana contiene todos los campos y los muestra en función
de su posición. Esto le da la flexibilidad de manipular la
presentacion de los formularios muy fácilmente.
</p>

<p>
Dado que esto es muy similar a las ventanas de menu, proporciono un
ejemplo con una mayor explicación. Las funciones son similares y
funcionan de la misma manera.
</p>

<p>
<a href="ncurses_programs/forms/form_win.c"><b>Ejemplo 28. Ventanas de Formulario</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;form.h&gt;
#include &lt;string.h&gt;

void print_in_middle( WINDOW *win, int starty, int startx,
                      int width, char *string, chtype color );

int main(){
  FIELD *field[3];
  FORM  *my_form;
  WINDOW *my_form_win;
  int ch, rows, cols;

  /* Inicialiaza curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad( stdscr, TRUE );

  /* Inicializa un par de color */
  init_pair( 1, COLOR_RED, COLOR_BLACK );

  /* Inicializa los campos */
  field[0] = new_field( 1, 10, 6, 1, 0, 0 );
  field[1] = new_field( 1, 10, 8, 1, 0, 0 );
  field[2] = NULL;

  /* Establece las opciones de campo */
  set_field_back( field[0], A_UNDERLINE );
  field_opts_off( field[0], O_AUTOSKIP ); /* No ir al siguiente campo cuando  */
                                          /* este campa se llene por completo */
  set_field_back( field[1], A_UNDERLINE );
  field_opts_off( field[1], O_AUTOSKIP );

  /* Crea el formulario y lo publica */
  my_form = new_form( field );

  /* Calcula el area requerida por el formulario */
  scale_form( my_form, &amp;rows, &amp;cols );

  /* Crea la venta que sera asociada con el formulario */
  my_form_win = newwin( rows + 4, cols + 4, 4, 4 );
  keypad( my_form_win, TRUE );

  /* Establece la ventana principal y la subventana */
  set_form_win( my_form, my_form_win );
  set_form_sub( my_form, derwin( my_form_win, rows, cols, 2, 2 ) );

  /* Imprime un margen alrededor de la ventana principal e imprime el titulo */
  box( my_form_win, 0, 0 );
  print_in_middle( my_form_win, 1, 0, cols + 4, "Mi formulario", COLOR_PAIR(1) );

  post_form( my_form );
  wrefresh( my_form_win );

  mvprintw( LINES - 2, 0, "Utilice las flechas UP, DOWN para cambiar entre campos" );
  refresh();

  /* Ciclo para optener solicitudes del usuario */
  while( (ch = wgetch(my_form_win)) != KEY_F(1) ){
    switch( ch ){
    case KEY_DOWN:
      /* Ir al siguiente campo */
      form_driver(my_form, REQ_NEXT_FIELD);
      /* Ir al final del buffer actual  */
      /* Deja en el ultimo caracter     */
      form_driver(my_form, REQ_END_LINE);
      break;
    case KEY_UP:
      /* Ir al campo anterior */
      form_driver(my_form, REQ_PREV_FIELD);
      form_driver(my_form, REQ_END_LINE);
      break;
    default:
      /* Si este es un caracter normal, se optiene */
      /* Imprime                                   */
      form_driver(my_form, ch);
      break;
    }
  }

  /* Remueve el formulario y lebera la memoria */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}

void print_in_middle( WINDOW *win, int starty, int startx,
                     int width, char *string, chtype color ){
  int length, x, y;
  float temp;

  if( win == NULL )
    win = stdscr;
  getyx( win, y, x );
  if( startx != 0 )
    x = startx;
  if( starty != 0 )
    y = starty;
  if( width == 0 )
    width = 80;

  length = strlen( string );
  temp = ( width - length )/ 2;
  x = startx + (int)temp;
  wattron( win, color );
  mvwprintw( win, y, x, "%s", string );
  wattroff( win, color );
  refresh();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-19-5" class="outline-3">
<h3 id="sec-19-5">18.5. Validación de Campo</h3>
<div class="outline-text-3" id="text-19-5">
<p>
Por defecto, un campo aceptará cualquier entrada de datos por parte
del usuario. Es posible colocar la validación en el campo. Por
tanto, fallará cualquier intento por parte del usuario de abandonar
el campo, mientras este contiene datos que no concuerdan con el
tipo de validación. Algunos tipos de validación también tienen
validacion por carácter para verificar cada vez que se introduce un
carácter en el campo.
</p>

<p>
La validación a un campo se pude agregar con la siguiente función.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* campo a modificar      */
                   FIELDTYPE *ftype,      /* tipo asociado          */
                   ...);                  /* argumentos adicionales */
</pre>
</div>

<p>
Una vez establecido, el tipo de validación de un campo se puede
consultar con
</p>

<div class="org-src-container">

<pre class="src src-c">FIELDTYPE *field_type(FIELD *field);      /* campo a consultar       */
</pre>
</div>

<p>
El controlador de formulario valida los datos en un campo solo
cuando los datos son ingresados por el usuario final. La Validación
no se produce cuando
</p>

<ul class="org-ul">
<li>El programa de aplicación cambia el valor del campo llamando a
<code>set_field_buffer</code>.
</li>
</ul>

<ul class="org-ul">
<li>Vincular valores de campo y cambiarlos indicertamente &#x2013;
cambiando el campo al que está vinculado
</li>
</ul>


<p>
Los siguientes son los tipos de validación predefinidos. También
puede especificar una validación personalizada, aunque es un poco
complicado y engorroso.
</p>
</div>

<div id="outline-container-sec-19-5-1" class="outline-4">
<h4 id="sec-19-5-1"><code>TYPE_ALPHA</code></h4>
<div class="outline-text-4" id="text-19-5-1">
<p>
Este tipo de campo acepta datos alfabéticos; sin espacios, digitos
o caracteres especiales (esto se comprueba en cada ingreso de
caracter). Este se crea con:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* campo a modificar     */
                   TYPE_ALPHA,            /* tipo asociado         */
                   int width);            /* ancho minimo de campo */
</pre>
</div>

<p>
El argumento <code>width</code> establece una anchura minima de datos. El
usuario tiene que ingresar un número de al menos el ancho de
caracteres antes poder salir del campo. Normalmente, querrá
establecer esto a la anchura del campo; si es mayor que el ancho
del campo, la comprobación de validación siempre fallara. Una
anchura menor a cero crea un campo con terminación opcional.
</p>
</div>
</div>

<div id="outline-container-sec-19-5-2" class="outline-4">
<h4 id="sec-19-5-2"><code>TYPE_ALNUM</code></h4>
<div class="outline-text-4" id="text-19-5-2">
<p>
Este tipo de campo acepta datos alfanumericos; sin espacios en
blanco, ni caracteres especiales (esto se comprueba en cada
ingreso de caracter). Este se crea con:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* campo a modificar     */
                   TYPE_ALNUM,            /* tipo asociado         */
                   int width);            /* ancho minimo de campo */
</pre>
</div>

<p>
El argumento <code>width</code> establece una anchura mínima de datos. Al
igual que <code>TYPE_ALPHA</code>, normalmente, querrá establecer esto a la
anchura del campo; si es mayor que el ancho del campo, la
comprobación de validación siempre fallara. Una anchura menor a
cero crea un campo con terminación opcional.
</p>
</div>
</div>

<div id="outline-container-sec-19-5-3" class="outline-4">
<h4 id="sec-19-5-3"><code>TYPE_ENUM</code></h4>
<div class="outline-text-4" id="text-19-5-3">
<p>
Este tipo le permite restringir los valores de un campo a estar
entre un conjunto de valores de cadena especifico (por ejemplo, el
codigo postal de dos letras de los estados de Estados Unidos). Se
crea con:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* campo a modificar         */
                   TYPE_ENUM,             /* tipo asociado             */
                   char **valuelist;      /* lista de valores posibles */
                   int checkcase;         /* sensible a mayusculas?    */
                   int checkunique);      /* coincidencia unica?       */
</pre>
</div>

<p>
El parámetro <code>valuelist</code> debe apuntar a una lista de cadenas
válidas terminada en <code>NULL</code>. Si el argumento <code>checkcase</code>, es
verdadero, hace la comparación sensible a mayúsculas y minúsculas.
</p>

<p>
Cuando el usuario sale de un campo <code>TYPE_ENUM</code>, el procedimiento
de validación intenta completar los datos en el buffer a una
entrada válida. Si ha ingresado una cadena completa de elección,
por supuesto es válido. Pero también es posible introducir un
prefijo de una cadena válido y que se complete para usted.
</p>

<p>
Por defecto, si se introduce un prefijo y coincide con más de un
valor en la lista de cadenas, el prefijo se completará al primer
valor coincidente. Pero el argumento <code>checkunique</code>, de ser cierto,
requiere que el prefijo coincida con un unico valor para ser
válido.
</p>

<p>
Las peticiones <code>REQ_NEXT_CHOICE</code> y <code>REQ_PREV_CHOICE</code> pueden ser
particularmente útiles con estos campos.
</p>
</div>
</div>

<div id="outline-container-sec-19-5-4" class="outline-4">
<h4 id="sec-19-5-4"><code>TYPE_INTEGER</code></h4>
<div class="outline-text-4" id="text-19-5-4">
<p>
Este tipo de campo acepta un entero. Se configura de la siguiente
manera:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* campo a modificar           */
                   TYPE_INTEGER,          /* tipo asociado               */
                   int padding,           /* precision de relleno a cero */
                   int vmin, int vmax);   /* rango valido                */
</pre>
</div>

<p>
Los caracteres válidos consisten en un menos inicial opcional y
dígitos. La prueba de rango se realiza a la salida. Si el rango
máximo es menor o igual al mínimo, se ignora.
</p>

<p>
Si el valor pasa la prueva de rango, se rellena con ceros a la
izquierda hasta cumplir con el argumento <code>padding</code>.
</p>

<p>
Un buffer de valor <code>TYPE_INTEGER</code> es interpretado convenientemente
con la funcion de la libreria C atoi(3).
</p>
</div>
</div>

<div id="outline-container-sec-19-5-5" class="outline-4">
<h4 id="sec-19-5-5"><code>TYPE_NUMERIC</code></h4>
<div class="outline-text-4" id="text-19-5-5">
<p>
Este tipo de campo acepta un número decimal. Se configura de la
siguiente manera:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* campo a modificar           */
                   TYPE_NUMERIC,          /* tipo asociado               */
                   int padding,           /* procicion de relleno a cero */
                   int vmin, int vmax);   /* rango valido                */
</pre>
</div>

<p>
Los caracteres válidos consisten en un menos inicial opcional y
dígitos, posiblemente incluyendo un punto decimal.  La prueba de
rango se realiza a la salida. Si el rango máximo es menor o igual
al mínimo, se ignora.
</p>

<p>
Si el valor pasa la prueva de rango, se rellena con ceros a la
izquierda hasta cumplir con el argumento <code>padding</code>.
</p>

<p>
Un buffer de valor <code>TYPE_NUMERIC</code> es interpretado convenientemente
con la funcion de la libreria C atof(3).
</p>
</div>
</div>

<div id="outline-container-sec-19-5-6" class="outline-4">
<h4 id="sec-19-5-6"><code>TYPE_REGEXP</code></h4>
<div class="outline-text-4" id="text-19-5-6">
<p>
Este tipo de campo acepta datos que coincidan con una expresión
regular. Se configura de la siguiente manera:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* campo a modificar   */
                   TYPE_REGEXP,           /* tipo asociado       */
                   char *regexp);         /* exprecion a empatar */
</pre>
</div>

<p>
La sintaxis de las expresiones regulares es la de regcomp(3). La
pueba de coincidencia de la expresión regular se ejecuta a la
salida.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-19-6" class="outline-3">
<h3 id="sec-19-6">18.6. Controlador del Formulario: El caballo de trabajo del sistema de formularios</h3>
<div class="outline-text-3" id="text-19-6">
<p>
Al igual que en el sistema de menus, <code>form_driver()</code> juega un papel
muy importante en el sistema de formularios. Todos los tipos de
peticiones al sistema de formularios deben ser canalizado a través
<code>form_driver()</code>.
</p>

<div class="org-src-container">

<pre class="src src-c">int form_driver(FORM *form,     /* formulario en el que operar */
                int request)    /* codigo de solicitud         */
</pre>
</div>

<p>
Como se ha visto en ejemplos anteriores, se tiene que estar en un
bucle en busca de entrada del usuario y luego decidir si se trata
de una solicitud de campo o una de formulario. Las solicitudes de
formulario se pasan a <code>form_driver()</code> para hacer el trabajo.
</p>

<p>
Se pueden dividir las peticiones aproximadamente en las siguientes
categorías. Las diferentes solicitudes y su uso se explica a
continuación:
</p>
</div>
<div id="outline-container-sec-19-6-1" class="outline-4">
<h4 id="sec-19-6-1">18.6.1. Solicitudes de Navegacion por Pagina</h4>
<div class="outline-text-4" id="text-19-6-1">
<p>
Estas solicitudes causan que el nivel de página se mueve a través
de la formulario, lo que provoca la visualización de una pantalla
nueva de formulario. Una formulario puede estar hecho de múltiples
páginas. Si tiene una formulario con gran cantidad de campos y
secciones lógicas, puede dividir el formulario en páginas. La
función <code>set_new_page()</code> para establecer una página nueva en un
campo especifico.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_new_page(FIELD *field,        /* Campo en el cual poner o quitar el salto de pagina */
                 bool new_page_flag); /* debe ser TRUE para colocar el salto                */
</pre>
</div>

<p>
Las siguientes peticiones le permiten moverse a diferentes páginas
</p>

<ul class="org-ul">
<li><code>REQ_NEXT_PAGE</code> mover a la página siguiente.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_PREV_PAGE</code> mover a la página anterior.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_FIRST_PAGE</code> mover a la primer página.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_LAST_PAGE</code> mover a la última página.
</li>
</ul>


<p>
Estas solicitudes manejan la lista de forma cíclica; es decir,
desde la ultima pagina <code>REQ_NEXT_PAGE</code> va a la primera, y desde la
primer pagina <code>REQ_PREV_PAGE</code> va a la última.
</p>
</div>
</div>
<div id="outline-container-sec-19-6-2" class="outline-4">
<h4 id="sec-19-6-2">18.6.2. Solicitudes de Navegación Entre Campos</h4>
<div class="outline-text-4" id="text-19-6-2">
<p>
Estas solicitudes manejar la navegación entre los campos de una
misma página.
</p>

<ul class="org-ul">
<li><code>REQ_NEXT_FIELD</code> mover al campo siguiente.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_PREV_FIELD</code> mover al campo anterior.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_FIRST_FIELD</code> mover al primer campo.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_LAST_FIELD</code> Mover al último campo.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SNEXT_FIELD</code> Mover al siguiente campo ordenado.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SPREV_FIELD</code> Mover al anteriar campo ordenado.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SFIRST_FIELD</code> mover al primer campo ordenado.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SLAST_FIELD</code> Mover al último campo ordenado.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_LEFT_FIELD</code> Mover a la izquierda del campo.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_RIGHT_FIELD</code> Mover a la derecha del campo.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_UP_FIELD</code> mover hacia arriba un campo.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_DOWN_FIELD</code> mover hacia abajo un campo.
</li>
</ul>

<p>
Estas peticiones manejan la lista de campos en una página de forma
cíclica; ese es decir, desde el ultimo campo <code>REQ_NEXT_FIELD</code> va a
el primero, y desde el primer campo <code>REQ_PREV_FIELD</code> va a el
ultimo. El orden de los campos para estas peticiones (incluidas
<code>REQ_FIRST_FIELD</code> y <code>REQ_LAST_FIELD</code>) es simplemente el orden de
los punteros en el arreglo de formularios (establecido por
<code>new_form()</code> o <code>set_form_field()</code>)
</p>

<p>
También es posible recorrer los campos como si hubieran sido
ordenados deacuerdo a su posicion en pantalla, por lo que la
secuencia va de izquierda a derecha y de arriba a abajo. Para
ello, utilice el segundo grupo de cuatro movimientos por orden.
</p>

<p>
Por último, es posible moverse entre campos utilizando las
direciones arriba, abajo, derecha, e izquierda. Para lograr esto,
utilice el tercer grupo de cuatro movimientos. Sin embargo,
observe que la posición de un formulario a efectos de estas
peticiones es la esquina superior izquierda.
</p>

<p>
Por ejemplo, suponga que tiene un campo B multilinea, y dos campos
de una sola línea A y C en la misma línea con B, A a la izquierdo
de B y C a la derecha de B. Desde A <code>REQ_MOVE_RIGHT</code> va a B sólo
si A, B, y C comparten la misma primera línea; de lo contrario,
saltar a C.
</p>
</div>
</div>
<div id="outline-container-sec-19-6-3" class="outline-4">
<h4 id="sec-19-6-3">18.6.3. Solicitudes de Navegacion dentro del Campo</h4>
<div class="outline-text-4" id="text-19-6-3">
<p>
Estas solicitudes manejan el movimiento de el cursor de edición
dentro del campo artalmente seleccionado.
</p>

<ul class="org-ul">
<li><code>REQ_NEXT_CHAR</code> Mover al carácter siguiente.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_PREV_CHAR</code> Mover a carácter anterior.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_NEXT_LINE</code> Mover a la línea siguiente.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_PREV_LINE</code> Mover a la línea anterior.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_NEXT_WORD</code> Mover a la palabra siguiente.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_PREV_WORD</code> Mover a la palabra anterior.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_BEG_FIELD</code> Mover a inicio del campo.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_END_FIELD</code> Mover a final del campo.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_BEG_LINE</code> Mover al incio de línea.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_END_LINE</code> Mover a final de línea.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_LEFT_CHAR</code> Mover a la izquierda en el campo.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_RIGHT_CHAR</code> Mover a la derecha en el campo.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_UP_CHAR</code> Mover hacia arriba en el campo.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_DOWN_CHAR</code> Mover hacia abajo en el campo.
</li>
</ul>


<p>
Cada palabra se separa de los caracteres anteriores y siguientes
por espacio en blanco. Los comandos para mover al inicio y fin de
línea o camo buscan el primer o el ultimo caracter que no es de
relleno en sus rangos.
</p>
</div>
</div>
<div id="outline-container-sec-19-6-4" class="outline-4">
<h4 id="sec-19-6-4">18.6.4. Solicitudes de Desplazamiento</h4>
<div class="outline-text-4" id="text-19-6-4">
<p>
Los campos dinámicos y los creados explícitamente con filas fuera
de pantalla son desplazables. Los campos de una linea se desplazan
horizontalmente; los campos multilínea verticalmente. La mayoría
de movimientos se acciona por la edición y el movimiento dentro
del campo (la libreria desplaza el campo para mantener el cursor
visible). Es posible solicitar explícitamente el desplazamiento
con las siguientes solicitudes:
</p>

<ul class="org-ul">
<li><code>REQ_SCR_FLINE</code> Desplazar verticalmente hacia adelante una
línea.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SCR_BLINE</code> Desplazar verticalmente hacia atrás una línea.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SCR_FPAGE</code> Desplazar verticalmente hacia adelante una
página.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SCR_BPAGE</code> Desplazar verticalmente hacia atrás una página.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SCR_FHPAGE</code> Desplazar verticalmente hacia adelante media
página.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SCR_BHPAGE</code> Desplazar verticalmente hacia atrás media
página.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SCR_FCHAR</code> Desplazar horizontal hacia adelante un caracter.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SCR_BCHAR</code> Desplazar horizontal hacia atrás un caracter.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SCR_HFLINE</code> Desplazar horizontal el ancho de campo hacia
adelante.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SCR_HBLINE</code> Desplazar horizontal el ancho de campo hacia
atrás.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SCR_HFHALF</code> Desplazar horizontal medio ancho de campo hacia
adelante.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_SCR_HBHALF</code> Desplazar horizontal medio ancho de campo hacia
atras.
</li>
</ul>


<p>
A efectos de desplazamiento, la página de un campo es la altura de
su parte visible.
</p>
</div>
</div>
<div id="outline-container-sec-19-6-5" class="outline-4">
<h4 id="sec-19-6-5">18.6.5. Solicitudes de Edición</h4>
<div class="outline-text-4" id="text-19-6-5">
<p>
Cuando se pasa un caracter ASCII al controlador de formulario, se
trata como una solicitud para agregar el carácter a buffer de
datos del campo. Si es un replazo o una inserción depende del modo
de edición del campo (por defecto es inserción).
</p>

<p>
Las siguientes solicitudes apoyan la edicion del campo y cambian
de modo de edición:
</p>

<ul class="org-ul">
<li><code>REQ_INS_MODE</code> Establece modo en inserción.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_OVL_MODE</code> Establece modo de superposición.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_NEW_LINE</code> Solicita nueva línea (ver más abajo para la
explicación).
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_INS_CHAR</code> Insertar espacio en la posicion de carácter.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_INS_LINE</code> Insertar línea en blanco en la posición del
carácter.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_DEL_CHAR</code> Eliminar el carácter en el cursor.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_DEL_PREV</code> Eliminar palabra anterior al cursor.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_DEL_LINE</code> Eliminar linea en el cursor.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_DEL_WORD</code> Eliminar la palabra en el cursor.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_CLR_EOL</code> Borrar hasta el final de la línea.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_CLR_EOF</code> Borrar hasta el final del campo.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_CLR_FIELD</code> Borrar campo entero.
</li>
</ul>


<p>
El comportamiento de las peticiones <code>REQ_NEW_LINE</code> y
<code>REQ_DEL_PREV</code> es complicado y en parte controlado por un par de
opciones del formulario. Los casos especiales se activan cuando el
cursor se encuentra al inicio o en la última línea del campo.
</p>

<p>
En primer lugar, consideramos <code>REQ_NEW_LINE</code>:
</p>

<p>
El comportamiento normal de <code>REQ_NEW_LINE</code> en modo de inserción es
romper la línea actual en la posición del cursor, colocando el
resto de linea despues del cursor como una nueva línea y moviendo
el cursor al inicio de la nueva línea (puede pensar en esto como
la inserción de una nueva línea en el buffer de campo).
</p>

<p>
El comportamiento normal de <code>REQ_NEW_LINE</code> en el modo de
superposición es limpiar la línea actual desde la posición del
cursor al fin de línea. El cursor se mueve entonces hasta el
inicio de la línea siguiente.
</p>

<p>
Sin embargo, <code>REQ_NEW_LINE</code> al incio de un campo, o sobre la
última línea de un campo, en cambio realiza <code>REQ_NEXT_FIELD</code>. Si
la opcion <code>O_NL_OVERLOAD</code> esta desactivada, se desactiva esta
acción especial.
</p>

<p>
Ahora, consideremos <code>REQ_DEL_PREV</code>:
</p>

<p>
El comportamiento normal de <code>REQ_DEL_PREV</code> es eliminar el caracter
anterior. Si el modo de inserción está activado, y el cursor se
encuentra al inicio de una línea, y el texto en esa línea cabe en
la anterior, se anexa el contenido de la línea actual a la
anterior y se borra la línea actual (puede pensar en esto como la
eliminación de un salto de línea del buffer de campo).
</p>

<p>
Sin embargo, <code>REQ_DEL_PREV</code> al inicio de un campo se trata como
<code>REQ_PREV_FIELD</code>.
</p>

<p>
Si la opcion <code>O_BS_OVERLOAD</code> está desactivada, se desactiva esta
acción especial y el controlador devuelve sólo <code>E_REQUEST_DENIED</code>.
</p>
</div>
</div>
<div id="outline-container-sec-19-6-6" class="outline-4">
<h4 id="sec-19-6-6">18.6.6. Solicitudes de Peticion</h4>
<div class="outline-text-4" id="text-19-6-6">
<p>
Si puede solicitar el contenido de un campo, y posse funciones
asociadas para obtener los valores siguiente y anterior de tipo de
un valor dado, estas son las solicitudes para obtener este valor
dentro del buffer del campo:
</p>

<ul class="org-ul">
<li><code>REQ_NEXT_CHOICE</code> Coloca el volor succesor del actual valor en
el buffer.
</li>
</ul>

<ul class="org-ul">
<li><code>REQ_PREV_CHOICE</code> Coloca el valor predecesor del actual valor en
el buffer.
</li>
</ul>


<p>
De los tipos de campo incorporados, solamente <code>TYPE_ENUM</code> ha
incorporado funciones de sucesor y predecesor. Cuando define un
tipo de campo por usted mismo (ver Validacion de Tipos
Personalizados), puede asociar su propia funciones de peticion.
</p>
</div>
</div>
<div id="outline-container-sec-19-6-7" class="outline-4">
<h4 id="sec-19-6-7">18.6.7. Comandos de aplicacion</h4>
<div class="outline-text-4" id="text-19-6-7">
<p>
Las peticiones de formulario se representan como números enteros
por encima del valor <code>KEY_MAX</code> y debajo o igual a la constante
<code>MAX_COMMAND</code>. Un valor dentro de este rango es ignorado por
<code>form_driver()</code>. Así que se puede utilizar para cualquier
propósito de la aplicacion. Se puede tratar como una acción
específica de la aplicación y tomar lao accion correspondiente.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20">19. Librerias de Widgets y Herramientas</h2>
<div class="outline-text-2" id="text-20">
<p>
Ahora que usted ha visto las capacidades de ncurses y sus librerias
hermanas, se esta enrollando las mangas preparandose para un
proyecto con una fuerte manipulacion de pantalla. Pero espere..
Puede ser muy difícil escribir y mantener widgets complejos con puro
ncurses o incluso con las librerias adicionales. Puede utilizar
algunas librerias de widgets y herramientas listas para usar en
lugar de escribir su propios widgets. Puede utilizar algunos de
ellos, obtener ideas a partir del código, o incluso extenderlas.
</p>
</div>
<div id="outline-container-sec-20-1" class="outline-3">
<h3 id="sec-20-1">19.1. CDK (Kit de desarrollo de curses)</h3>
<div class="outline-text-3" id="text-20-1">
<p>
En palabras del autor
</p>

<div class="italic">
<p>
CDK significa 'curses Development Kit' y actualmente contiene 21
widgets listos para usar que facilitan el rápido desarrollo de
programas curses a pantalla completa.
</p>

</div>

<p>
El kit proporciona algunos widgets útiles, que pueden utilizarse
directamente en sus programas. Está muy bien escrito y la
documentación es muy buena. Los ejemplos en el directorio examples
pueden ser un buen punto de partida para los principiantes. CDK se
puede descargar desde <a href="http://invisible-island.net/cdk/">http://invisible-island.net/cdk/</a>. Siga las
instrucciones del archivo README para instalarlo.
</p>
</div>
<div id="outline-container-sec-20-1-1" class="outline-4">
<h4 id="sec-20-1-1">19.1.1. Lista de Widgets</h4>
<div class="outline-text-4" id="text-20-1-1">
<p>
La siguiente es la lista de widgets provista de cdk y su
descripción.
</p>

<pre class="example">
Widget                Descripcion
===========================================================================
Alphalist             Permite seleccionar al usuario de una lista de
                      palabras, con la capacidad de reducir la lista de
                      búsqueda escribiendo algunos caracteres de la
                      palabra deseada.
Buttonbox             Crea widgets de multiples botones.
Calendar              Crea un pequeño y simple widget calendario.
Dialog                Informa un mesaje al usuario, y el usuario puede
                      escojer una obcion de los botones proporcionados.
Entry                 Permite al usuario ingresar varios tipos de datos.
File Selector         Un selector de ficheros construido con widgets
                      CDK. Esta ejemplo muestra cómo crear widgets más
                      complicados utilizando la librería CDK.
Graph                 Dibuja un grafico.
Histogram             Dibuja un histograma.
Item List             Crea un campo emergente que permite al usuario
                      seleccionar una de las varias opciones en un
                      pequeño campo. Muy útil para cosas como día de la
                      semana o nombre de mes.
Label                 Muestra mensajes sobre una caja emergente, o sobre
                      etiqueta que se considera parte de la pantalla.
Marquee               Muestra un mensaje sobre una marquesina con
                      desplazamiento.
Matrix                Crea una compleja matrix con muchas opciones.
Menu                  Crea una interfaz de menu desplegable.
Multiple Line Entry   Un campo multilinea de entrada. Muy útil para los
                      campos largos. (como un campo de descripción)
Radio List            Crea una lista de radio botones.
Scale                 Crea una escala numérica. Se utiliza para
                      permitir a un usuario elegir un valor numérico y
                      restringirlos a una serie de valores.
Scrolling List        Crea un menu/lista desplazable.
Scrolling Window      Crea un visor de registros desplazable. Puede
                      agregar información en la ventana mientras se
                      ejecuta. Un buen widget para visualizar el
                      progreso de algo. (similar a una ventana de la
                      consola)
Selection List        Crea una lista de opciones de seleccion multiple.
Slider                Similar al widget escale, este widget proporciona
                      una barra deslizante visual para representar el
                      valor numérico.
Template              Crea un campo de entrada con caracteres sensibles
                      a una posicion. Se utiliza para pre-formatear
                      campos como fechas y numeros de telefono.
Viewer                Este es un visor de ficheros/informacion. Muy util
                      cuando se necesita mostrar un monton de informacion.
===========================================================================
</pre>

<p>
Algunos de los widgets son modificados por Thomas Dickey en las
últimas versiones.
</p>
</div>
</div>
<div id="outline-container-sec-20-1-2" class="outline-4">
<h4 id="sec-20-1-2">19.1.2. Algunas Características Atractivas</h4>
<div class="outline-text-4" id="text-20-1-2">
<p>
Ademas de hacer nuestra vida más fácil con widgets fácilmente
utilizables, cdk resuelve un problema frustrante con la impresión
de cadenas de colores, cadenas justificadas elegantemente.  Las
etiquetas con formato especial se puede incrustar en las cadenas
pasadas a las funciones CDK. por Ejemplo
</p>

<p>
Si la cadena
</p>

<pre class="example">
"&lt;/B/1&gt;This line should have a yellow foreground and a blue
background.&lt;!1&gt;"
</pre>

<pre class="example">
"&lt;/B/1&gt;Esta line debe tener un primer plano amarillo y un fondo azul.&lt;!1&gt;"
</pre>

<p>
se pasa como parámetro a <code>newCDKLabel()</code>, se imprime la línea con
primer plano amarillo y fondo azul. Hay otras etiquetas
disponibles para justificar la cadeno, dibujo de caracteres
especiales etc.. Por favor, consulte la página man
<code>cdk_display(3X)</code> para mas detalles. La página del manual explica
el uso con buenos ejemplos.
</p>
</div>
</div>
<div id="outline-container-sec-20-1-3" class="outline-4">
<h4 id="sec-20-1-3">19.1.3. Conclusión</h4>
<div class="outline-text-4" id="text-20-1-3">
<p>
Considerando todo, CDK es un paquete de widgets bien escrito, que
si se utiliza correctamente puede formar un fuerte marco de
trabajo para el desarrollo de complejos GUI.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-20-2" class="outline-3">
<h3 id="sec-20-2">19.2. dialog</h3>
<div class="outline-text-3" id="text-20-2">
<p>
Hace mucho mucho tiempo, en Septiembre de 1994, cuando pocas
personas sabían GNU/linux, Jeff Tranter escribió un <a href="http://www2.linuxjournal.com/lj-issues/issue5/2807.html">articulo</a> de
diálog en Linux Journal. El articulo comienza con estas palabras..
</p>

<div class="italic">
<p>
Linux se basa en el sistema operativo Unix, pero cuenta también
con un número de características del núcleo únicas y útiles y
programas de aplicación que a menudo van más allá de lo que está
disponible en Unix. Uno joya poco conocida es "diálog", una
utilidad para crear cuadros de dialogo de aspecto profesional
desde shell scripts. Esta artículo presenta un tutorial de
introducción para la utilidad dialog, y muestra ejemplos de cómo
y dónde se puede utilizar
</p>

</div>

<p>
Como él mismo explica, dialog es una verdadera joya para crear
cajas de dialogo de aspecto profesional con facilidad. Crea una
variedad de cuadros de diálogo, menus, listas de verificación,
etc.. Por lo general se instala de forma predeterminada. Si no,
puede descargarlo desde el sitio de <a href="http://invisible-island.net/dialog/">Thomas Dickey</a>'s.
</p>

<p>
El artículo mencionado da una muy buena descripción de sus usos y
capacidades. La página del man tiene más detalles. Se puede
utilizar en variedad de situaciones. Un buen ejemplo es la
construcción del kernel linux en modo texto. El kernel linux
utiliza una versión de dialog modificada a medida para sus
necesidades.
</p>

<p>
dialog fue diseñado inicialmente para ser utilizado con shell
scripts. Si desea utilizar su funcionalidad en un programa c,
entonces puede utilizar libdialog. La documentación en este aspecto
es escasa. La referencia definitiva es el archivo de cabecera
dialog.h que viene con el libreria. Puede que tenga que cortar aquí
y allá para conseguir la salida necesaria. El codigo fuente es
fácilmente personalizable. Lo he usado en un número de ocasiones
mediante la modificación del código.
</p>
</div>
</div>
<div id="outline-container-sec-20-3" class="outline-3">
<h3 id="sec-20-3">19.3. Módulos curses de Perl CURSES::FORM y CURSES::WIDGETS</h3>
<div class="outline-text-3" id="text-20-3">
<p>
Los módulos curses de perl, curses::Form y curses::Widgets dan
acceso a curses desde perl. Si usted tiene la instalacion basica de
curses y perl, puede obtener estos módulos de <a href="http://www.cpan.org/modules/01modules.index.html">CPAN All Modules
page</a>. Obtener los tres módulos comprimidos en la categoría
curses. Una vez instalados puede utilizar estos módulos en scripts
de Perl como cualquier otro módulo. Para obtener más información
sobre los módulos vea la pagina man perlmod. Los módulos anteriores
vienenn con una buena documentación y tienen algunos scripts de
demostración para probar su funcionalidad. Aunque los widgets
proporcionadas son muy rudimentarios, estos módulos proporcionan un
buen acceso a la libreria curses desde perl.
</p>

<p>
Algunos de mis ejemplos de código fueron adaptados a perl por
Anuradha Ratnaweera y están disponibles en el directorio <a href="ncurses_programs/perl">perl</a>.
</p>

<p>
Para obtener más información, consulte las páginas de manual
curses(3), curses::Form(3) y curses::Widgets(3). Estas paginas se
instalan sólo cuando los módulos anteriores se adquieren e
instalan.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-21" class="outline-2">
<h2 id="sec-21">20. Solo Por Diversion !!!</h2>
<div class="outline-text-2" id="text-21">
<p>
Esta sección contiene algunos programas escritos por mí sólo por
diversión. Esto no significa que sean una mejor práctica de
programación o la mejor manera de utilizar ncurses. Se proporcionan
a fin de permitir que los principiantes obtegan ideas y añaden más
programas a esta sección. Si usted ha escrito un par de buenos
programas, programas sencillos en curses y los quiere incluir aquí,
<a href="mailto:ppadala@gmail.com">contacteme</a>.
</p>
</div>
<div id="outline-container-sec-21-1" class="outline-3">
<h3 id="sec-21-1">20.1. El juego de la vida</h3>
<div class="outline-text-3" id="text-21-1">
<p>
El Juego de la vida es una maravilla de la matemáticas. En palbras
de <a href="http://www.math.com/students/wonders/life/life.html">Paul Callahan</a>
</p>

<pre class="example">
The Game of Life (or simply Life) is not a game in the conventional sense. There
are no players, and no winning or losing. Once the "pieces" are placed in the
starting position, the rules determine everything that happens later.
Nevertheless, Life is full of surprises! In most cases, it is impossible to look
at a starting position (or pattern) and see what will happen in the future. The
only way to find out is to follow the rules of the game.
</pre>

<pre class="example">
El juego de la vida (o simplemente la vida) no es un juego en el
sentido convencional. Ya que tiene jugadores, y no se gana o
pierde. Una vez que las "piezas" se colocan en la posición
inicial, las reglas determinan todo lo que sucede después.
Sin embargo, la vida está llena de sorpresas! En la mayoría de
los casos, es imposible mirar un posición de inicial (o patrón) y
ver lo que sucederá en el futuro. La única manera de averiguarlo
es seguir las reglas del juego.
</pre>

<p>
Este programa comienza con un simple patrón o recambio y muestra el
maravilloso trabajo de la vida. Hay mucho margen de mejora en el
programa. Puede dejar que el usuario introduzca el patrón de su
elección o incluso obtener información de un archivo. También puede
cambiar las reglas y jugar con un gran cantidad de variaciones.
Realice una busqueda en <a href="http://www.google.com">google</a> para obtener interesante información
sobre el juego de vida.
</p>

<p>
Ruta del archivo: <a href="ncurses_programs/JustForFun/life.c">JustForFun/life.c</a>
</p>
</div>
</div>
<div id="outline-container-sec-21-2" class="outline-3">
<h3 id="sec-21-2">20.2. Cuadrado Mágico</h3>
<div class="outline-text-3" id="text-21-2">
<p>
Otra maravilla de las matemáticas, es muy sencillo de entender pero
muy difícil de hacer. En un cuadrado mágico la suma de los números
en cada fila, y cada columna es igual. Incluso la suma en digonal
puede ser igual. Hay muchas variaciones con propiedades
particulares.
</p>

<p>
Este programa crea un sencillo cuadrado mágico de orden impar.
</p>

<p>
Ruta del archivo: <a href="ncurses_programs/JustForFun/magic.c">JustForFun/magic.c</a>
</p>
</div>
</div>
<div id="outline-container-sec-21-3" class="outline-3">
<h3 id="sec-21-3">20.3. Torres de Hanoi</h3>
<div class="outline-text-3" id="text-21-3">
<p>
Solucionador de las famosas torres de hanoi. El objetivo del juego
es mover los discos de la primer a la último estaca, utilizando la
estaca central como temporal. No se permite tomar un disco y
colocarlo sobre otro mas pequeño.
</p>

<p>
Ruta del archivo: <a href="ncurses_programs/JustForFun/hanoi.c">JustForFun/hanoi.c</a>
</p>
</div>
</div>
<div id="outline-container-sec-21-4" class="outline-3">
<h3 id="sec-21-4">20.4. Rompecabezas de las Reinas</h3>
<div class="outline-text-3" id="text-21-4">
<p>
El objetivo del famoso rompecabezas N-reina es poner N reinas en un
tablero de ajedrez N X N atacarse unas a otras.
</p>

<p>
Este programa resuelve esto con una técnica de rastreo hacia atras
simple.
</p>

<p>
Ruta del archivo: <a href="ncurses_programs/JustForFun/queens.c">JustForFun/queens.c</a>
</p>
</div>
</div>
<div id="outline-container-sec-21-5" class="outline-3">
<h3 id="sec-21-5">20.5. Barajar</h3>
<div class="outline-text-3" id="text-21-5">
<p>
Un juego divertido, si tienes tiempo para matar.
</p>

<p>
Ruta del archivo: <a href="ncurses_programs/JustForFun/shuffle.c">JustForFun/shuffle.c</a>
</p>
</div>
</div>
<div id="outline-container-sec-21-6" class="outline-3">
<h3 id="sec-21-6">20.6. Tutor de Mecanografia</h3>
<div class="outline-text-3" id="text-21-6">
<p>
Un tutor de mecanografía simple, Lo he creado más por necesidad que
por su facilidad de uso. Si sabe cómo colocar los dedos
correctamente en el teclado, pero le falta práctica, puede serle
útil.
</p>

<p>
Ruta del archivo: <a href="ncurses_programs/JustForFun/tt.c">JustForFun/tt.c</a>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-22" class="outline-2">
<h2 id="sec-22">21. Referencias</h2>
<div class="outline-text-2" id="text-22">
<ul class="org-ul">
<li><a href="man/index.html">Páginas man</a> de NCURSES
</li>
</ul>

<ul class="org-ul">
<li>NCURSES FAQ en
<a href="http://invisible-island.net/ncurses/ncurses.faq.html">http://invisible-island.net/ncurses/ncurses.faq.html</a>
</li>
</ul>

<ul class="org-ul">
<li>Escribir programas con NCURSES por Eric Raymond y Zeid
M. Ben-Halim en
<a href="http://invisible-island.net/ncurses/ncurses-intro.html">http://invisible-island.net/ncurses/ncurses-intro.html</a> - algo
obsoleto. Me inspiré en este documento y la estructura de este
HOWTO sigue la del documento original
</li>
</ul>
</div>
</div>
</div>
</body>
</html>
