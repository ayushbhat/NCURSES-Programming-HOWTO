#+TITLE:  NCURSES Programming HOWTO
#+AUTHOR: ppadala
#+MAIL: ppadala@gmail.com
#+LANGUAGE: en
#+OPTIONS: H:5 num:nil html-postamble:nil html-style:nil html-scripts:nil
#+html_head: <link rel="stylesheet" type="text/css" href="worg-data/worg.css" /
#+STARTUP: showall


# * Revision History
* Revisión histórica

  - Revision 1.9     2005-06-20   Revised by: ppadala

    # The license has been changed to the MIT-style license used by
    # NCURSES. Note that the programs are also re-licensed under this.
    La licencia se ha cambiado a una licencia estilo MIT utilizada por
    Ncurses. Tenga en cuenta que los programas están también
    re-licenciados bajo esta.

  - Revision 1.8     2005-06-17   Revised by: ppadala

    # Lots of updates. Added references and perl examples. Changes to
    # examples. Many grammatical and stylistic changes to the
    # content. Changes to NCURSES history.
    Un montón de actualizaciones. Añadidas referencias y ejemplos de
    perl. Cambios a ejemplos. Muchos cambios gramaticales y de estilo
    al contenido. Cambios en la historia NCURSES.

  - Revision 1.7.1   2002-06-25   Revised by: ppadala

    # Added a README file for building and instructions for building
    # from source.
    Se ha añadido un archivo README para la construcción y las
    instrucciones para la construcción desde el codigo fuente.

  - Revision 1.7     2002-06-25   Revised by: ppadala

    # Added "Other formats" section and made a lot of fancy changes to
    # the programs. ‽Inlining of programs is gone.
    Añadida sección "Other formats" y un montón de cambios fantasticos
    a los programas. Inlining de los programas se ha ido.

  - Revision 1.6.1   2002-02-24   Revised by: ppadala

    # Removed the old Changelog section, cleaned the makefiles
    Eliminada la vieja sección Changelog, limpieza a los makefiles

  - Revision 1.6     2002-02-16   Revised by: ppadala

    # Corrected a lot of spelling mistakes, added ACS variables section
    Se han corregido un montón de errores de ortografía, agregó
    sección de variables ACS

  - Revision 1.5     2002-01-05   Revised by: ppadala

    # Changed structure to present proper TOC
    Estructura cambiada para presentar TOC adecuado

  - Revision 1.3.1   2001-07-26   Revised by: ppadala

    # Corrected maintainers paragraph, Corrected stable release number
    Párrafo de mantenedores corregido, número de versión estable
    Corregido

  - Revision 1.3     2001-07-24   Revised by: ppadala

    # Added copyright notices to main document (LDP license) and
    # programs (GPL), Corrected =printw_example=.
    Añadido aviso de copyright al documento principal (licencia LDP) y
    programas (GPL), corregido =printw_example=.

  - Revision 1.2     2001-06-05   Revised by: ppadala

    # Incorporated ravi's changes. Mainly to introduction, menu, form,
    # justforfun sections
    Incorporados los cambios de Ravi. Principalmente a la
    introducción, menu, form, y secciones JustForFun

  - Revision 1.1     2001-05-22   Revised by: ppadala

    # Added "a word about window" section, Added =scanw_example=.
    Se agregó una sección "a word about window", Agregado
    =scanw_example=.


  # #+BEGIN_ITALIC
  #   This document is intended to be an "All in One" guide for
  #   programming with ncurses and its sister libraries. We graduate
  #   from a simple "Hello World" program to more complex form
  #   manipulation. No prior experience in ncurses is assumed. Send
  #   comments to [[mailto:ppadala@gmail.com][this address]]
  # #+END_ITALIC

  #+BEGIN_ITALIC
    Este documento pretende ser una guía "Todo en Uno" para la
    programación con ncurses y sus bibliotecas hermanas. Nos graduamos
    desde un simple programa "Hola Mundo" a una forma más compleja de
    manipulación. Se asume una nula experiencia previa en
    ncurses. Enviar comentarios a [[mailto:ppadala@gmail.com][esta direccion]]
  #+END_ITALIC

# * 1. Introduccion
* 1. Introduccion

  # In the olden days of teletype terminals, terminals were away from
  # computers and were connected to them through serial cables. The
  # terminals could be configured by sending a series of bytes. All the
  # capabilities (such as moving the cursor to a new location, erasing
  # part of the screen, scrolling the screen, changing modes etc.) of
  # terminals could be accessed through these series of bytes. These
  # control seeuqnces are usually called escape sequences, because they
  # start with an escape(0x1B) character. Even today, with proper
  # emulation, we can send escape sequences to the emulator and achieve
  # the same effect on a terminal window.
  En los viejos tiempos de los terminales de teletipo, los terminales
  estaban lejos de las computadoras y se conectaban a ellos a través
  de cables seriales. los terminales podrían ser configurados mediante
  el envío de una serie de bytes. Todas las capacidades (tales como
  mover el cursor a una nueva ubicación, borrar parte de la pantalla,
  el desplazamiento de pantalla, cambio de modos, etc.) de los
  terminales se puede acceder a través de esta serie de bytes. Estas
  secuencias de control generalmente se llaman secuencias de escape,
  ya que comenzar con un carácter de escape(0x1B). Incluso hoy en día,
  con la adecuada emulación, podemos enviar secuencias de escape a el
  emulador y lograr el mismo efecto en una ventana de terminal.

  # Suppose you wanted to print a line in color. Try typing this on your
  # console.
  Suponga que desea imprimir una línea en color. Pruebe a escribir
  esto en su consola.

  #+BEGIN_SRC sh
    echo "^[[0;31;40mIn Color"
  #+END_SRC

  # The first character is an escape character, which looks like two
  # characters =^= and =[=. To be able to print it, you have to press
  # CTRL+V and then the ESC key. All the others are normal printable
  # characters.  You should be able to see the string "In Color" in
  # red. It stays that way and to revert back to the original mode type
  # this.
  El primer carácter es un carácter de escape, que aparece como los
  caracteres =^= y =[=. Para poder imprimirlo, hay que pulsar CTRL+V y
  luego la tecla ESC. Todos los demás son caracteres imprimibles
  normales.  Usted debe ser capaz de ver la cadena "In Color" en
  rojo. Se mantiene de esa forma y para volver de nuevo al tipo de
  modo original.

  #+BEGIN_SRC sh
    echo "^[[0;37;40m"
  #+END_SRC

  # Now, what do these magic characters mean? Difficult to comprehend?
  # They might even be different for different terminals. So the
  # designers of UNIX invented a mechanism named =termcap=. It is a file
  # that lists all the capabilities of a particular terminal, along with
  # the escape sequences needed to achieve a particular effect. In the
  # later years, this was replaced by =terminfo=. Without delving too
  # much into details, this mechanism allows application programs to
  # query the terminfo database and obtain the control characters to be
  # sent to a terminal or terminal emulator.
  Ahora, ¿qué significan estos caracteres mágicos? Difíciles de
  comprender?  Incluso podrían ser diferentes para diferentes
  terminales. Asi que los diseñadores de UNIX inventaron un mecanismo
  denominado =termcap=. Es un archivo que enumera todas las
  capacidades de un terminal en particular, junto con las secuencias
  de escape necesarias para conseguir un efecto particular. Años más
  tarde, este fue reemplazado por =terminfo=. Sin ahondar demasiado en
  detalles, este mecanismo permite a los programas de aplicación
  consultar la base de datos terminfo y obtener los caracteres de
  control para ser enviados a un terminal o emulador de terminal.

# ** 1.1. What is NCURSES?
** 1.1. ¿Qué es Ncurses?

   # You might be wondering, what the import of all this technical
   # gibberish is. In the above scenario, every application program is
   # supposed to query the terminfo and perform the necessary stuff
   # (sending control characters etc.). It soon became difficult to
   # manage this complexity and this gave birth to 'CURSES'. Curses is a
   # pun on the name "cursor optimization". The Curses library forms a
   # wrapper over working with raw terminal codes, and provides highly
   # flexible and efficient API (Application Programming Interface). It
   # provides functions to move the cursor, create windows, produce
   # colors, play with mouse etc. The application programs need not
   # worry about the underlying terminal capabilities.
   Usted podría preguntarse, el significado de toda esta algarabia
   técnica. En el escenario anterior, todos los programas de
   aplicación se supone consultan terminfo y realizan las cosas
   necesarias (envío de caracteres de control, etc.). Pronto se hizo
   difícil gestionar toda esta complejidad y esto dio a luz a
   'CURSES'. Curses es un juego de palabras del nombre "cursor
   optimization" (optimización del cursor). La libreria Curses forma
   un envoltorio para trabajar encima de los códigos de terminal
   puros, y proporciona una API (Application Programming Interface)
   altamente flexible y eficiente. Proporciona funciones para mover el
   cursor, crear ventanas, producir colores, jugar con el ratón,
   etc. Los programas de aplicación no necesitan preocuparse por las
   capacidades subyacentes del terminal.

   # So what is NCURSES? NCURSES is a clone of the original System V
   # Release 4.0 (SVr4) curses. It is a freely distributable library,
   # fully compatible with older version of curses. In short, it is a
   # library of functions that manages an application's display on
   # character-cell terminals. In the remainder of the document, the
   # terms curses and ncurses are used interchangeably.
   Entonces, ¿qué es NCURSES? NCURSES es un clon del original Sistem V
   Release 4.0 (SVr4) curses. Es una biblioteca de libre disposición,
   totalmente compatible con la versión anterior de curses. En breve,
   es una libreria de funciones que maneja la pantalla de una
   aplicación en terminales de celdas de caracter. En el resto del
   documento, la términos curses y ncurses se utilizan
   indistintamente.

   # A detailed history of NCURSES can be found in the NEWS file from
   # the source distribution. The current package is maintained by
   # [[mailto:dickey@his.com][Thomas Dickey]]. You can contact the maintainers at
   # [[mailto:bug-ncurses@gnu.org][bug-ncurses@gnu.org]].
   Una historia detallada de NCURSES se puede encontrar en el archivo
   NEWS dentro del codigo fuente. El paquete actual es mantenido por
   [[mailto:dickey@his.com][Thomas Dickey]]. Puede contactar con los mantenedores en
   [[mailto:bug-ncurses@gnu.org][bug-ncurses@gnu.org]].

# ** 1.2. What we can do with NCURSES
** 1.2. Que podemos hacer con Ncurses

   # NCURSES not only creates a wrapper over terminal capabilities, but
   # also gives a robust framework to create nice looking UI (User
   # Interface)s in text mode. It provides functions to create windows
   # etc. Its sister libraries panel, menu and form provide an extension
   # to the basic curses library. These libraries usually come along
   # with curses. One can create applications that contain multiple
   # windows, menus, panels and forms.  Windows can be managed
   # independently, can provide 'scrollability' and even can be hidden.
   Ncurses no sólo crea una envoltura sobre las capacidades del
   terminal, también le da un marco sólido para crear una bonita UI
   (User Interface/interfaz de usuario) en modo texto. Proporciona
   funciones para crear ventanas etc. Sus bibliotecas hermanas
   =panel=, =menu= y =form= proporcionan una extensión a la biblioteca
   básica curses. Estas bibliotecas por lo general vienen tambien con
   Curses. Uno puede crear aplicaciones que contienen múltiples
   ventanas, menús, paneles y formularios. Las ventanas se pueden
   manejar independientemente, pueden proporcionar 'deslizabilidad' e
   incluso pueden ocultarse.

   # Menus provide the user with an easy command selection option. Forms
   # allow the creation of easy-to-use data entry and display
   # windows. Panels extend the capabilities of ncurses to deal with
   # overlapping and stacked windows.
   Los menús ofrecen al usuario una fácil opción de selección de
   comandos. Los formularios facilitan la entrada de datos y ventanas
   de visualización. Los paneles extienden las capacidades de ncurses
   para hacer frente a ventanas superpuestas y apiladas.

   # These are just some of the basic things we can do with ncurses. As
   # we move along, We will see all the capabilities of these libraries.
   Estas son sólo algunas de las cosas básicas que podemos hacer con
   ncurses. A medida que avancemos, veremos todas las capacidades de
   estas librerias.

# ** 1.3. Where to get it
** 1.3. Dónde conseguirlo

   # All right, now that you know what you can do with ncurses, you must
   # be rearing to get started. NCURSES is usually shipped with your
   # installation. In case you don't have the library or want to compile
   # it on your own, read on.
   Muy bien, ahora que ya sabes lo que puedes hacer con ncurses, debes
   estar ancioso por empezar. Generalmente NCURSES viene con su
   distribucion. En caso de que usted no tenga la libreria o quiera
   compilar por su cuenta, siga leyendo.

   # /Compiling the package/
*** /Compilación del paquete/

    # NCURSES can be obtained from
    # [[ftp://ftp.gnu.org/pub/gnu/ncurses/ncurses.tar.gz]] or any of the ftp
    # sites mentioned in [[http://www.gnu.org/order/ftp.html]].
    Ncurses pueden obtenerse desde
    [[ftp://ftp.gnu.org/pub/gnu/ncurses/ncurses.tar.gz]] o cualquiera de
    los sitios ftp mencionados en [[http://www.gnu.org/order/ftp.html]].

    # Read the README and INSTALL files for details on to how to install
    # it.  It usually involves the following operations.
    Lea los archivos README e INSTALL para obtener más información
    sobre cómo instalarlo. Por lo general, implica las siguientes
    operaciones.

    # #+BEGIN_SRC sh
    #   tar zxvf ncurses<version>.tar.gz  # unzip and untar the archive
    #   cd ncurses<version>               # cd to the directory
    #   ./configure                             # configure the build according to your
    #                                           # environment
    #   make                                    # make it
    #   su root                                 # become root
    #   make install                            # install it
    # #+END_SRC

    #+BEGIN_SRC sh
      tar zxvf ncurses<version>.tar.gz  # descomprimir y desempaquetar el archivo
      cd ncurses<version>               # ir al directorio
      ./configure                             # configurar la contruccion de acuerdo
                                              # con su entorno
      make                                    # fabricar
      su root                                 # como root
      make install                            # instalarlo
    #+END_SRC

    # /Using the RPM/
*** /Usando el RPM/

    # NCURSES RPM can be found and downloaded from [[http://rpmfind.net]].
    # The RPM can be installed with the following command after becoming
    # root.
    El RPM de NCURSES se puede encontrar y descargar desde
    [[http://rpmfind.net]].  El RPM se puede instalar con el siguiente
    comando después de convertirse en root.

    #+BEGIN_SRC sh
      rpm -i <downloaded rpm>
    #+END_SRC

# ** 1.4. Purpose/Scope of the document
** 1.4. Objetivo/Alcance del documento

   # This document is intended to be a "All in One" guide for
   # programming with ncurses and its sister libraries. We graduate from
   # a simple "Hello World" program to more complex form
   # manipulation. No prior experience in ncurses is assumed. The
   # writing is informal, but a lot of detail is provided for each of
   # the examples.
   Este documento pretende ser una guía "Todo en Uno" para la
   programación con ncurses y sus librerias hermanas. Nos graduamos
   desde un simple programa "Hola Mundo" a una forma más compleja de
   manipulación. Se asume una nula experiencia previa en ncurses. La
   escritura es informal, pero se proporciona una gran cantidad de
   detalles de cada uno de los ejemplos.

# ** 1.5. About the Programs
** 15. Acerca de los Programas

   # All the programs in the document are available in zipped form [[http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs.tar.gz][here]].
   # Unzip and untar it. The directory structure looks like this.
   Todos los programas en el documento están disponibles en forma de
   empaquetado [[http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs.tar.gz][aqui]]. Descomprima y desempaquete. La estructura de
   directorios se parece a esto.

   # #+BEGIN_EXAMPLE
   #   ncurses
   #      |
   #      |----> JustForFun     -- just for fun programs
   #      |----> basics         -- basic programs
   #      |----> demo           -- output files go into this directory after make
   #      |          |
   #      |          |----> exe -- exe files of all example programs
   #      |----> forms          -- programs related to form library
   #      |----> menus          -- programs related to menus library
   #      |----> panels         -- programs related to panels library
   #      |----> perl           -- perl equivalents of the examples (contributed
   #      |                            by Anuradha Ratnaweera)
   #      |----> Makefile       -- the top level Makefile
   #      |----> README         -- the top level README file. contains instructions
   #      |----> COPYING        -- copyright notice
   # #+END_EXAMPLE

   #+BEGIN_BLOCK
     [[file:ncurses_programs/][ncurses]]
        ┬
        ├────> [[file:ncurses_programs/JustForFun][JustForFun]]     – Solo para programas divertidos
        ├────> [[file:ncurses_programs/basics][basics]]         – programas basicos
        ├────> [[file:ncurses_programs/demo][demo]]           – los archivos de salida van a este directorio
        │        ┬
        │        └──────> [[file:ncurses_programs/demo/exe][exe]] – executables de todos los programas de ejemplo
        ├────> [[file:ncurses_programs/forms][forms]]          – programas relacionados con la libreria form
        ├────> [[file:ncurses_programs/menus][menus]]          – programas relacionados con la libreria menu
        ├────> [[file:ncurses_programs/panels][panels]]         – programas relacionados con la libreria panel
        ├────> [[file:ncurses_programs/perl][perl]]           – equivalentes en perl de los ejemplos
        │                           (aportados por Anuradha Ratnaweera)
        ├────> [[file:ncurses_programs/Makefile][Makefile]]       – Makefile del nivel superior
        ├────> [[file:ncurses_programs/README][README]]         – archivo README del nivel superior. contiene instrucciones
        └────> [[file:ncurses_programs/COPYING][COPYING]]        – aviso de copyright
   #+END_BLOCK

   # The individual directories contain the following files.
   Los directorios individuales contienen los siguientes archivos.

   #+BEGIN_BLOCK
     Descripción de los archivos en cada directorio
     ––––––––––––––––––––––––––––––––––––––––––––––
     [[file:ncurses_programs/JustForFun][JustForFun]]
         ┬
         ├────> [[file:ncurses_programs/JustForFun/hanoi.c][=hanoi.c=]]   – Solucionador de las Torres de Hanoi
         ├────> [[file:ncurses_programs/JustForFun/life.c][=life.c=]]    – Demostracion de el Juego de la Vida
         ├────> [[file:ncurses_programs/JustForFun/magic.c][=magic.c=]]   – Constructor del cuadrado mágico
         ├────> [[file:ncurses_programs/JustForFun/queens.c][=queens.c=]]  – Solucionador del famoso N-Queens
         ├────> [[file:ncurses_programs/JustForFun/shuffle.c][=shuffle.c=]] – Un juego divertido, si tienes tiempo para matar
         └────> [[file:ncurses_programs/JustForFun/tt.c][=tt.c=]]      – Un tutor de mecanografía muy trivial

       [[file:ncurses_programs/basics][basics]]
         ┬
         ├────> [[file:ncurses_programs/basics/acs_vars.c][=acs_vars.c=]]            – Ejemplo de Variables ACS_
         ├────> [[file:ncurses_programs/basics/hello_world.c][=hello_world.c=]]         – Simple programa "Hola Mundo"
         ├────> [[file:ncurses_programs/basics/init_func_example.c][=init_func_example.c=]]   – Ejemplo de funciones de inicialización
         ├────> [[file:ncurses_programs/basics/key_code.c][=key_code.c=]]            – Muestra el código de la tecla pulsada
         ├────> [[file:ncurses_programs/basics/mouse_menu.c][=mouse_menu.c=]]          – Un menú accesible con el ratón
         ├────> [[file:ncurses_programs/basics/other_border.c][=other_border.c=]]        – Muestra el uso de otras funciones de borde
         │                                 – rt de box ()
         ├────> [[file:ncurses_programs/basics/printw_example.c][=printw_example.c=]]      – Ejemplo muy simple de printw()
         ├────> [[file:ncurses_programs/basics/scanw_example.c][=scanw_example.c=]]       – Ejemplo muy simple de getstr()
         ├────> [[file:ncurses_programs/basics/simple_attr.c][=simple_attr.c=]]         – Un programa que puede imprimir archivos c con
         │                                 – comentarios en atributo
         ├────> [[file:ncurses_programs/basics/simple_color.c][=simple_color.c=]]        – Un simple ejemplo que muestra colores
         ├────> [[file:ncurses_programs/basics/simple_key.c][=simple_key.c=]]          – Un menú accesible con las teclas de flecha
         │                                 – ARRIBA, ABAJO
         ├────> [[file:ncurses_programs/basics/temp_leave.c][=temp_leave.c=]]          – Demostracion de salida temporal del modo curses
         ├────> [[file:ncurses_programs/basics/win_border.c][=win_border.c=]]          – Muestra creación de ventanas y bordes
         └────> [[file:ncurses_programs/basics/with_chgat.c][=with_chgat.c=]]          – chgat() ejemplo de uso

       [[file:ncurses_programs/forms][forms]]
         ┬
         ├────> [[file:ncurses_programs/forms/form_attrib.c][=form_attrib.c=]]     – Uso de atributos de campo
         ├────> [[file:ncurses_programs/forms/form_options.c][=form_options.c=]]    – Uso de opciones de campo
         ├────> [[file:ncurses_programs/forms/form_simple.c][=form_simple.c=]]     – Un ejemplo sencillo de formulario
         └────> [[file:ncurses_programs/forms/form_win.c][=form_win.c=]]        – Demo de ventanas asociadas a formularios

       [[file:ncurses_programs/menus][menus]]
         ┬
         ├────> [[file:ncurses_programs/menus/menu_attrib.c][=menu_attrib.c=]]        – Uso de atributos =menu=
         ├────> [[file:ncurses_programs/menus/menu_item_data.c][=menu_item_data.c=]]     – Uso de funciones =item_name()= etc..
         ├────> [[file:ncurses_programs/menus/menu_multi_column.c][=menu_multi_column.c=]]    Crear menús múlti columna
         ├────> [[file:ncurses_programs/menus/menu_scroll.c][=menu_scroll.c=]]        – Demuestra capacidad de desplazamiento en menús
         ├────> [[file:ncurses_programs/menus/menu_simple.c][=menu_simple.c=]]        – Un sencillo menú accesible por las flechas
         ├────> [[file:ncurses_programs/menus/menu_toggle.c][=menu_toggle.c=]]        – Crea menús de multiples valores y explica
         │                                – =REQ_TOGGLE_ITEM=
         ├────> [[file:ncurses_programs/menus/menu_userptr.c][=menu_userptr.c=]]       – Uso del puntero del usuario
         └────> [[file:ncurses_programs/menus/menu_win.c][=menu_win.c=]]           – Demo de ventanas asociadas a menús

       [[file:ncurses_programs/panels][panels]]
         ┬
         ├────> [[file:ncurses_programs/panels/panel_browse.c][=panel_browse.c=]]    – Panel de navegación a través de pestañas.
         │                             – Uso de puntero de usuario
         ├────> [[file:ncurses_programs/panels/panel_hide.c][=panel_hide.c=]]      – Ocultación y despliegue de paneles
         ├────> [[file:ncurses_programs/panels/panel_resize.c][=panel_resize.c=]]    – Mover y cambiar el tamaño de los paneles
         └────> [[file:ncurses_programs/panels/panel_simple.c][=panel_simple.c=]]    – Un ejemplo de panel sencillo

       [[file:ncurses_programs/perl][perl]]
         ┬
         └────> [[file:ncurses_programs/perl/][=01-10.pl=]]    – Equivalentes Perl de los diez primeros programas de ejemplo
   #+END_BLOCK

   # There is a top level Makefile included in the main directory. It
   # builds all the files and puts the ready-to-use exes in demo/exe
   # directory. You can also do selective make by going into the
   # corresponding directory.  Each directory contains a README file
   # explaining the purpose of each c file in the directory.
   Hay un Makefile de nivel superior en el directorio principal. Este
   construye todos los archivos y pone los ejecutables listos para su
   uso en el directorio [[file:ncurses_programs/demo/exe][demo/exe]]. También puede construir los
   programas selectivamente mediante el make del directorio
   correspondiente. Cada directorio contiene un archivo README
   explicando el propósito de cada archivo c en el directorio.

   # For every example, I have included path name for the file relative
   # to the examples directory.
   Para cada ejemplo, he incluido el nombre de ruta relativo al al
   directorio de ejemplos.

   # If you prefer browsing individual programs, point your browser to
   # [[http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs/]]
   Si prefiere navegar por los distintos programas, apunte su navegador para
   [[http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs/]]

   # All the programs are released under the same license that is used
   # by ncurses (MIT-style). ‽ This gives you the ability to do pretty
   # much anything other than claiming them as yours. Feel free to use
   # them in your programs as appropriate.
   Todos los programas son liberados bajo la misma licencia usada para
   ncurses (estilo MIT). Esto le da la capacidad de hacer cualquier
   cosa ademas de reclamar todo como suyo. Siéntase libre de
   utilizarlos en sus programas, según convenga.

# ** 1.6. Other Formats of the document
** 16. Otros formatos del documento

   # This howto is also availabe in various other formats on the
   # tldp.org site. Here are the links to other formats of this
   # document.
   Esta guía también está disponible en otros formatos varios en el
   sitio [[http://tldp.org/][tldp.org]]. Aquí están los enlaces a otros formatos de este
   documento.

# *** 1.6.1. Readily available formats from tldp.org
*** 1.6.1. Formatos de fácil acceso desde tldp.org

    - [[http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/pdf/NCURSES-Programming-HOWTO.pdf][Acrobat PDF Format]]

    - [[http:/www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/ps/NCURSES-Programming-HOWTO.ps.gz][PostScript Format]]

    - [[http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html/NCURSES-Programming-HOWTO-html.tar.gz][In Multiple HTML pages]]

    - [[http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html_single/NCURSES-Programming-HOWTO.html][In One big HTML format]]

# *** 1.6.2. Building from source
*** 1.6.2. Construcción desde codigo fuente

    # If above links are broken or if you want to experiment with sgml
    # read on.
    Si los enlaces anteriores están rotos o si quieres experimentar
    con sgml sigue leyendo.

    # - Get both the source and the tar,gzipped programs, available at
    - El codigo fuente y los programas en tar y gzip, estan
      disponibles en

      http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/NCURSES-HOWTO/NCURSES-Programming-HOWTO.sgml

      http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/NCURSES-HOWTO/ncurses_programs.tar.gz

    # - Unzip =ncurses_programs.tar.gz= with
    - Descomprimir =ncurses_programs.tar.gz= con

      #+BEGIN_SRC sh
        tar zxvf ncurses_programs.tar.gz
      #+END_SRC

    # - Use jade to create various formats. For example if you just want
    #   to create the multiple html files, you would use
    - Utilice jade para crear varios formatos. Por ejemplo, si desea
      crear los múltiples archivos html, utilizaría

      #+BEGIN_SRC sh
        jade -t sgml -i html -d <path to docbook html stylesheet> NCURSES-Programming-HOWTO.sgml
      #+END_SRC

    # - to get pdf, first create a single html file of the HOWTO with
    - Para obtener el pdf, primero hay que crear un único archivo html
      del HOWTO con

      #+BEGIN_SRC sh
        jade -t sgml -i html -d <path to docbook html stylesheet> -V nochunks NCURSES-Programming-HOWTO.sgml > NCURSES-ONE-BIG-FILE.html
      #+END_SRC

    # - then use htmldoc to get pdf file with
    - A continuación, utilizar htmldoc para conseguir el archivo pdf

      #+BEGIN_SRC sh
        htmldoc --size universal -t pdf --firstpage p1 -f <output file name.pdf> NCURSES-ONE-BIG-FILE.html
      #+END_SRC

    # - for ps, you would use
    - Para ps, utilizaría

      #+BEGIN_SRC sh
        htmldoc --size universal -t ps --firstpage p1 -f <output file name.ps> NCURSES-ONE-BIG-FILE.html
      #+END_SRC

    # See [[http://www.tldp.org/LDP/LDP-Author-Guide/][LDP Author guide]] for more details. If all else failes, mail me
    # at [[mailto:ppadala@gmail.com][ppadala@gmail.com]]

    Véa [[http://www.tldp.org/LDP/LDP-Author-Guide/][LDP Author guide]] para más detalles. Si todo lo demas falla,
    envíeme un correo a [[mailto:ppadala@gmail.com][ppadala@gmail.com]]

# ** 1.7. Credits
** 1.7. Créditos

   # I thank [[mailto:sharath_1@usa.net][Sharath]] and Emre Akbas for helping me with few sections.
   # The introduction was initially written by sharath.  I rewrote it
   # with few excerpts taken from his initial work. Emre helped in
   # writing printw and scanw sections.
   Doy las gracias a [[mailto:sharath_1@usa.net][Sharath]] y Emre Akbas por ayudarme con algunas
   secciones.  La introducción fue escrita inicialmente por
   sharath. La Reescribí con algunos extractos tomados de su trabajo
   inicial. Emre ayudó a escribir las secciones printw y scanw.

   # Perl equivalents of the example programs are contributed by
   # [[mailto:Aratnaweera@virtusa.com][Anuradha Ratnaweera]].
   Los equivalentes Perl de los programas de ejemplo son aportados por
   [[mailto:Aratnaweera@virtusa.com][Anuradha Ratnaweera]].

   # Then comes [[mailto:parimi@ece.arizona.edu][Ravi Parimi]], my dearest friend, who has been on this
   # project before even one line was written.  He constantly bombarded
   # me with suggestions and patiently reviewed the whole text. He also
   # checked each program on Linux and Solaris.
   Luego viene [[mailto:parimi@ece.arizona.edu][Ravi Parimi]], mi querido amigo, que ha estado en este
   proyecto antes de escribir ni una línea. Constantemente me
   bombardeado con sugerencias y a revisado pacientemente todo el
   texto. Él también comprobo cada programa en Linux y Solaris.

# ** 1.8. Wish List
** 1.8. Lista de deseos

   # This is the wish list, in the order of priority. If you have a wish
   # or you want to work on completing the wish, mail [[mailto:ppadala@gmail.com][me]].
   Esta es la lista de deseos, en orden de prioridad. Si tienes un
   deseo o quieres trabajar completando alguno, [[mailto:ppadala@gmail.com][enviame]] un correo.

   # - Add examples to last parts of forms section.
   - Añadir ejemplos de últimas partes de la sección de formularios.

   # - Prepare a Demo showing all the programs and allow the user to
   #   browse through description of each program. Let the user compile
   #   and see the program in action. A dialog based interface is
   #   preferred.
   - Preparar una demo que muestre todos los programas y permitir al
     usuario navegar a través de la descripción de cada
     programa. Dejar compilar a el usuario y ver el programa en
     acción. Preferentemente una interfaz basada en diálogo.

   # - Add debug info. =_tracef=, =_tracemouse= stuff.
   - Agregar información de depuración. Cosas =_tracef=, =_tracemouse=.

   # - Accessing termcap, terminfo using functions provided by ncurses
   #   package.
   - Acceso a termcap, terminfo usando las funciones proporcionadas
     por el paquete ncurses.

   # - Working on two terminals simultaneously.
   - Trabajar en dos terminales simultáneamente.

   # - Add more stuff to miscellaneous section.
   - Añadir más cosas a la sección varios.

# ** 1.9. Copyright
** 1.9. Derechos de autor

   Copyright © 2001 by Pradeep Padala.

   Permission is hereby granted, free of charge, to any person
   obtaining a copy of this software and associated documentation
   files (the "Software"), to deal in the Software without
   restriction, including without limitation the rights to use, copy,
   modify, merge, publish, distribute, distribute with modifications,
   sublicense, and/or sell copies of the Software, and to permit
   persons to whom the Software is furnished to do so, subject to the
   following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE
   LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.

   Except as contained in this notice, the name(s) of the above
   copyright holders shall not be used in advertising or otherwise to
   promote the sale, use or other dealings in this Software without
   prior written authorization.

# * 2. Hello World !!!
* 2. Hola Mundo!!!

  # Welcome to the world of curses. Before we plunge into the library
  # and look into its various features, let's write a simple program and
  # say hello to the world.
  Bienvenido al mundo de curses. Antes de sumergimos en la libreria y
  mirar en sus diversas características, vamos a escribir un programa
  simple y decir hola al mundo.

# ** 2.1. Compiling With the NCURSES Library
** 2.1. Compilar con la librería NCURSES

   # To use ncurses library functions, you have to include ncurses.h in
   # your programs. To link the program with ncurses the flag -lncurses
   # should be added.
   Para utilizar las funciones de la libreria ncurses, usted tiene que
   incluir ncurses.h en sus programas. Para enlazar el programa con
   ncurses la bandera -lncurses debe ser agregada.

    #+BEGIN_EXAMPLE
     #include <ncurses.h>
     .
     .
     .

     compilacion y enlace: gcc <archivo de programa> -lncurses
   #+END_EXAMPLE

   # *Example 1. The Hello World !!! Program*
   [[file:ncurses_programs/basics/hello_world.c][*Ejemplo 1. El Programa Hello World !!!*]]

   #+BEGIN_SRC c
     #include <ncurses.h>

     int main()
     {
       initscr();                      /* Inicia el modo curses          */
       printw("Hello World !!!");      /* Imprime Hello World            */
       refresh();                      /* Imprimirlo en la pantalla real */
       getch();                        /* Esperar entrada de usuario     */
       endwin();                       /* Terminar el modo curses        */

       return 0;
     }
   #+END_SRC

# ** 2.2. Dissection
** 2.2. Disección

   # The above program prints "Hello World !!!" to the screen and
   # exits. This program shows how to initialize curses and do screen
   # manipulation and end curses mode. Let's dissect it line by line.
   Las programa anterior inmprime "Hello World !!!" a la pantalla y
   termina. Este programa muestra cómo inicializar curses, manipular
   la pantalla y finalizar el modo curses. Vamos a diseccionar línea
   por línea.

# *** 2.2.1. About initscr()
*** 2.2.1. Acerca de initscr()

    # The function initscr() initializes the terminal in curses mode. In
    # some implementations, it clears the screen and presents a blank
    # screen. To do any screen manipulation using curses package this
    # has to be called first. This function initializes the curses
    # system and allocates memory for our present window (called
    # =stdscr=) and some other data-structures.  Under extreme cases
    # this function might fail due to insufficient memory to allocate
    # memory for curses library's data structures.
    La funcion initscr() inicializa el terminal en modo de curses. En
    algunas implementaciones, se borra la pantalla y presenta una
    pantalla en blanco. Para cualquier manipulación de pantalla
    utilizando el paquete curses este ha de ser llamado primero. Esta
    función inicializa el sistema curses y asigna memoria para la
    ventana actual (llamanda =stdscr=) y algunas otras estructuras de
    datos. En casos extremos esta función puede fallar por falta de
    memoria para almacenar las estructuras de datos de la libreria
    curses.

    # After this is done, we can do a variety of initializations to
    # customize our curses settings. These details will be explained
    # [[@INIT][later]].
    Una vez hecho esto, podemos hacer una variedad de inicializaciones
    para personalizar nuestros ajustes a curses. Estos detalles serán
    explicados [[@INIT][Más adelante]].

# *** 2.2.2. The mysterious refresh()
*** 2.2.2. La misteriosa refresh()

    # The next line printw prints the string "Hello World !!!" on to the
    # screen. This function is analogous to normal printf in all
    # respects except that it prints the data on a window called stdscr
    # at the current (y,x) co-ordinates. Since our present co-ordinates
    # are at 0,0 the string is printed at the left hand corner of the
    # window.
    La siguiente línea =printw= imprime la cadena "Hello World !!!" en
    el pantalla. Esta función es análoga al =printf= normal en todos
    aspectos excepto que imprime los datos en una ventana llamada
    =stdscr= en las coordenadas (y,x) actuales. Al inicio nuestras
    coordenadas actuales están en 0,0 la cadena se imprime en la
    esquina izquierda de la ventana.

    # This brings us to that mysterious refresh(). Well, when we called
    # printw the data is actually written to an imaginary window, which
    # is not updated on the screen yet. The job of printw is to update a
    # few flags and data structures and write the data to a buffer
    # corresponding to stdscr. In order to show it on the screen, we
    # need to call refresh() and tell the curses system to dump the
    # contents on the screen.
    Esto nos lleva al misterioso =refresh()=. Cuando llamamos a
    =printw= los datos se escriben realmente a una ventana imaginaria,
    esto no actualiza la pantalla todavía. El trabajo de =printw= es
    actualizar algunas banderas y estructuras de datos y escribir los
    datos a el buffer correspondiente a =stdscr=. Con el fin de
    mostrar esto en pantalla, deberá llamar a =refresh()= y decirle al
    sistema de curses que debe volcar el contenido en pantalla.

    # The philosophy behind all this is to allow the programmer to do
    # multiple updates on the imaginary screen or windows and do a
    # refresh once all his screen update is done. refresh() checks the
    # window and updates only the portion which has been changed. This
    # improves performance and offers greater flexibility too. But, it
    # is sometimes frustrating to beginners.  A common mistake committed
    # by beginners is to forget to call refresh() after they did some
    # update through printw() class of functions. I still forget to add
    # it sometimes :-)
    La filosofía detrás de todo esto es permitir al programador hacer
    varias actualizaciones en la pantalla o ventana imaginaria y hacer
    un refresco una vez terminada toda la actualización de pantalla.
    =refresh()= comprueba la ventana y actualiza sólo la porción que
    ha cambiado. Esto mejora el rendimiento y también ofrece una mayor
    flexibilidad. Pero a veces es frustrante para los principiantes.
    Un error común cometido por los principiantes es olvidar llamar a
    =refresh()= después de que hacer algunas actualizacions mediante
    funciones de clase =printw()=. A veces todavía lo olvido añadir :-)

# *** 2.2.3. About endwin()
*** 2.2.3. Acerca de endwin()

    # And finally don't forget to end the curses mode. Otherwise your
    # terminal might behave strangely after the program quits. endwin()
    # frees the memory taken by curses sub-system and its data
    # structures and puts the terminal in normal mode. This function
    # must be called after you are done with the curses mode.
    Y, finalmente, no se olvide poner fin al modo curses. De lo
    contrario su terminal puede comportarse de forma extraña después
    de cerrar el programa. =endwin()= libera la memoria tomada por el
    sub-sistema de curses y sus estructuras de datos y pone el
    terminal en modo normal. Esta función debe ser llamada después de
    que haya terminado con el modo de curses.

# * 3. The Gory Details
* 3. Los detalles sangrientos

  # Now that we have seen how to write a simple curses program let's get
  # into the details. There are many functions that help customize what
  # you see on screen and many features which can be put to full use.
  Ahora que hemos visto cómo escribir un programa sencillo vamos a
  entrar en detalles. Hay muchas funciones que ayudan a personalizar
  lo que se ve en pantalla y muchas características que pueden tener
  un uso completo.

  # Here we go...
  Aquí vamos...

# * 4. Initialization                                                   <<@INIT>>
* 4. Inicialización                                                   <<@INIT>>

  # We now know that to initialize curses system the function initscr()
  # has to be called. There are functions which can be called after this
  # initialization to customize our curses session. We may ask the
  # curses system to set the terminal in raw mode or initialize color or
  # initialize the mouse etc.. Let's discuss some of the functions that
  # are normally called immediately after initscr();
  Ahora sabemos que para inicializar el sistema curses la funcion
  =initscr()= ha de ser llamada. Hay funciones que pueden ser llamadas
  después de esta inicialización para personalizar nuestra sesión de
  curses. Podemos cuestionar al sistema curses para configurar el
  terminal en modo raw o inicializar el color o el ratón, etc .. Vamos
  a discutir algunas de las funciones que normalmente se llaman
  inmediatamente después de =initscr()=;

** 4.1. Funciones de inicialización
*** 4.1.1. =raw()= and =cbreak()=

    # Normally the terminal driver buffers the characters a user types
    # until a new line or carriage return is encountered. But most
    # programs require that the characters be available as soon as the
    # user types them. The above two functions are used to disable line
    # buffering. The difference between these two functions is in the way
    # control characters like suspend (CTRL-Z), interrupt and quit
    # (CTRL-C) are passed to the program.  In the raw() mode these
    # characters are directly passed to the program without generating a
    # signal. In the =cbreak()= mode these control characters are
    # interpreted as any other character by the terminal driver. I
    # personally prefer to use raw() as I can exercise greater control
    # over what the user does.
    Normalmente, el terminal maneja buffers de caracteres que el
    usuario escribe hasta que se encuentra una línea nueva o retorno
    de carro. Pero la mayoria de programas requiere que los caracteres
    estén disponibles tan pronto como los escribe el usuario. Las dos
    funciones anteriores se utilizan para desactivar el buffer de
    línea. La diferencia entre estas dos funciones es la forma en que
    los caracteres de control como suspender (CTRL-Z), interrumpir y
    quitar (CTRL-C) se pasan al programa. En el modo =raw()= los
    caracteres pasan directamente al programa sin generar una
    señal. En el modo =cbreak()= estos caracteres de control son
    interpretados como cualquier otro carácter por el controlador de
    terminal. Personalmente prefiero usar =raw()= ya que puedo ejercer
    un mayor control de lo que hace el usuario.

*** 4.1.2. =echo()= and =noecho()=

    # These functions control the echoing of characters typed by the user
    # to the terminal. =noecho()= switches off echoing. The reason you
    # might want to do this is to gain more control over echoing or to
    # suppress unnecessary echoing while taking input from the user
    # through the getch() etc. functions. Most of the interactive
    # programs call =noecho()= at initialization and do the echoing of
    # characters in a controlled manner.  It gives the programmer the
    # flexibility of echoing characters at any place in the window
    # without updating current (y,x) co-ordinates.
    Estas funciones controlan el eco de caracteres generados por el
    usuario al terminal. =noecho()= desactiva el eco. La posible razón
    para hacer esto es mejorar el control sobre el eco o suprimir el
    eco innecesario al tomar la entrada del usuario mediante funciones
    =getch()=. La mayor parte de los programas interactivos llaman a
    =noecho()= en la inicialización y realizan el eco de caracteres de
    manera controlada. Esto le da al programador la flexibilidad de
    imprimir caracteres en cualquier lugar en la ventana sin
    actualizar las coordenadas actuales (y, x).

*** 4.1.3. =keypad()=

    # This is my favorite initialization function. It enables the reading
    # of function keys like F1, F2, arrow keys etc. Almost every
    # interactive program enables this, as arrow keys are a major part of
    # any User Interface. Do =keypad(stdscr, TRUE)= to enable this
    # feature for the regular screen (stdscr). You will learn more about
    # key management in later sections of this document.
    Este es mi función de inicialización favorita. Habilita la lectura
    de teclas de función como F1, F2, teclas de direccion, etc. Casi
    todos los programa interactivos permiten esto, Las teclas de
    dirección son una parte importante de cualquier interfaz de
    usuario. Coloque =keypad(stdscr, TRUE)= para habilitar esta
    función en la pantalla (=stdscr=). Usted aprenderá más sobre
    gestión de teclas en secciones posteriores de este documento.

*** 4.1.4. =halfdelay()=

    # This function, though not used very often, is a useful one at
    # times.  halfdelay()is called to enable the half-delay mode, which
    # is similar to the cbreak() mode in that characters typed are
    # immediately available to program. However, it waits for 'X' tenths
    # of a second for input and then returns ERR, if no input is
    # available. 'X' is the timeout value passed to the function
    # halfdelay(). This function is useful when you want to ask the user
    # for input, and if he doesn't respond with in certain time, we can
    # do some thing else. One possible example is a timeout at the
    # password prompt.
    Esta función, aunque no se utiliza muy a menudo, en ocaciones
    suele ser de utilidad. =halfdelay()= es llamada para activar el
    modo de espera medio, que es similar al modo =cbreak()= en el que
    los caracteres escritos estan disponibles de inmediato para el
    programa. Sin embargo, espera 'X' décimas de segundo por la
    entrada y luego devuelve =ERR=, si no hay entrada disponible. 'X'
    es el valor de tiempo de espera pasado a la función =halfdelay()=.
    Esta función es útil cuando se pide entrada al usuario, y si no
    responde en cierto tiempo, podemos hacer algo más. Un ejemplo
    posible es un tiempo de espera en la solicitud de contraseña.

# ** 4.6. Miscellaneous Initialization functions
** 4.2. Otras funciones de inicialización

   # There are few more functions which are called at initialization to
   # customize curses behavior. They are not used as extensively as
   # those mentioned above. Some of them are explained where
   # appropriate.
   Hay algunas funciones más que se llaman en la inicialización para
   personalizar el comportamiento de curses. No se utilizan tan
   ampliamente como las mencionadas anteriormente. Algunas de estas se
   explican donde es apropiado.

# ** 4.7. An Example
** 4.3. Un ejemplo

   # Let's write a program which will clarify the usage of these
   # functions.
   Vamos a escribir un programa que permitirá aclarar el uso de éstas
   funciones.

   # *Example 2. Initialization Function Usage example*
   [[file:ncurses_programs/basics/init_func_example.c][*Ejemplo 2. Funciones de inicialización*]]

   # #+BEGIN_SRC c
   #   #include <ncurses.h>

   #   int main()
   #   {   int ch;

   #     initscr();                      /* Start curses mode                */
   #     raw();                          /* Line buffering disabled          */
   #     keypad(stdscr, TRUE);           /* We get F1, F2 etc..              */
   #     noecho();                       /* Don't echo() while we do getch   */

   #     printw("Type any character to see it in bold\n");
   #     ch = getch();                   /* If raw() hadn't been called
   #                                      * we have to press enter before it
   #                                      * gets to the program              */
   #     if(ch == KEY_F(1))              /* Without keypad enabled this will */
   #       printw("F1 Key pressed");     /*  not get to us either            */
   #                                     /* Without noecho() some ugly escape
   #                                      * charachters might have been printed
   #                                      * on screen                        */
   #     else
   #       {   printw("The pressed key is ");
   #           attron(A_BOLD);
   #           printw("%c", ch);
   #           attroff(A_BOLD);
   #       }
   #     refresh();                      /* Print it on to the real screen   */
   #     getch();                        /* Wait for user input              */
   #     endwin();                       /* End curses mode                  */

   #     return 0;
   #   }
   # #+END_SRC

   #+BEGIN_SRC c
     #include <ncurses.h>

     int main()
     {   int ch;

       initscr();                      /* Inicia el modo curses            */
       raw();                          /* Desactiva buffer de linea        */
       keypad(stdscr, TRUE);           /* Obtener F1, F2 etc..d            */
       noecho();                       /* Sin echo() al hacer getch        */

       printw("Pulse cualquier caracter para verlo remarcado\n");
       ch = getch();                   /* Si no ha llamado a raw() tenemos
                                        * que pulsar enter antes que que
                                        * que llegue al programa           */
       if(ch == KEY_F(1))              /* sin habilitar keypad esto no     */
         printw("F1 Key pressed");     /* llegara a nosotros               */
                                       /* Sin noecho() algunos feos
                                        * caracteres de escape podrian ser
                                        * impresos en pantalla             */
       else
         {   printw("La tecla pulsada es ");
             attron(A_BOLD);
             printw("%c", ch);
             attroff(A_BOLD);
         }
       refresh();                      /* Imprime en la pantalla real      */
       getch();                        /* Espera entrada de usuario        */
       endwin();                       /* Termina modo curses              */

       return 0;
     }
   #+END_SRC

   # This program is self-explanatory. But I used functions which aren't
   # explained yet. The function =getch()= is used to get a character
   # from user. It is equivalent to normal =getchar()= except that we
   # can disable the line buffering to avoid <enter> after input. Look
   # for more about =getch()=and reading keys in the [[@KEYS][key management
   # section]]. The functions attron and attroff are used to switch some
   # attributes on and off respectively. In the example I used them to
   # print the character in bold. These functions are explained in
   # detail later.
   Este programa se explica por sí mismo. Pero hago uso de funciones
   que aun no se han explicado. La función =getch()= se utiliza para
   obtener un caracter del usuario. Es equivalente un =getchar()=
   normal excepto que puede deshabilitar el buffer de línea para
   evitar <enter> después de la entrada. Para más información sobre
   =getch()= y lectura de teclas eche un vistazo a la seccion [[@KEYS][gestion
   de teclado]]. Las funciones =attron= y =attroff= se utilizan para
   cambiar y desactivar algunos atributos respectivamente. En el
   ejemplo son usadas para imprimir el carácter en negrita. Estas
   funciones se explican en detalle más adelante.

# * 5. A Word about Windows
* 5. Una indicacion acerca de las Ventanas

  # Before we plunge into the myriad ncurses functions, let me clear few
  # things about windows. Windows are explained in detail in following
  # [[@WINDOWS][sections]]
  Antes de sumergirse en las innumerables funciones de ncurses,
  permítanme aclarar algunas cosas acerca de las ventanas. Las
  ventanas se explican en detalle en la siguientes [[@WINDOWS][secciones]]

  # A Window is an imaginary screen defined by curses system. A window
  # does not mean a bordered window which you usually see on Win9X
  # platforms.  When curses is initialized, it creates a default window
  # named =stdscr= which represents your 80x25 (or the size of window in
  # which you are running) screen. If you are doing simple tasks like
  # printing few strings, reading input etc., you can safely use this
  # single window for all of your purposes. You can also create windows
  # and call functions which explicitly work on the specified window.
  Una ventana es una pantalla imaginaria definida por el sistema de
  curses. una ventana no significa una ventana bordeada que por lo
  general se ven en plataformas Win9X. Cuando inicializa curses, se
  crea una ventana por defecto llamada =stdscr= que representa su
  pantalla de 80x25 (o el tamaño de ventana en el que se está
  ejecutando). Si está realizando tareas simples como imprimir algunas
  cadenas, lectura de entrada, etc., puede utilizar con seguridad esta
  única ventana para todos los propósitos. También se pueden crear
  ventanas y llamar a funciones que trabajan de forma explícita en una
  ventana especificada.

  # For example, if you call
  Por ejemplo, si usted llama a

  # #+BEGIN_SRC c
  #   printw("Hi There !!!");
  #   refresh();
  # #+END_SRC

  #+BEGIN_SRC c
    printw("Hola ahi !!!");
    refresh();
  #+END_SRC

  # It prints the string on stdscr at the present cursor
  # position. Similarly the call to refresh(), works on stdscr only.
  Imprime la cadena en =stdscr= en la posicion actual del cursor. Del
  mismo modo la llamada a =refresh()=, funciona sólo en =stdscr=.

  # Say you have created [[@WINDOWS][windows]] then you have to call a function with a
  # 'w' added to the usual function.
  Digamos que ha creado [[@WINDOWS][ventanas]] entonces tiene que llamar a
  una función con una 'w' añadida a la función habitual.

  # #+BEGIN_SRC c
  #   wprintw(win, "Hi There !!!");
  #   wrefresh(win);
  # #+END_SRC

  #+BEGIN_SRC c
    wprintw(win, "Hola ahi !!!");
    wrefresh(win);
  #+END_SRC

  # As you will see in the rest of the document, naming of functions
  # follow the same convention. For each function there usually are
  # three more functions.
  Como se verá en el resto del documento, Los nombres de funcione
  siguen la misma convención. Para cada función por lo general hay
  tres funciones más.

  # #+BEGIN_SRC c
  #   printw(string);           /* Print on stdscr at present cursor position     */
  #   mvprintw(y, x, string);   /* Move to (y, x) then print string               */
  #   wprintw(win, string);     /* Print on window win at present cursor position */
  #                             /* in the window                                  */
  #   mvwprintw(win, y, x, string);  /* Move to (y, x) relative to window         */
  #                                  /* co-ordinates and then print               */
  # #+END_SRC

  #+BEGIN_SRC c
    printw(string);           /* Imprime en stdscr en la posicion actual del cursor */
    mvprintw(y, x, string);   /* Mueve a (y, x) luego imprime la cadena             */
    wprintw(win, string);     /* Imprime en la ventana win en la actual posicion    */
                              /* del cursor en la ventana                           */
    mvwprintw(win, y, x, string);  /* Mueve a las coordenadas (y, x) relativas      */
                                   /* a la ventana y luego imprime                  */
  #+END_SRC

  # Usually the w-less functions are macros which expand to
  # corresponding w-function with stdscr as the window parameter.
  Por lo general, las funciones sin-w son macros que se expanden a la
  correspondiente funcion-w con =stdscr= como parámetro de ventana.

# * 6. Output functions
* 6. Funciones de Salida

  # I guess you can't wait any more to see some action. Back to our
  # odyssey of curses functions. Now that curses is initialized, let's
  # interact with world.
  Supongo que no puede esperar más para ver algo de acción. De nuevo a
  nuestra odisea de funciones. Ahora que curses esta inicializado,
  vamos a interactuar con el mundo.

  # There are three classes of functions which you can use to do output
  # on screen.
  Hay tres clases de funciones que se pueden utilizar para manejar la
  salida en la pantalla.

  # 1. addch() class: Print single character with attributes
  1. Clase =addch()=: Imprimir carácter individual con atributos

  # 2. printw() class: Print formatted output similar to printf()
  2. Clase =printw()=: Imprimir salida con formato similar a
     =printf()=

  # 3. addstr() class: Print strings
  3. Clase =addstr()=: Imprimir cadenas

  # These functions can be used interchangeably and it's a matter of
  # style as to which class is used. Let's see each one in detail.
  Estas funciones se pueden utilizar indistintamente y es cuestión de
  estilo elegir la clase a utilizar. Veamos cada una a detalle.

# ** 6.1. addch() class of functions
** 6.1. Clase de funciones =addch()=

   # These functions put a single character into the current cursor
   # location and advance the position of the cursor. You can give the
   # character to be printed but they usually are used to print a
   # character with some attributes. Attributes are explained in detail
   # in later [[@ATTRIB][sections]] of the document. If a character is associated
   # with an attribute(bold, reverse video etc.), when curses prints the
   # character, it is printed in that attribute.
   Estas funciones colocan un solo carácter en la posicion del cursor
   y avanzan la posición del cursor. Puede dar el carácter a imprimir
   pero por lo general se utilizan para imprimir un caracter con
   algunos atributos. Los atributos se explican a detalle en
   posteriores [[@ATTRIB][secciones]] del documento. Si un caracter está asociado a
   un atributo (negrita, vídeo inverso, etc.), cuando curses imprime
   el carácter, este se imprime con ese atributo.

   # In order to combine a character with some attributes, you have two
   # options:
   A fin de combinar un caracter con algunos atributos, tiene dos
   Opciones:

   # - By OR'ing a single character with the desired attribute
   #   macros. These attribute macros could be found in the header file
   #   =ncurses.h=. For example, you want to print a character ch(of
   #   type char) bold and underlined, you would call addch() as below.
   - con el operador OR enmascarar un solo caracter y la macro del
     atributo deseado. Estas macros de atributos se encuentran en el
     archivo de cabecera =ncurses.h=. Por ejemplo, si desea imprimir
     un carácter =ch= (de tipo char) negrita y subrayado, llamaría a
     =addch()= de la siguiente manera.

     #+BEGIN_SRC c
       addch(ch | A_BOLD | A_UNDERLINE);
     #+END_SRC

   # - By using functions like =attrset(),attron(),attroff()=. These
   #   functions are explained in the [[@ATTRIB][Attributes]] section.  Briefly, they
   #   manipulate the current attributes of the given window.  Once set,
   #   the character printed in the window are associated with the
   #   attributes until it is turned off.
   - Mediante funciones como =attrset()=, =attron()=, =attroff()=.
     Estas funciones se explican en la sección [[@ATTRIB][Attributos]]. Brevemente,
     se pueden manipular los atributos actuales de una ventana
     dada. Una vez establecidos, el carácter impreso está asociado con
     los atributos hasta que se desactivan.


   # Additionally, =curses= provides some special characters for
   # character-based graphics. You can draw tables, horizontal or
   # vertical lines, etc. You can find all avaliable characters in the
   # header file =ncurses.h=. Try looking for macros beginning with
   # =ACS_= in this file.

   Adicionalmente, =curses= proporciona algunos caracteres especiales
   para gráficos basados ​​en caracteres. Puede dibujar tablas, líneas
   horizontales o verticales, etc. Puede encontrar todos los
   caracteres disponibles en el archivo de cabecera =ncurses.h=.
   Intente buscando macros que inicien con =ACS_= en dicho archivo.

# ** 6.2. mvaddch(), waddch() and mvwaddch()
** 6.2. =mvaddch()=, =waddch()= y =mvwaddch()=

   # =mvaddch()= is used to move the cursor to a given point, and then
   # print.  Thus, the calls:
   =mvaddch()= se utiliza para mover el cursor a un punto dado, y
   luego imprimir. Por tanto, las llamadas:

   # #+BEGIN_SRC c
   #   move(row,col);    /* moves the cursor to rowth row and colth column */
   #   addch(ch);
   # #+END_SRC
   #+BEGIN_SRC c
     move(row,col);    /* mueve el cursor a la enesima fila y enesima columna */
     addch(ch);
   #+END_SRC

   # can be replaced by
   puede ser reemplazado por

   #+BEGIN_SRC c
     mvaddch(row,col,ch);
   #+END_SRC

   # =waddch()= is similar to =addch()=, except that it adds a character
   # into the given window. (Note that =addch()= adds a character into
   # the window =stdscr=.)
   =waddch()= es similar a =addch()=, excepto que añade un carácter a
   una ventana dada. (Tenga en cuenta que =addch()= añade un carácter
   a la ventana =stdscr=.)

   # In a similar fashion =mvwaddch()= function is used to add a
   # character into the given window at the given coordinates.
   De manera similar la función =mvwaddch()= se utiliza para añadir un
   carácter a la ventana dada en las coordenadas dadas.

   # Now, we are familiar with the basic output function =addch()=. But,
   # if we want to print a string, it would be very annoying to print it
   # character by character. Fortunately, =ncurses= provides
   # =printf=-like or =puts=-like functions.
   Ahora, estamos familiarizados con la función de salida basico
   =addch()=. Pero, si queremos imprimir una cadena, sera muy molesto
   imprimirla carácter a carácter. Afortunadamente, =ncurses= provee
   funciones similares a =printf= y =puts=.

# ** 6.3. printw() class of functions
** 6.3. Clase de funciones =printw()=

   # These functions are similar to =printf()= with the added capability
   # of printing at any position on the screen.
   Estas funciones son similares a =printf()= con la capacidad añadida
   de imprimir en cualquier posición de la pantalla.

# *** 6.3.1. printw() and mvprintw
*** 6.3.1. =printw()= y =mvprintw=

    # These two functions work much like =printf()=. =mvprintw()= can be
    # used to move the cursor to a position and then print. If you want
    # to move the cursor first and then print using =printw()= function,
    # use =move()= first and then use =printw()= though I see no point
    # why one should avoid using =mvprintw()=, you have the flexibility
    # to manipulate.
    Estas dos funciones operan similar a =printf()=. =mvprintw()= se
    utiliza para mover el cursor a una posición y luego imprimir. Si
    quiere puede mover el cursor y luego imprimir utilizando la
    función =printw()=, primero utilice =move()= y luego =printw()=
    aunque no veo ningún punto para evitar el uso de =mvprintw()=, la
    flexibilidad de manejo es tuya.

# *** 6.3.2. wprintw() and mvwprintw
*** 6.3.2. =wprintw()= y =mvwprintw=

    # These two functions are similar to above two except that they
    # print in the corresponding window given as argument.
    Estas dos funciones son similares a las de dos de arriba, excepto
    que imprimen en la correspondiente ventana dada como argumento.

# *** 6.3.3. vwprintw()
*** 6.3.3. =vwprintw()=

    # This function is similar to =vprintf()=. This can be used when
    # variable number of arguments are to be printed.
    Esta función es similar a =vprintf()=. Se puede utilizar para
    imprimir un número variable de argumentos.

# *** 6.3.4. A Simple printw example
*** 6.3.4. Un ejemplo sencillo de =printw=

    # *Example 3. A Simple printw example*
    [[file:ncurses_programs/basics/printw_example.c][*Ejemplo 3. Un ejemplo sencillo de printw*]]

    #+BEGIN_SRC c
      #include <ncurses.h>              /* ncurses.h incluye stdio.h            */
      #include <string.h>

      int main()
      {
        char mesg[]="Solo una cadena";  /* mensage que aparecera en pantalla     */
        int row,col;                    /* para guardar el numero de filas y     *
                                         * el numero de columnas de la pantalla  */
        initscr();                      /* inicia el modo curses                 */
        getmaxyx(stdscr,row,col);       /* obtiene el numero de filas y columnas */
        mvprintw(row/2,(col-strlen(mesg))/2,"%s",mesg);
                                        /* imprime el mensaje en el centro de la pantalla */
        mvprintw(row-2,0,"Esta pantalla tiene %d filas y %d rolumnas\n",row,col);
        printw("Prueba redimencionar la ventana(si es posible) y corre el programa nuevamente");
        refresh();
        getch();
        endwin();

        return 0;
      }
    #+END_SRC

    # Above program demonstrates how easy it is to use =printw=. You
    # just feed the coordinates and the message to be appeared on the
    # screen, then it does what you want.
    El Programa anterior demuestra lo fácil que es utilizar =printw=.
    Simplemente pase las coordenadas y el mensaje a mostrar en
    pantalla, y luego haga lo que quiera.

    # The above program introduces us to a new function =getmaxyx()=, a
    # macro defined in =ncurses.h=. It gives the number of columns and
    # the number of rows in a given window. =getmaxyx()= does this by
    # updating the variables given to it. Since =getmaxyx()= is not a
    # function we don't pass pointers to it, we just give two integer
    # variables.
    El programa anterior introduce una nueva función =getmaxyx()=, una
    macro definida en =ncurses.h=. Entrega el número de columnas y el
    número de filas en una ventana dada. =getmaxyx()= hace esto
    actulalizando las variables que le son dadas. Ya que =getmaxyx()=
    no es una función no pase punteros en ella, solo entregue dos
    variables entero.

# ** 6.4. addstr() class of functions
** 6.4. clase de funciones =addstr()=

   # =addstr()= is used to put a character string into a given
   # window. This function is similar to calling =addch()= once for each
   # character in a given string. This is true for all output
   # functions. There are other functions from this family such as
   # =mvaddstr(),mvwaddstr()= and =waddstr()=, which obey the naming
   # convention of curses.(e.g. mvaddstr() is similar to the respective
   # calls move() and then addstr().) Another function of this family is
   # addnstr(), which takes an integer parameter(say n)
   # additionally. This function puts at most n characters into the
   # screen. If n is negative, then the entire string will be added.
   =addstr()= se utiliza para poner una cadena de caracteres en una
   ventana determinada. Esta función es similar a llamar a =addch()=
   una vez por cada carácter de una cadena dada. Esto es cierto para
   todas las funciones de salida. Hay otras funciones de esta familia
   como =mvaddstr()=, =mvwaddstr()= y =waddstr()=, que obedecen la
   convención de nomenclatura de curses. (por ejemplo =mvaddstr()= es
   similar a las respectivas llamadas =move()= y luego =addstr()=.)
   Otra de las funciones de esta familia es =addnstr()=, que
   adicionalmente toma un parámetro entero (llamado =n=). Esta función
   pone almenos =n= caracteres en el pantalla. Si =n= es negativo,
   entonces se añadirá toda la cadena.

# ** 6.5. A word of caution
** 6.5. Una plabra de advertencia

   # All these functions take y co-ordinate first and then x in their
   # arguments. A common mistake by beginners is to pass x,y in that
   # order.  If you are doing too many manipulations of (y,x)
   # co-ordinates, think of dividing the screen into windows and
   # manipulate each one separately.  Windows are explained in the
   # [[@WINDOWS][windows]] section.
   Todas estas funciones toman en sus argumentos la coordenada =y=
   primero y =x= despues. Un error común de los principiantes es pasar
   =x=, =y= en ese orden. Si está haciendo demasiadas manipulaciones
   de coordenadas (y, x), considere dividir la pantalla en ventanas y
   manipular cada una por separado. Las ventanas se explican en la
   sección [[@WINDOWS][Ventanas]].

# * 7. Input functions
* 7. Funciones de entrada

  # Well, printing without taking input, is boring. Let's see functions
  # which allow us to get input from user. These functions also can be
  # divided into three categories.
  Bueno, la impresión sin toma de entrada, es aburrida. Veamos las
  funciones que nos permiten tomar la entrada de usuario. Estas
  funciones también pueden ser divididas en tres categorías.

  # 1. getch() class: Get a character
  1. Clase =getch()=: Obtener un caracter

  # 2. scanw() class: Get formatted input
  2. Clase =scanw()=: Obtener entrada con formato

  # 3. getstr() class: Get strings
  3. Clase =getstr()=: Obtener cadenas

# ** 7.1. getch() class of functions
** 7.1. clase de funciones =getch()=

   # These functions read a single character from the terminal. But
   # there are several subtle facts to consider. For example if you
   # don't use the function cbreak(), curses will not read your input
   # characters contiguously but will begin read them only after a new
   # line or an EOF is encountered. In order to avoid this, the cbreak()
   # function must used so that characters are immediately available to
   # your program. Another widely used function is noecho(). As the name
   # suggests, when this function is set (used), the characters that are
   # keyed in by the user will not show up on the screen. The two
   # functions cbreak() and noecho() are typical examples of key
   # management. Functions of this genre are explained in the [[@KEYS][key
   # management section]].
   Estas funciones leen un solo carácter de la terminal. Pero hay
   varios hechos sutiles a considerar. Por ejemplo, si no utiliza la
   función =cbreak()=, curses no leerán sus caracteres de entrada
   forma continua, solo empezara a leerlos sólo después de encontrar
   un caracter de nueva linea o un EOF. Con el fin de evitar esto,
   debe utilizarse la funcion =cbreak()= para que los caracteres están
   disponibles a su prograba inmediatamente. Otra función muy
   utilizada es =noecho()=. Como el nombre sugiere, cuando esta
   función es activada (usada), los caracteres pulsados por el usuario
   no se mostrarán en la pantalla. Las dos funciones =cbreak()= y
   =noecho()= son ejemplos típicos de gestión del teclado. Las
   funciones de este género se explican en la sección [[@keys][gestion del
   teclado]].

# ** 7.2. scanw() class of functions
** 7.2. clase de funciones =scanw()=

   # These functions are similar to =scanf()= with the added capability
   # of getting the input from any location on the screen.
   Estas funciones son similares a =scanf()= con la capacidad añadida
   de conseguir la entrada desde cualquier lugar de la pantalla.

# *** 7.2.1. scanw() and mvscanw
*** 7.2.1. =scanw()= y =mvscanw=

    # The usage of these functions is similar to that of =sscanf()=,
    # where the line to be scanned is provided by =wgetstr()=
    # function. That is, these functions call to =wgetstr()=
    # function(explained below) and uses the resulting line for a scan.
    El uso de estas funciones es similar al de =sscanf()=, donde la
    línea a escanear es proporcionada por la funcien =wgetstr()=. Es
    decir, estas funciones llaman a la funcion =wgetstr()= (explicada
    más adelante) y utilizan la línea resultante de un escaneo.

# *** 7.2.2. wscanw() and mvwscanw()
*** 7.2.2. =wscanw()= y =mvwscanw()=

    # These are similar to above two functions except that they read
    # from a window, which is supplied as one of the arguments to these
    # functions.
    Estas son similares a las dos funciones anteriores excepto que
    leen desde una ventana, que se suministra como uno de los
    argumentos a estas funciones.

# *** 7.2.3. vwscanw()
*** 7.2.3. =vwscanw()=

    # This function is similar to =vscanf()=. This can be used when a
    # variable number of arguments are to be scanned.
    Esta función es similar a =vscanf()=. Se puede utilizar cuando se
    va a escanear una número variable de argumentos.

# ** 7.3. getstr() class of functions
** 7.3. Clase de funciones =getstr()=

   # These functions are used to get strings from the terminal. In
   # essence, this function performs the same task as would be achieved
   # by a series of calls to =getch()= until a newline, carriage return,
   # or end-of-file is received. The resulting string of characters are
   # pointed to by =str=, which is a character pointer provided by the
   # user.
   Estas funciones se utilizan para obtener cadenas desde la terminal.
   Esencialmente, esta función realiza la misma tarea que la que se
   lograría con una serie de llamadas a =getch()= hasta recibir nueva
   línea, retorno de carro, o fin de archivo. La cadena de caracteres
   resultante es apuntada por =str=, El cual es un puntero a carácter
   proporcionado por el usuario.

# ** 7.4. Some examples
** 7.4. Algunos ejemplos

   # *Example 4. A Simple scanw example*
   [[file:ncurses_programs/basics/scanw_example.c][*Ejemplo 4. Un ejemplo sencillo de scanw*]]

   #+BEGIN_SRC c
     #include <ncurses.h>                   /* ncurses.h incluye stdio.h             */
     #include <string.h>

     int main()
     {
       char mesg[]="Ingrese una cadena: ";  /* mensaje a mostrar en pantalla         */
       char str[80];
       int row,col;                         /* para almacenar el numera de filas y   *
                                             * el numero de columnas de pantalla     */
       initscr();                           /* inicia el modo curses                 */
       getmaxyx(stdscr,row,col);            /* obtiene el numero de filas y columnas */
       mvprintw(row/2,(col-strlen(mesg))/2,"%s",mesg);
                                      /* imprime el mensaje al centro de la pantalla */
       getstr(str);
       mvprintw(LINES - 2, 0, "Ha ingresado: %s", str);
       getch();
       endwin();

       return 0;
     }
   #+END_SRC

# * 8. Attributes                                                       <<@ATTRIB>>
* 8. Atributos                                                        <<@ATTRIB>>

  # We have seen an example of how attributes can be used to print
  # characters with some special effects. Attributes, when set
  # prudently, can present information in an easy, understandable
  # manner. The following program takes a C file as input and prints the
  # file with comments in bold. Scan through the code.
  Hemos visto un ejemplo de cómo se pueden utilizar atributos para
  imprimir caracteres con algunos efectos especiales. Cuando los
  atributos se establecen con prudencia, pueden presentar información
  de manera sencilla y comprensible. El siguiente programa toma un
  archivo C como entrada e imprime el archivo con comentarios en
  negrita. Escanea a través del código.

  # *Example 5. A Simple Attributes example*
  [[file:ncurses_programs/basics/simple_attr.c][*Ejemplo 5. Un ejemplo sencillo de atributos*]]

  #+BEGIN_SRC c
    /* pager functionality by Joseph Spainhour" <spainhou@bellsouth.net> */
    #include <ncurses.h>
    #include <stdlib.h>

    int main(int argc, char *argv[])
    {
      int ch, prev, row, col;
      prev = EOF;
      FILE *fp;
      int y, x;

      if(argc != 2)
        {
          printf("Usage: %s <a c file name>\n", argv[0]);
          exit(1);
        }
      fp = fopen(argv[1], "r");
      if(fp == NULL)
        {
          perror("Cannot open input file");
          exit(1);
        }
      initscr();                               /* inicia el modo curses                */
      getmaxyx(stdscr, row, col);              /* obtiene los limites de pantalla      */
      while((ch = fgetc(fp)) != EOF)           /* lee el archivo hasta alcanzar el fin */
        {
          getyx(stdscr, y, x);                 /* obtiene posicion actual del cursor   */
          if(y == (row - 1))                   /* estamos al final de la pantalla      */
            {
              printw("<-Press Any Key->");     /* pide una pulsacion al usuario        */
              getch();
              clear();                         /* limpia la pantalla                   */
              move(0, 0);                      /* comienza al inicio de la pantalla    */
            }
          if(prev == '/' && ch == '*')         /* sololamente cuando es / y *
                                                * cambia a negrita                     */
            {
              attron(A_BOLD);                  /* activa negrita                       */
              getyx(stdscr, y, x);             /* obtiene posicion actual del cursor   */
              move(y, x - 1);                  /* retrocede un espacio                 */
              printw("%c%c", '/', ch);         /* La impresion real sucede aqui       */
            }
          else
            printw("%c", ch);
          refresh();
          if(prev == '*' && ch == '/')
            attroff(A_BOLD);                   /* apagar una vez se ha alcanzado *
                                                * y luego /                            */
          prev = ch;
        }

      printw("<-Press Any Key->");
      getch();

      endwin();                                /* Fin del modo curses                  */
      fclose(fp);
      return 0;
    }
  #+END_SRC

  # Don't worry about all those initialization and other crap.
  # Concentrate on the while loop. It reads each character in the file
  # and searches for the pattern /*. Once it spots the pattern, it
  # switches the BOLD attribute on with = attron()= . When we get the
  # pattern */ it is switched off by = attroff()= .
  No se inquiete con toda esa inicialización y otras mierdas.
  Concéntrese en el bucle while. Se lee cada carácter en el archivo y
  se busca el patrón =/*=. Una vez visto el patrón, cambia el atributo
  a BOLD con =attron()=. Cuando se obtiene el patrón =*/= se desactiva
  mediante =attroff()=.

  # The above program also introduces us to two useful functions
  # =getyx()= and =move()=. The first function gets the co-ordinates of
  # the present cursor into the variables y, x. Since getyx() is a macro
  # we don't have to pass pointers to variables. The function =move()=
  # moves the cursor to the co-ordinates given to it.
  El programa anterior también nos presenta dos funciones útiles
  =getyx()= y =move()=. La primera función obtiene las coordenadas
  actuales del cursor en las variables =y=, =x=. Ya que =getyx()= es
  una macro no tenemos que pasar punteros a variables. La función
  =move()= mueve el cursor a las coordenadas que le son dadas.

  # The above program is really a simple one which doesn't do much. On
  # these lines one could write a more useful program which reads a C
  # file, parses it and prints it in different colors. One could even
  # extend it to other languages as well.
  El programa anterior es realmente muy simple ya que no hace mucho.
  Con estas líneas se podría escribir un programa más útil que lea un
  archivo C, lo analice e imprima en diferentes colores. Podría
  incluso extenderlo a otros lenguajes.

# ** 8.1. The details
** 8.1. Los detalles

   # Let's get into more details of attributes. The functions =attron(),
   # attroff(), attrset()=, and their sister functions = attr_get()=
   # etc.. can be used to switch attributes on/off , get attributes and
   # produce a colorful display.
   Entremos en más detalles sobre los atributos. Las funciones
   =attron()=, =attroff()=, =attrset()=, y sus funciones hermanas
   =attr_get()= etc... se utilizan para encender/apagar atributos,
   obtener atributos y dar una presetracion colorida.

   # The functions attron and attroff take a bit-mask of attributes and
   # switch them on or off, respectively. The following video
   # attributes, which are defined in <curses.h> can be passed to these
   # functions.
   Las funciones =attron= y =attroff= toman una máscara de bits de
   atributos para encenderlos o apagarlos, respectivamente. Los
   siguientes atributos de video, definidos en =<curses.h>= pueden ser
   pasados a estas funciones.

   # #+BEGIN_EXAMPLE
   #   A_NORMAL        Normal display (no highlight)
   #   A_STANDOUT      Best highlighting mode of the terminal.
   #   A_UNDERLINE     Underlining
   #   A_REVERSE       Reverse video
   #   A_BLINK         Blinking
   #   A_DIM           Half bright
   #   A_BOLD          Extra bright or bold
   #   A_PROTECT       Protected mode
   #   A_INVIS         Invisible or blank mode
   #   A_ALTCHARSET    Alternate character set
   #   A_CHARTEXT      Bit-mask to extract a character
   #   COLOR_PAIR(n)   Color-pair number n
   # #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     A_NORMAL         Visualizacion normal (sin resaltar)
     A_STANDOUT       Mejor modo del terminal para resaltado
     A_UNDERLINE      Subrayado
     A_REVERSE        Video inverso
     A_BLINK          Intermitente
     A_DIM            Mitad de brillo
     A_BOLD           Brillo extra o negrita
     A_PROTECT        Modo protegido
     A_INVIS          En modo Invisible o en blanco
     A_ALTCHARSET     Juego de caracteres alternativo
     A_CHARTEXT       Mascara de bits para extraer el caracter
     COLOR_PAIR(n)    Par de color numero /n/
   #+END_EXAMPLE

   # The last one is the most colorful one :-) Colors are explained in
   # the [[@color][next sections]].
   El último es el más colorido :-) Los colores se explican en las
   [[@color][secciones siguentes]].

   # We can OR(|) any number of above attributes to get a combined
   # effect. If you wanted reverse video with blinking characters you
   # can use
   Con OR(|) podemos poner cualquier número de los atributos
   anteriores para obtener un efecto combinado. Si querías vídeo
   inverso con caracteres parpadeantes puedes usar

   #+BEGIN_SRC c
     attron(A_REVERSE | A_BLINK);
   #+END_SRC

# ** 8.2. attron() vs attrset()
** 8.2. =attron()= vs =attrset()=

   # Then what is the difference between attron() and attrset()? attrset
   # sets the attributes of window whereas attron just switches on the
   # attribute given to it. So attrset() fully overrides whatever
   # attributes the window previously had and sets it to the new
   # attribute(s). Similarly attroff() just switches off the
   # attribute(s) given to it as an argument. This gives us the
   # flexibility of managing attributes easily.But if you use them
   # carelessly you may loose track of what attributes the window has
   # and garble the display. This is especially true while managing
   # menus with colors and highlighting. So decide on a consistent
   # policy and stick to it. You can always use =standend()= which is
   # equivalent to =attrset(A_NORMAL)= which turns off all attributes
   # and brings you to normal mode.
   Entonces ¿cuál es la diferencia entre =attron()= y =attrset()=?
   =attrset= establece los atributos de la ventana mientras que
   =attron= simplemente enciende el atributo que le es dado. Así
   =attrset()= anula totalmente los atributos que la ventana tenía
   anteriormente y establece nuevos atributos. Del mismo modo
   =attroff()= simplemente se apaga el atributo que se le da como
   argumento. Esto nos da la flexibilidad de gestiónar los atributos
   facilmente. Pero si se utilizan descuidadamente puede perder la
   pista de que atributos tiene la ventana y distorsionar la
   pantalla. Esto es especialmente cierto cuando maneja menús con
   colores y resaltado. Así que determine una política constante y
   adhierase a ella. Siempre puede utilizar =standend()= (que es
   equivalente a =attrset(A_NORMAL)=) para apagar todos los atributos
   y regresar al modo normal.

# ** 8.3. =attr_get()=
** 8.3. =attr_get()=

   # The function =attr_get()= gets the current attributes and color
   # pair of the window. Though we might not use this as often as the
   # above functions, this is useful in scanning areas of screen. Say we
   # wanted to do some complex update on screen and we are not sure what
   # attribute each character is associated with. Then this function can
   # be used with either attrset or attron to produce the desired
   # effect.
   La función =attr_get()= obtiene los atributos y colores actuales de
   la ventana. Aunque tal vez la utilice tan a menudo como las
   funciones anteriores, es útil para escanear áreas de la pantalla.
   Digamos que queríamos realizar alguna actualización compleja en la
   pantalla y no estamos seguros de cuales atributos estan asociados a
   cada carácter. En ese caso puede utilizadar esta función en
   conjunto con =attrset= o =attron= para producir el efecto deseado.

# ** 8.4. =attr_= functions
** 8.4. funciones =attr_=

   # There are series of functions like =attr_set()=, =attr_on=
   # etc.. These are similar to above functions except that they take
   # parameters of type =attr_t=.
   Hay una serie de funciones como =attr_set()=, =attr_on=,
   etc.. Estas son similares a las funciones anteriores, excepto que
   toman parámetros de tipo =attr_t=.

# ** 8.5. wattr functions
** 8.5. funciones =wattr=

   # For each of the above functions we have a corresponding function
   # with 'w' which operates on a particular window. The above functions
   # operate on stdscr.
   Para cada una de las funciones anteriores tenemos una función
   correspondiente con 'w', que opera en una ventana en
   particular. Las funciones anteriores operar en =stdscr=.

# ** 8.6. chgat() functions
** 8.6. funciones =chgat()=

   # The function chgat() is listed in the end of the man page
   # =curs_attr=. It actually is a useful one. This function can be used
   # to set attributes for a group of characters without moving. I mean
   # it !!! without moving the cursor :-) It changes the attributes of a
   # given number of characters starting at the current cursor location.
   La función =chgat()= aparece al final de la página man =curs_attr=.
   En realidad, es una utilidad. Puede utilizar esta función para
   establecer los atributos de un grupo de caracteres sin moverse.
   Con ello quiero decir !!! sin mover el cursor :-) Esto cambia los
   atributos de un determinado número de caracteres a partir de la
   ubicación actual del cursor.

   # We can give -1 as the character count to update till end of
   # line. If you want to change attributes of characters from current
   # position to end of line, just use this.
   Pasando =-1= como numero de caracteres actualiza hasta el final de
   línea. Si desea cambiar los atributos a los caracteres de la
   posición actual hasta el fin de línea, sólo utilice:

   #+BEGIN_SRC c
     chgat(-1, A_REVERSE, 0, NULL);
   #+END_SRC

   # This function is useful when changing attributes for characters
   # that are already on the screen. Move to the character from which
   # you want to change and change the attribute.
   Esta función es útil cuando se cambian los atributos de caracteres
   que ya estan en pantalla. Valla al caracter desde el que desea
   cambiar y modifique el atributo.

   # Other functions wchgat(), mvchgat(), wchgat() behave similarly
   # except that the w functions operate on the particular window. The
   # mv functions first move the cursor then perform the work given to
   # them. Actually chgat is a macro which is replaced by a wchgat()
   # with stdscr as the window. Most of the "w-less" functions are
   # macros.
   Las otras funciones =wchgat()=, =mvchgat()=, =mvwchgat()= se
   comportan de manera similar excepto que las funciones "w" operan en
   un ventana concreta. Las funciones mv primero mueven el cursor y a
   continuación realizan el trabajo dado. =chgat= en realidad es una
   macro que se sustituye por =wchgat()= con =stdscr= como ventana. La
   mayor parte de las funciones de sin "w" son macros.

   # *Example 6. Chgat() Usage example*
   [[file:ncurses_programs/basics/with_chgat.c][*Ejemplo 6. Ejemplo de uso para chgat()*]]

   #+BEGIN_SRC c
     #include <ncurses.h>

     int main(int argc, char *argv[])
     {   initscr();                      /* Inicia el modo curses            */
       start_color();                    /* Inicia la funcionalidad de color */

       init_pair(1, COLOR_CYAN, COLOR_BLACK);
       printw("Una gran cadena en la que no importa que escribir ");
       mvchgat(0, 0, -1, A_BLINK, 1, NULL);
       /*
        * Los primeros dos parametros especifican la posicion para empezar
        * El tercer parametro es el numero de caracteres a acutalizal, -1
        * quiere decir hasta fin de linea
        * El cuarto parametro es el attributo para el caracter
        * El quinto parametro es el indice de color. Este idice se obtiene
        * con init_pair() utilice 0 si no quiere ningun color
        * El sexto es siempre NULL
        */
       refresh();
       getch();
       endwin();                         /* Fin de modo curses               */
       return 0;
     }
   #+END_SRC

   # This example also introduces us to the color world of curses.
   # Colors will be explained in detail later. Use 0 for no color.
   Este ejemplo también nos introduce en el mundo de color de curses.
   Los colores serán explicadas en detalle más adelante. Utilice 0
   para ningún color.

# * 9. Windows                                                          <<@WINDOWS>>
* 9. Ventanas                                                         <<@WINDOWS>>

  # Windows form the most important concept in curses. You have seen the
  # standard window stdscr above where all the functions implicitly
  # operated on this window. Now to make design even a simplest GUI, you
  # need to resort to windows. The main reason you may want to use
  # windows is to manipulate parts of the screen separately, for better
  # efficiency, by updating only the windows that need to be changed and
  # for a better design. I would say the last reason is the most
  # important in going for windows. You should always strive for a
  # better and easy-to-manage design in your programs. If you are
  # writing big, complex GUIs this is of pivotal importance before you
  # start doing anything.
  Las ventanas forman el concepto más importante en curses. Has visto
  la ventana estándar =stdscr= en la cual todas funciones anteriores
  operan de forma implícita. Ahora para hacer el diseño incluso de una
  GUI sencilla, recurriremos al uso de ventanas. La principal razón
  para utilizar ventanas es para manipular partes de la pantalla por
  separado, abtenietdo asi un mejor redimiento, actualizando sólo las
  ventanas que necesitan cambiar y para un diseño mejor. Yo diría que
  la última razón es la más importante para utilizar ventanas. Usted
  siempre debe luchar por un diseño de sus programas mejor y más fácil
  de gestionar. Si esta escribiendo grandes y complejas GUIs esto es
  de fundamental importancia antes de empezar a hacer cualquier cosa.

# ** 9.1. The basics
** 9.1. Lo basico

   # A Window can be created by calling the function =newwin()=. It
   # doesn't create any thing on the screen actually. It allocates
   # memory for a structure to manipulate the window and updates the
   # structure with data regarding the window like it's size, beginy,
   # beginx etc.. Hence in curses, a window is just an abstraction of an
   # imaginary window, which can be manipulated independent of other
   # parts of screen. The function newwin() returns a pointer to
   # structure WINDOW, which can be passed to window related functions
   # like wprintw() etc.. Finally the window can be destroyed with
   # delwin(). It will deallocate the memory associated with the window
   # structure.
   Puede crear una ventana llamando a la función =newwin()=. Esto en
   realidad no crea nada en la pantalla. Asigna memoria a una
   estructura para manipular la ventana y actualiza la estructura con
   los datos relativos a la ventana como su tamaño, inicioy, iniciox
   etc.. De ahí que en curses, una ventana sea sólo una abstracción
   imaginaria de una ventana, que se puede manipular independiente de
   las demás partes de la pantalla. La funcion =newwin()= devuelve un
   puntero a la estructura =WINDOW=, el cual puede pasar a funciones
   relacionadas con ventanas como =wprintw()= etc.. Finalmente la
   ventana puede ser destruida con =delwin()=. Esto libera la memoria
   asociada con la estructura =WINDOW=.

# ** 9.2. Let there be a Window !!!
** 9.2. Que haya una Ventana !!!

   # What fun is it, if a window is created and we can't see it. So the
   # fun part begins by displaying the window. The function =box()= can
   # be used to draw a border around the window. Let's explore these
   # functions in more detail in this example.
   Lo divertido es, crear una ventana y no poder verla. Comencemos
   mostrando la ventana. La función =box()= sirve para dibujar un
   borde alrededor de la ventana. Vamos a explorar esta y otras
   funciones con más detalle en este ejemplo.

   # *Example 7. Window Border example*
   [[file:ncurses_programs/basics/win_border.c][*Ejemplo 7. Borde en ventana*]]

   #+BEGIN_SRC c
     #include <ncurses.h>

     WINDOW *create_newwin(int height, int width, int starty, int startx);
     void destroy_win(WINDOW *local_win);

     int main(int argc, char *argv[])
     { WINDOW *my_win;
       int startx, starty, width, height;
       int ch;

       initscr();                      /* Inicia el modo curses              */
       cbreak();                       /* Desactivar el buffer de linea
                                        * pasarme todo a mi                  */
       keypad(stdscr, TRUE);           /* Para habilitar F1                  */

       height = 3;
       width = 10;
       starty = (LINES - height) / 2;  /* Calculo para colocar al centro     */
       startx = (COLS - width) / 2;    /* de la ventana                      */
       printw("Pulse F1 para salir");
       refresh();
       my_win = create_newwin(height, width, starty, startx);

       while((ch = getch()) != KEY_F(1))
         {   switch(ch)
             {   case KEY_LEFT:
                 destroy_win(my_win);
                 my_win = create_newwin(height, width, starty, --startx);
                 break;
             case KEY_RIGHT:
               destroy_win(my_win);
               my_win = create_newwin(height, width, starty, ++startx);
               break;
             case KEY_UP:
               destroy_win(my_win);
               my_win = create_newwin(height, width, --starty, startx);
               break;
             case KEY_DOWN:
               destroy_win(my_win);
               my_win = create_newwin(height, width, ++starty, startx);
               break;
             }
         }

       endwin();                       /* Fin del modo curses                */
       return 0;
     }

     WINDOW *create_newwin(int height, int width, int starty, int startx)
     { WINDOW *local_win;

       local_win = newwin(height, width, starty, startx);
       box(local_win, 0, 0);           /* 0, 0 pone los caracteres por
                                        * defecto para las lineas vertical
                                        * y horizontal                       */
       wrefresh(local_win);            /* Muestra la caja                    */

       return local_win;
     }

     void destroy_win(WINDOW *local_win)
     {
       /* box(local_win, ' ', ' '); : Esto no produce el resultado deseado
        * de borrar la ventana. Deja las cuatro esquinas como un feo residuo
        * de la ventana.
        */
       wborder(local_win, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ');
       /* Los parametros tomados son
        * 1. win: la ventana sobre la que operar
        * 2. ls: caracter a utilizar para el lado izquierdo de la ventana
        * 3. rs: caracter a utilizar para el lado derecho de la ventana
        * 4. ts: caracter a utilizar para el lado superior de la ventana
        * 5. bs: caracter a utilizar para el lado inferior de la ventana
        * 6. tl: caracter a utilizar para la esquina superior isquierda de la ventana
        * 7. tr: caracter a utilizar para la esquina superior derecha de la ventana
        * 8. bl: caracter a utilizar para la esquina inferior izquierda de la ventana
        * 9. br: caracter a utilizar para la esquina inferior derecha de la ventana
        */
       wrefresh(local_win);
       delwin(local_win);
     }
   #+END_SRC

# ** 9.3. Explanation
** 9.3. Explicación

   # Don't scream. I know it's a big example. But I have to explain some
   # important things here :-). This program creates a rectangular
   # window that can be moved with left, right, up, down arrow keys. It
   # repeatedly creates and destroys windows as user press a key. Don't
   # go beyond the screen limits. Checking for those limits is left as
   # an exercise for the reader. Let's dissect it by line by line.
   No grites. Sé que es un ejemplo grande. Pero tengo que explicar
   algunas cosas importantes aquí :-). Este programa crea una ventana
   rectangular que se puede mover con las teclas de flecha izquierda,
   derecha, arriba y abajo. Con la creacion y destruccion repetida de
   ventanas cuando el usuario presiona una tecla. No valla más allá de
   los límites de la pantalla. La comprobación de estos límites se
   deja como un ejercicio para el lector. Vamos a diseccionar línea
   por línea.

   # The =create_newwin()= function creates a window with =newwin()= and
   # displays a border around it with box. The function =destroy_win()=
   # first erases the window from screen by painting a border with ' '
   # character and then calling =delwin()= to deallocate memory related
   # to it. Depending on the key the user presses, starty or startx is
   # changed and a new window is created.
   El funcion =create_newwin()= crea una ventana con =newwin()= y
   muestra un borde alrededor con =box()=. La función =destroy_win()=
   primero borra la ventana de pantalla pintando un borde con el
   caracter ' ' y luego llama a =delwin()= para liberar la memoria.
   Dependiendo de la tecla que el usuario presiona, se cambia =starty=
   o =startx= y se crea una nueva ventana.

   # In the =destroy_win=, as you can see, I used wborder instead of
   # box. The reason is written in the comments (You missed it. I
   # know. Read the code :-)). wborder draws a border around the window
   # with the characters given to it as the 4 corner points and the 4
   # lines. To put it clearly, if you have called wborder as below:
   Como puede ver en =destroy_win=, he usado =wborder()= en lugar de
   =box()=. La razón está escrita en los comentarios (Te lo
   perdiste. Lo se. Lee el codigo :-)). =wborder()= dibuja un borde
   alrededor de la ventana con los caracteres dados para las 4
   esquinas y las 4 líneas. Para decirlo claramente, si llama a
   =wborder()= como a continuación:

   #+BEGIN_SRC c
     wborder(win, '|', '|', '-', '-', '+', '+', '+', '+');
   #+END_SRC

   # it produces some thing like
   se produce algo como

   #+BEGIN_EXAMPLE
     +------------+
     |            |
     |            |
     |            |
     |            |
     |            |
     |            |
     +------------+
   #+END_EXAMPLE

# ** 9.4. The other stuff in the example
** 9.4. Las otras cosas en el ejemplo

   # You can also see in the above examples, that I have used the
   # variables COLS, LINES which are initialized to the screen sizes
   # after initscr().  They can be useful in finding screen dimensions
   # and finding the center co-ordinate of the screen as above. The
   # function =getch()= as usual gets the key from keyboard and
   # according to the key it does the corresponding work. This type of
   # switch-case is very common in any GUI based programs.
   También puede ver que en los ejemplos anteriores, he utilizado las
   variables =COLS= y =LINES= que se inicializan con el tamaño de
   pantalla después de llamar a =initscr()=. Pueden ser útiles para
   obtener las dimensiones de la pantalla y para localizar las
   cordenadas al centro de la pantalla. Como siempre la función
   =getch()= obtiene informacion del teclado y de acuerdo a esta se
   hace el trabajo correspondiente. Este tipo de switch-case es muy
   común en todos los programas basados en GUI.

# ** 9.5. Other Border functions
** 9.5. Otras funciones de Borde

   # Above program is grossly inefficient in that with each press of a
   # key, a window is destroyed and another is created. So let's write a
   # more efficient program which uses other border related functions.
   El programa anterior es muy ineficiente ya que a cada pulsación, se
   destruye una ventana y se crea otra. Así que vamos a escribir un
   programa más eficiente que utiliza otras funciones relacionadas con
   bordes.

   # The following program uses =mvhline()= and =mvvline()= to achieve
   # similar effect. These two functions are simple. They create a
   # horizontal or vertical line of the specified length at the
   # specified position.
   El siguiente programa utiliza =mvhline()= y =mvvline()= para lograr
   un efecto similar. Estas dos funciones son simples. Crean un línea
   horizontal o vertical de la longitud especificada en la posición
   especificada.

   # *Example 8. More border functions*
   [[file:ncurses_programs/basics/other_border.c][*Ejemplo 8. Más funciones de borde*]]

   #+BEGIN_SRC c
     #include <ncurses.h>

     typedef struct _win_border_struct {
       chtype  ls, rs, ts, bs,
         tl, tr, bl, br;
     } WIN_BORDER;

     typedef struct _WIN_struct {
       int startx, starty;
       int height, width;
       WIN_BORDER border;
     } WIN;

     void init_win_params(WIN *p_win);
     void print_win_params(WIN *p_win);
     void create_box(WIN *win, bool flag);

     int main(int argc, char *argv[])
     { WIN win;
       int ch;

       initscr();                      /* Inicia el modo curses           */
       start_color();                  /* Inicia la fucionalidad de color */
       cbreak();                       /* Desactivar el buffer de linea,
                                        * pasarme todo a mi               */
       keypad(stdscr, TRUE);           /* Necesario para habilitar F1     */
       noecho();
       init_pair(1, COLOR_CYAN, COLOR_BLACK);

       /* Inicializa los parametros de ventana */
       init_win_params(&win);
       print_win_params(&win);

       attron(COLOR_PAIR(1));
       printw("Pulse F1 para salir");
       refresh();
       attroff(COLOR_PAIR(1));

       create_box(&win, TRUE);
       while((ch = getch()) != KEY_F(1))
         {   switch(ch)
             {   case KEY_LEFT:
                 create_box(&win, FALSE);
                 --win.startx;
                 create_box(&win, TRUE);
                 break;
             case KEY_RIGHT:
               create_box(&win, FALSE);
               ++win.startx;
               create_box(&win, TRUE);
               break;
             case KEY_UP:
               create_box(&win, FALSE);
               --win.starty;
               create_box(&win, TRUE);
               break;
             case KEY_DOWN:
               create_box(&win, FALSE);
               ++win.starty;
               create_box(&win, TRUE);
               break;
             }
         }
       endwin();                       /* Fin del modo curses             */
       return 0;
     }
     void init_win_params(WIN *p_win)
     {
       p_win->height = 3;
       p_win->width = 10;
       p_win->starty = (LINES - p_win->height)/2;
       p_win->startx = (COLS - p_win->width)/2;

       p_win->border.ls = '|';
       p_win->border.rs = '|';
       p_win->border.ts = '-';
       p_win->border.bs = '-';
       p_win->border.tl = '+';
       p_win->border.tr = '+';
       p_win->border.bl = '+';
       p_win->border.br = '+';

     }
     void print_win_params(WIN *p_win)
     {
     #ifdef _DEBUG
       mvprintw(25, 0, "%d %d %d %d", p_win->startx, p_win->starty,
                p_win->width, p_win->height);
       refresh();
     #endif
     }
     void create_box(WIN *p_win, bool flag)
     { int i, j;
       int x, y, w, h;

       x = p_win->startx;
       y = p_win->starty;
       w = p_win->width;
       h = p_win->height;

       if(flag == TRUE)
         { mvaddch(y, x, p_win->border.tl);
           mvaddch(y, x + w, p_win->border.tr);
           mvaddch(y + h, x, p_win->border.bl);
           mvaddch(y + h, x + w, p_win->border.br);
           mvhline(y, x + 1, p_win->border.ts, w - 1);
           mvhline(y + h, x + 1, p_win->border.bs, w - 1);
           mvvline(y + 1, x, p_win->border.ls, h - 1);
           mvvline(y + 1, x + w, p_win->border.rs, h - 1);

         }
       else
         for(j = y; j <= y + h; ++j)
           for(i = x; i <= x + w; ++i)
             mvaddch(j, i, ' ');

       refresh();

     }
   #+END_SRC

# * 10. Colors                                                          <<@color>>
* 10. Colores                                                         <<@color>>
# ** 10.1. The basics
** 10.1. Lo basico

   # Life seems dull with no colors. curses has a nice mechanism to
   # handle colors. Let's get into the thick of the things with a small
   # program.
   La vida parece aburrida sin colores. curses tiene un buen mecanismo
   para el manejo de colores. Vamos a entrar de lleno con un pequeño
   programa.

   # *Example 9. A Simple Color example*
   [[file:ncurses_programs/basics/simple_color.c][*Ejemplo 9. Un ejemplo simple de color*]]

   #+BEGIN_SRC c
     #include <stdlib.h>
     #include <string.h>
     #include <ncurses.h>

     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string);
     int main(int argc, char *argv[])
     { initscr();                /* Inica el modo curses     */
       if(has_colors() == FALSE)
         { endwin();
           printf("Tu terminar no soporta color\n");
           exit(1);
         }
       start_color();            /* Inicia el color          */
       init_pair(1, COLOR_RED, COLOR_BLACK);

       attron(COLOR_PAIR(1));
       print_in_middle(stdscr, LINES / 2, 0, 0, "Viola !!! En color ...");
       attroff(COLOR_PAIR(1));
       getch();
       endwin();
     }
     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string)
     { int length, x, y;
       float temp;

       if(win == NULL)
         win = stdscr;
       getyx(win, y, x);
       if(startx != 0)
         x = startx;
       if(starty != 0)
         y = starty;
       if(width == 0)
         width = 80;

       length = strlen(string);
       temp = (width - length)/ 2;
       x = startx + (int)temp;
       mvwprintw(win, y, x, "%s", string);
       refresh();
     }
   #+END_SRC

   # As you can see, to start using color, you should first call the
   # function =start_color()=. After that, you can use color
   # capabilities of your terminals using various functions. To find out
   # whether a terminal has color capabilities or not, you can use
   # =has_colors()= function, which returns FALSE if the terminal does
   # not support color.
   Como puede ver, para empezar a utilizar el color, primero debe
   llamar a la función =start_color()=. Después de eso, puede utilizar
   las capacidades de color de su terminal utilizando distintas
   funciones. Pasa averiguar si un terminal tiene capacidades de color
   o no, puede utilizar la funcion =has_colors()=, que devuelve
   =FALSE= si el terminal no soporta color.

   # curses initializes all the colors supported by terminal when
   # =start_color()= is called. These can be accessed by the define
   # constants like =COLOR_BLACK= etc. Now to actually start using
   # colors, you have to define pairs. Colors are always used in
   # pairs. That means you have to use the function =init_pair()= to
   # define the foreground and background for the pair number you
   # give. After that that pair number can be used as a normal attribute
   # with =COLOR_PAIR()= function. This may seem to be cumbersome at
   # first. But this elegant solution allows us to manage color pairs
   # very easily. To appreciate it, you have to look into the the source
   # code of "dialog", a utility for displaying dialog boxes from shell
   # scripts. The developers have defined foreground and background
   # combinations for all the colors they might need and initialized at
   # the beginning. This makes it very easy to set attributes just by
   # accessing a pair which we already have defined as a constant.
   curses inicializa todos los colores admitidos por el terminal
   cuando llama a =start_color()=. Estos estan accesibles mediante
   constantes como =COLOR_BLACK=, etc. Ahora para realizar un manejo
   efectivo de colores, debe definir pares. Los colores siempre se
   utilizan en pares. Esto significa hacer uso de la función
   =init_pair()= para definir el color de el frente y el fondo para un
   numero de pares deseado. Después los pares pueden ser utilizados
   como un atributo normal con la funcion =COLOR_PAIR()=. Esto puede
   parecer incómodo al inicio. Pero esta elegante solución nos permite
   gestionar pares de colores muy facilmente. Para apreciarlo, mire el
   codigo fuente de "dialog", una utilidad para mostrar cuadros de
   diálogo en scripts de shell. Los desarrolladores definen todas las
   combinaciones de color que se podiran necesitar y son inicializas
   al inicio. Esto fácilita establecer atributos y acceder a parejas
   ya definidas como constantes.

   # The following colors are defined in =curses.h=. You can use these
   # as parameters for various color functions.
   Los siguientes colores están definidos en =curses.h=. Usted puede
   hacer uso de estos como parámetros para las distintas funciones de
   color.

   #+BEGIN_EXAMPLE
     COLOR_BLACK   0
     COLOR_RED     1
     COLOR_GREEN   2
     COLOR_YELLOW  3
     COLOR_BLUE    4
     COLOR_MAGENTA 5
     COLOR_CYAN    6
     COLOR_WHITE   7
   #+END_EXAMPLE

# ** 10.2. Changing Color Definitions
** 10.2. Cambio en Definiciones de Color

   # The function =init_color()= can be used to change the rgb values
   # for the colors defined by curses initially. Say you wanted to
   # lighten the intensity of red color by a minuscule. Then you can use
   # this function as
   Puede utilizar la función =init_color()= para cambiar los valores
   RGB definidos por curses inicialmente. Digamos que quiere aligerar
   la intensidad del color rojo para una minúscula. Entonces puede
   utilizar esta función como

   #+BEGIN_SRC c
     init_color(COLOR_RED, 700, 0, 0);
     /* param 1     : nombre de color
      * param 2, 3, 4 : contenido rgb min = 0, max = 1000 */
   #+END_SRC

   # If your terminal cannot change the color definitions, the function
   # returns ERR. The function =can_change_color()= can be used to find
   # out whether the terminal has the capability of changing color
   # content or not. The rgb content is scaled from 0 to 1000. Initially
   # RED color is defined with content 1000(r), 0(g), 0(b).
   Si el terminal no puede cambiar las definiciones de color, la
   función devuelve =ERR=. Puede utilizar la función
   =can_change_color()= para conocer si el terminal tiene la capacidad
   de cambiar el contenido de color o no. El contenido rgb se escala
   de 0 a 1000. Inicialmente =COLOR_RED= es definido con un contenido
   de 1,000(r), 0(g), 0(b).

# ** 10.3. Color Content
** 10.3. Contenido en color

   # The functions =color_content()= and =pair_content()= can be used to
   # find the color content and foreground, background combination for
   # the pair.
   Puede utilizar las funciones =color_content()= y =pair_content()=
   para conocer el contenido de color y la combinacion de frente y
   fondo de un par.

# * 11. Interfacing with the key board                                  <<@KEYS>>
* 11. Comunicandonos con el teclado                                   <<@KEYS>>
# ** 11.1. The Basics
** 11.1. Lo basico

   # No GUI is complete without a strong user interface and to interact
   # with the user, a curses program should be sensitive to key presses
   # or the mouse actions done by the user. Let's deal with the keys
   # first.
   Ningun GUI está completo sin una fuerte interfaz de usuario y para
   interactuar con el usuario, un programa curses debe ser sensible a
   la pulsacion de teclas o las acciones del ratón realizadas por el
   usuario. Vamos a tratar con las teclas primero.

   # As you have seen in almost all of the above examples, it's very
   # easy to get key input from the user. A simple way of getting key
   # presses is to use =getch()= function. The cbreak mode should be
   # enabled to read keys when you are interested in reading individual
   # key hits rather than complete lines of text (which usually end with
   # a carriage return).  keypad should be enabled to get the Functions
   # keys, arrow keys etc. See the initialization section for details.
   Como se ha visto en casi todos los ejemplos anteriores, es muy
   fácil obtener la entrada de teclado del usuario. Una manera simple
   de conseguir pulsaciones del teclado es utilizar la funcion
   =getch()=.  El modo =cbreak= debe estar habilitado para leer las
   teclas individualmente en lugar de lineas completas de texto (que
   por lo general terminan con un retorno de carro). Debe habilitar
   =keypad= para obtener las teclas de funcion, flecha, etc. Vea la
   sección [[@INIT][Inicialización]] para más detalles.

   # =getch()= returns an integer corresponding to the key pressed. If
   # it is a normal character, the integer value will be equivalent to
   # the character. Otherwise it returns a number which can be matched
   # with the constants defined in =curses.h=. For example if the user
   # presses F1, the integer returned is 265. This can be checked using
   # the macro =KEY_F()= defined in curses.h. This makes reading keys
   # portable and easy to manage.
   =getch()= devuelve un entero correspondiente a la tecla pulsada. Si
   es un caracter normal, el valor entero será equivalente a el
   caracter. De lo contrario, devuelve un número que pueda ser
   igualado con las constantes definidas en =curses.h=. Por ejemplo,
   si el usuario presiona F1, el entero devuelto es 265. Esto se puede
   comprobar con la macro =KEY_F()= defina en =curses.h=. Esto vuelve
   la lectura portáble y fácil de manejar.

   # For example, if you call getch() like this
   Por ejemplo, si llama a =getch()= como

   #+BEGIN_SRC c
     int ch;
     ch = getch();
   #+END_SRC

   # getch() will wait for the user to press a key, (unless you
   # specified a timeout) and when user presses a key, the corresponding
   # integer is returned. Then you can check the value returned with the
   # constants defined in curses.h to match against the keys you want.
   =getch()= esperará a que el usuario presione una tecla, (a menos
   que especique un tiempo de espera) y cuando el usuario pulsa una
   tecla, se devuelve el entero correspondiente . A continuación,
   puede comprobar el valor correspondiente devuelto con las
   constantes definidas en =curses.h= contra las teclas que deseadas.

   # The following code piece will do that job.
   El siguiente fragmento de código hara ese trabajo.

   #+BEGIN_SRC c
     if(ch == KEY_LEFT)
       printw("Left arrow is pressed\n");
   #+END_SRC

   # Let's write a small program which creates a menu which can be
   # navigated by up and down arrows.
   Vamos a escribir un pequeño programa que crea un menú navegable con
   las flechas arriba y abajo.

# ** 11.2. A Simple Key Usage example
** 11.2. Ejemplo simple de uso de teclado

   # *Example 10. A Simple Key Usage example*
   [[file:ncurses_programs/basics/simple_key.c][*Ejemplo 10. Uso sencillo del teclado*]]

   #+BEGIN_SRC c
     #include <stdio.h>
     #include <ncurses.h>

     #define WIDTH  30
     #define HEIGHT 10

     int startx = 0;
     int starty = 0;

     char *choices[] = {
       "Eleccion 1",
       "Eleccion 2",
       "Eleccion 3",
       "Eleccion 4",
       "Salir",
     };
     int n_choices = sizeof(choices) / sizeof(char *);
     void print_menu(WINDOW *menu_win, int highlight);

     int main()
     { WINDOW *menu_win;
       int highlight = 1;
       int choice = 0;
       int c;

       initscr();
       clear();
       noecho();
       cbreak();   /* Buffer de linea desactivado. Pasar de todo */
       startx = (80 - WIDTH) / 2;
       starty = (24 - HEIGHT) / 2;

       menu_win = newwin(HEIGHT, WIDTH, starty, startx);
       keypad(menu_win, TRUE);
       mvprintw(0, 0, "Utilice las flechas para ir arriba y abajo, Presione enter para elegir");
       refresh();
       print_menu(menu_win, highlight);
       while(1)
         { c = wgetch(menu_win);
           switch(c) {
             case KEY_UP:
               if(highlight == 1)
                 highlight = n_choices;
               else
                 --highlight;
               break;
             case KEY_DOWN:
               if(highlight == n_choices)
                 highlight = 1;
               else
                 ++highlight;
               break;
             case 10:
               choice = highlight;
               break;
             default:
               mvprintw(24, 0, "Caracter presionado = %3d Ojala se imprima como '%c'", c, c);
               refresh();
               break;
             }
           print_menu(menu_win, highlight);
           if(choice != 0) /* El usuario eligio salir del bucle infinito */
             break;
         }
       mvprintw(23, 0, "Elegiste la opcion %d con la cadena %s\n", choice, choices[choice - 1]);
       clrtoeol();
       refresh();
       getch();
       endwin();
       return 0;
     }

     void print_menu(WINDOW *menu_win, int highlight)
     {
       int x, y, i;

       x = 2;
       y = 2;
       box(menu_win, 0, 0);
       for(i = 0; i < n_choices; ++i)
         {   if(highlight == i + 1) /* Resalta lo opcion actual */
             { wattron(menu_win, A_REVERSE);
               mvwprintw(menu_win, y, x, "%s", choices[i]);
               wattroff(menu_win, A_REVERSE);
             }
           else
             mvwprintw(menu_win, y, x, "%s", choices[i]);
           ++y;
         }
       wrefresh(menu_win);
     }
   #+END_SRC

# * 12. Interfacing with the mouse
* 12. Interfaz con el ratón

  # Now that you have seen how to get keys, lets do the same thing from
  # mouse. Usually each UI allows the user to interact with both
  # keyboard and mouse.
  Ahora hemos visto cómo obtener informacion del teclado, hagamos los
  mismo desde el ratón. Por lo general, cada interfaz de usuario
  permite al usuario interactuar con ambos, teclado y ratón.

# ** 12.1. The Basics
** 12.1. Lo basico

   # Before you do any thing else, the events you want to receive have
   # to be enabled with =mousemask()=.
   Antes de hacer cualquier otra cosa, los eventos que desea recibir
   deben ser habilitados con =mousemask()=.

   # #+BEGIN_SRC c
   #   mousemask( mmask_t newmask,    /* The events you want to listen to */
   #              mmask_t *oldmask ); /* The old events mask              */
   # #+END_SRC

   #+BEGIN_SRC c
     mousemask( mmask_t newmask,    /* Los eventos que quiere escuchar  */
                mmask_t *oldmask ); /* La anterior mascara de eventos   */
   #+END_SRC

   # The first parameter to above function is a bit mask of events you
   # would like to listen. By default, all the events are turned
   # off. The bit mask =ALL_MOUSE_EVENTS= can be used to get all the
   # events.
   El primer parámetro de la función anterior es una máscara de bits
   de los eventos que le gustaría escuchar. Por defecto, todos los
   eventos están apagados. La máscara de bits =ALL_MOUSE_EVENTS= se
   puede utilizar para obtener todos los eventos.

   # The following are all the event masks:
   Las siguientes son todas las máscaras de eventos:

   | Name                     | Description                                            |
   |--------------------------+--------------------------------------------------------|
   | ~BUTTON1_PRESSED~        | boton 1 del mouse abajo                                |
   | ~BUTTON1_RELEASED~       | boton 1 del mouse arriba                               |
   | ~BUTTON1_CLICKED~        | boton 1 del mouse clic                                 |
   | ~BUTTON1_DOUBLE_CLICKED~ | boton 1 del mouse doble clic                           |
   | ~BUTTON1_TRIPLE_CLICKED~ | boton 1 del mouse triple clic                          |
   | ~BUTTON2_PRESSED~        | boton 2 del mouse abajo                                |
   | ~BUTTON2_RELEASED~       | boton 2 del mouse arriba                               |
   | ~BUTTON2_CLICKED~        | boton 2 del mouse clic                                 |
   | ~BUTTON2_DOUBLE_CLICKED~ | boton 2 del mouse doble clic                           |
   | ~BUTTON2_TRIPLE_CLICKED~ | boton 2 del mouse triple clic                          |
   | ~BUTTON3_PRESSED~        | boton 3 del mouse abajo                                |
   | ~BUTTON3_RELEASED~       | boton 3 del mouse arriba                               |
   | ~BUTTON3_CLICKED~        | boton 3 del mouse clic                                 |
   | ~BUTTON3_DOUBLE_CLICKED~ | boton 3 del mouse doble clic                           |
   | ~BUTTON3_TRIPLE_CLICKED~ | boton 3 del mouse triple clic                          |
   | ~BUTTON4_PRESSED~        | boton 4 del mouse abajo                                |
   | ~BUTTON4_RELEASED~       | boton 4 del mouse up                                   |
   | ~BUTTON4_CLICKED~        | boton 4 del mouse clic                                 |
   | ~BUTTON4_DOUBLE_CLICKED~ | boton 4 del mouse doble clic                           |
   | ~BUTTON4_TRIPLE_CLICKED~ | boton 4 del mouse triple clic                          |
   | ~BUTTON_SHIFT~           | se pulso shift durante el cambio de estado del boton   |
   | ~BUTTON_CTRL~            | se pulso control durante el cambio de estado del boton |
   | ~BUTTON_ALT~             | se pulso alt durante el cambio de estado del boton     |
   | ~ALL_MOUSE_EVENTS~       | informa todos los cambios de estados                   |
   | ~REPORT_MOUSE_POSITION~  | informa movimiento del mouse                           |

# ** 12.2. Getting the events
** 12.2. Obtención de eventos

   # Once a class of mouse events have been enabled, getch() class of
   # functions return =KEY_MOUSE= every time some mouse event
   # happens. Then the mouse event can be retrieved with =getmouse()=.
   Una vez que una clase de eventos de ratón se ha habilitado, las
   funciones de clase =getch()= devuelven =KEY_MOUSE= cada vez que
   sucede un evento de ratón. En ese caso, el evento de ratón puede
   ser recuperado con =getmouse()=.

   # The code approximately looks like this:
   El código es aproximadamente así:

   #+BEGIN_SRC c
     MEVENT event;
     ch = getch();
     if(ch == KEY_MOUSE)
       if(getmouse(&event) == OK)
         .    /* Hacer algo con el evento */
         .
         .
   #+END_SRC

   # getmouse() returns the event into the pointer given to it. It's a
   # structure which contains
   =getmouse()= devuelve el evento en el puntero que se le da. Es un
   estructura que contiene

   #+BEGIN_SRC c
     typedef struct
     {
       short id;         /* ID para distinguir multiples dispositivos */
       int x, y, z;      /* coordenadas del evento   */
       mmask_t bstate;   /* bits de estado del boton */
     }
   #+END_SRC

   # The =bstate= is the main variable we are interested in. It tells
   # the button state of the mouse.
   =bstate= es la variable que mayor nos interesa. Informa el estado
   del botón del ratón.

   # Then with a code snippet like the following, we can find out what
   # happened.
   Luego, con un fragmento de código como el siguiente, podemos
   averiguar lo sucedido.

   #+BEGIN_SRC c
     if(event.bstate & BUTTON1_PRESSED)
       printw("Boton izquierdo presionado");
   #+END_SRC

# ** 12.3. Putting it all Together
** 12.3. Poniendo todo junto

   # That's pretty much interfacing with mouse. Let's create the same
   # menu and enable mouse interaction. To make things simpler, key
   # handling is removed.
   Esta es más o menos la interfaz con el ratón. Vamos a crear el
   mismo menú y permitir la interacción del ratón. Para hacer las
   cosas más simples, se elimina el manejo del teclado.

   # *Example 11. Access the menu with mouse !!!*
   [[file:ncurses_programs/basics/mouse_menu.c][*Ejemplo 11. Acceder al menú con el ratón !!!*]]

   #+BEGIN_SRC c
     #include <ncurses.h>
     #include <string.h>

     #define WIDTH  30
     #define HEIGHT 10

     int startx = 0;
     int starty = 0;

     char *choices[] = {     "Opcion 1",
                             "Opcion 2",
                             "Opcion 3",
                             "Opcion 4",
                             "Salir",
     };

     int n_choices = sizeof(choices) / sizeof(char *);

     void print_menu(WINDOW *menu_win, int highlight);
     void report_choice(int mouse_x, int mouse_y, int *p_choice);

     int main()
     { int c, choice = 0;
       WINDOW *menu_win;
       MEVENT event;

       /* Inicializa curses */
       initscr();
       clear();
       noecho();
       cbreak();   // Deshabilitar buffer de linea. Pasar todo

       /* Trata de poner la ventana al centro de la pantalla */
       startx = (80 -  WIDTH) / 2;
       starty = (24 - HEIGHT) / 2;

       attron(A_REVERSE);
       mvprintw(23, 1, "Click en Salir para terminar (Funciona mejor en una consola virtual)");
       refresh();
       attroff(A_REVERSE);

       /* Imprime el menu por primera vez */
       menu_win = newwin(HEIGHT, WIDTH, starty, startx);
       print_menu(menu_win, 1);
       /* necesitamos habilitar las teclas de "funcion",
          KEY_MOUSE forma parte de ellas */
       keypad( menu_win, TRUE );
       /* Optener todos los eventos del raton */
       mousemask(ALL_MOUSE_EVENTS, NULL);

       while(1)
         { c = wgetch(menu_win);
           switch(c)
             {   case KEY_MOUSE:
                 if(getmouse(&event) == OK)
                   { /* Cuando el usuario presiona el boton izquierdo del mouse */
                     if(event.bstate & BUTTON1_PRESSED)
                       { report_choice(event.x + 1, event.y + 1, &choice);
                         if(choice == -1) // Opcion de salida
                           goto end;
                         mvprintw(22, 1, "La opcion elegida : %d La cadena elegida es \"%10s\"", choice, choices[choice - 1]);
                         refresh();
                       }
                   }
                 print_menu(menu_win, choice);
                 break;
             }
         }
      end:
       endwin();
       return 0;
     }


     void print_menu(WINDOW *menu_win, int highlight)
     {
       int x, y, i;

       x = 2;
       y = 2;
       box(menu_win, 0, 0);
       for(i = 0; i < n_choices; ++i)
         { if(highlight == i + 1)
           { wattron(menu_win, A_REVERSE);
             mvwprintw(menu_win, y, x, "%s", choices[i]);
             wattroff(menu_win, A_REVERSE);
           }
           else
             mvwprintw(menu_win, y, x, "%s", choices[i]);
           ++y;
         }
       wrefresh(menu_win);
     }

     /* Informa la opcion de acuerdo a la posicion del mouse */
     void report_choice(int mouse_x, int mouse_y, int *p_choice)
     { int i,j, choice;

       i = startx + 2;
       j = starty + 2;

       for(choice = 0; choice < n_choices; ++choice)
         if(mouse_y == j + choice && mouse_x >= i &&
            mouse_x <= i + strlen(choices[choice]))
           { if(choice == n_choices - 1)
             *p_choice = -1;
             else
               *p_choice = choice + 1;
             break;
           }
     }
   #+END_SRC

# ** 12.4. Miscellaneous Functions
** 12.4. Funciones varias

   # The functions =mouse_trafo()= and =wmouse_trafo()= can be used to
   # convert to mouse co-ordinates to screen relative co-ordinates. See
   # =curs_mouse(3X)= man page for details.
   Puede utilizar las funciones =mouse_trafo()= y =wmouse_trafo()=
   para convertir las cordenadas del ratón en coordenadas relativas a
   la pantalla. Vea la pagina de manual [[file:man/curs_mouse.3x.org][=curs_mouse(3X)=]] para más
   detalles.

   # The mouseinterval function sets the maximum time (in thousands of a
   # second) that can elapse between press and release events in order
   # for them to be recognized as a click. This function returns the
   # previous interval value. The default is one fifth of a second.
   La función mouseinterval establece el tiempo máximo (en milesimas
   de segundo) que puede transcurrir entre eventos de presion y
   liberación para que puedan ser reconocidos como un clic. Esta
   función devuelve el valor del intervalo anterior. El valor
   predeterminado es una quinta parte de un segundo.

# * 13. Screen Manipulation
* 13. Manipulación de Pantalla

  # In this section, we will look into some functions, which allow us to
  # manage the screen efficiently and to write some fancy programs. This
  # is especially important in writing games.
  En esta sección, veremos algunas funciones, que nos permiten manejar
  la pantalla de manera eficiente para escribir algunos programas
  fantasticos. Esto es especialmente importante en la escritura de
  juegos.

# ** 13.1. getyx() functions
** 13.1. funciones =getyx()=

   # The function =getyx()= can be used to find out the present cursor
   # co-ordinates. It will fill the values of x and y co-ordinates in
   # the arguments given to it. Since getyx() is a macro you don't have
   # to pass the address of the variables. It can be called as
   La función =getyx()= se utiliza para descubrir las coordenadas
   actuales del cursor. Se colocaran las coordenadas de los valores
   =x= e =y= en los argumentos dados. Ya que =getyx()= es una macro no
   tiene que pasar la dirección de las variables. Se le puede llamar
   como

   #+BEGIN_SRC c
     getyx(win, y, x);
     /* win : puentero a ventana
      * y, x: se colocaran las coordenadas y, x en estas variables
      */
   #+END_SRC

   # The function getparyx() gets the beginning co-ordinates of the sub
   # window relative to the main window. This is some times useful to
   # update a sub window. When designing fancy stuff like writing
   # multiple menus, it becomes difficult to store the menu positions,
   # their first option co-ordinates etc. A simple solution to this
   # problem, is to create menus in sub windows and later find the
   # starting co-ordinates of the menus by using getparyx().
   La función =getparyx()= obtiene las coordenadas iniciales de la sub
   ventana con respecto a la ventana principal. Esto algunas veces es
   útil para actualizar una sub ventana. Cuando se diseñan cosas
   asombrosas como menús múltiples, debido a la dificultad de
   almacenar las posiciones del menú, las coordenadas de la opcion
   principal etc. Una solución simple a este problema, es la creación
   de menús en ventanas secundarias y luego localizar las coordenadas
   iniciales de los menús utilizando =getparyx()=.

   # The functions getbegyx() and getmaxyx() store current window's
   # beginning and maximum co-ordinates. These functions are useful in
   # the same way as above in managing the windows and sub windows
   # effectively.
   Las funciones =getbegyx()= y =getmaxyx()= almacenan el inicio y las
   coordenadas maximas de la ventana actual. Estas funciones son
   útiles de la misma manera que la anterior en el manejo eficaz de
   ventanas y sub ventanas.

# ** 13.2. Screen Dumping
** 13.2. Volcado de Pantalla

   # While writing games, some times it becomes necessary to store the
   # state of the screen and restore it back to the same state. The
   # function =scr_dump()= can be used to dump the screen contents to a
   # file given as an argument. Later it can be restored by
   # =scr_restore= function. These two simple functions can be used
   # effectively to maintain a fast moving game with changing scenarios.
   Cuando se escriben juegos, en ocaciones es necesario almacenar el
   estado de la pantalla y restaurarlo de nuevo al mismo estado. Puede
   utilizar la función =scr_dump()= para volcar los contenidos de la
   pantalla al archivo dado como argumento. Más tarde se puede
   restaurare con la función =scr_restore=. Con estas dos simples
   funciones pueden mantener el manejo eficiente en un juego de
   movimiento rapido con cambios de escenarios.

# ** 13.3. Window Dumping
** 13.3. Volcado de Ventana

   # To store and restore windows, the functions =putwin()= and
   # =getwin()= can be used. =putwin()= puts the present window state
   # into a file, which can be later restored by =getwin()=.
   Puede utilizar las funciones =putwin()= y =getwin()=, para guardar
   y restaurar ventanas. =putwin()= coloca el estado actual de la
   ventana en un archivo, que puede ser restaurado posteriormente por
   =getwin()=.

   # The function =copywin()= can be used to copy a window completely
   # onto another window. It takes the source and destination windows as
   # parameters and according to the rectangle specified, it copies the
   # rectangular region from source to destination window. It's last
   # parameter specifies whether to overwrite or just overlay the
   # contents on to the destination window. If this argument is true,
   # then the copying is non-destructive.
   Puede utilizar la función =copywin()= para copiar por completo una
   ventana en otra ventana. Toma las ventanas de origen y destino como
   parámetros y de acuerdo con el rectángulo especificado, copia la
   región rectangular desde la ventana origen hasta la ventana
   destino. El último parámetro especifica si desea sobrescribir o
   simplemente superponer el contenido en la ventana destino. Si este
   argumento es cierto, entonces la copia es no destructiva.

# * 14. Miscellaneous features
* 14. Características diversas

  # Now you know enough features to write a good curses program, ¤with
  # all bells and whistles. There are some miscellaneous functions which
  # are useful in various cases. Let's go headlong into some of those.
  Ahora ya conoces suficientes características para escribir un buen
  programa curses. Aqui estan algunas funciones auxiliares útiles en
  varios casos. Vamos a ir de cabeza a algunas de ellas.

# ** 14.1. =curs_set()=
** 14.1. =curs_set()=

   # This function can be used to make the cursor invisible. The
   # parameter to this function should be
   Puede utilizar esta función para hacer el cursor invisible. Los
   parámetros aceptados por esta funcion son.

   # #+BEGIN_EXAMPLE
   #   0 : invisible  or
   #   1 : normal     or
   #   2 : very visible.
   # #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     0 : invisible
     1 : normal
     2 : muy visible.
   #+END_EXAMPLE

# ** 14.2. Temporarily Leaving curses mode
** 14.2. Dejar Temporalmente el modo curses

   # Some times you may want to get back to ¤cooked mode (normal line
   # buffering mode) temporarily. In such a case you will first need to
   # save the tty modes with a call to =def_prog_mode()= and then call
   # =endwin()= to end the curses mode. This will leave you in the
   # original tty mode. To get back to curses once you are done, call
   # =reset_prog_mode()=. This function returns the tty to the state
   # stored by =def_prog_mode()=. Then do refresh(), and you are back to
   # the curses mode. Here is an example showing the sequence of things
   # to be done.
   En algunas ocaciones puede buscar volver temporalmente al cooked
   mode(modo normal de linea de buffer). En tal caso, primero tendrás
   que guardar los modos tty con una llamada a =def_prog_mode()= y
   luego llamar a =endwin()= para finalizar el modo de curses. Esto te
   dejará en el el modo tty original. Una vez que haya terminado,
   llamara a =reset_prog_mode()= para volver al modo curses. Esta
   función devuelve el tty al estado almacenada por =def_prog_mode()=.
   Luego de un =refreth()=, estára de vuelta en el modo de curses.  He
   aquí un ejemplo que muestra la secuencia de cosas por hacer.

   # *Example 12. Temporarily Leaving curses Mode*
   [[file:ncurses_programs/basics/temp_leave.c][*Ejemplo 12. Dejando Temporalmente el Modo curses*]]

   #+BEGIN_SRC c
     #include <ncurses.h>
     #include <stdlib.h>

     int main()
     {
       initscr();                      /* Iniciar el modo curses                 */
       printw("Hola mundo !!!\n");     /* Imprime Hola mundo                     */
       refresh();                      /* Imprimir en la pantalla real           */
       getch();                        /* Esperar                                */
       def_prog_mode();                /* Guardar los modos tty                  */
       endwin();                       /* Finalizar curnes temporalmente         */
       system("/bin/sh");              /* Realizar cualquier cosa en modo cooked */
       reset_prog_mode();              /* Regresar al modo tty previo            */
                                       /* almacenado por def_prog_mode()         */
       refresh();                      /* refresh() restaura los contenidos      */
                                       /* en pantalla                            */
       printw("Otra Cadena\n");        /* De nuevo utilizar curses al maximo     */
       refresh();                      /* de sus capacidades                     */
       getch();                        /* Esperar                                */
       endwin();                       /* Finalizar el modo curses               */

       return 0;
     }
   #+END_SRC

# ** 14.3. =ACS_= variables
** 14.3. Variables =ACS_=

   # If you have ever programmed in DOS, you know about those nifty
   # characters in extended character set. They are printable only on
   # some terminals. NCURSES functions like =box()= use these
   # characters. All these variables start with ACS meaning alternative
   # character set. You might have noticed me using these characters in
   # some of the programs above. Here's an example showing all the
   # characters.
   Si alguna vez has programado en DOS, debes conocer acerca de este
   ingenioso juego de caracteres extendidos. Estos son imprimibles
   sólo en algunos terminales. Las funciones como =box()= utilizan
   estos caracteres. Todas estas variables comienzan con *ACS*
   significando el conjunto de caracteres alternativo. Es posible que
   haya observado mi uso de estos caracteres en algunos de los
   programas anteriores. El siguiente ejemplo que muestra todos los
   caracteres.

   # *Example 13. ACS Variables Example*
   [[file:ncurses_programs/basics/acs_vars.c][*Ejemplo 13. Variables ACS*]]

   #+BEGIN_SRC c
     #include <ncurses.h>

     int main()
     {
       initscr();

       printw("Upper left corner           "); addch(ACS_ULCORNER ); printw("\n");
       printw("Lower left corner           "); addch(ACS_LLCORNER ); printw("\n");
       printw("Lower right corner          "); addch(ACS_LRCORNER ); printw("\n");
       printw("Tee pointing right          "); addch(ACS_LTEE     ); printw("\n");
       printw("Tee pointing left           "); addch(ACS_RTEE     ); printw("\n");
       printw("Tee pointing up             "); addch(ACS_BTEE     ); printw("\n");
       printw("Tee pointing down           "); addch(ACS_TTEE     ); printw("\n");
       printw("Horizontal line             "); addch(ACS_HLINE    ); printw("\n");
       printw("Vertical line               "); addch(ACS_VLINE    ); printw("\n");
       printw("Large Plus or cross over    "); addch(ACS_PLUS     ); printw("\n");
       printw("Scan Line 1                 "); addch(ACS_S1       ); printw("\n");
       printw("Scan Line 3                 "); addch(ACS_S3       ); printw("\n");
       printw("Scan Line 7                 "); addch(ACS_S7       ); printw("\n");
       printw("Scan Line 9                 "); addch(ACS_S9       ); printw("\n");
       printw("Diamond                     "); addch(ACS_DIAMOND  ); printw("\n");
       printw("Checker board (stipple)     "); addch(ACS_CKBOARD  ); printw("\n");
       printw("Degree Symbol               "); addch(ACS_DEGREE   ); printw("\n");
       printw("Plus/Minus Symbol           "); addch(ACS_PLMINUS  ); printw("\n");
       printw("Bullet                      "); addch(ACS_BULLET   ); printw("\n");
       printw("Arrow Pointing Left         "); addch(ACS_LARROW   ); printw("\n");
       printw("Arrow Pointing Right        "); addch(ACS_RARROW   ); printw("\n");
       printw("Arrow Pointing Down         "); addch(ACS_DARROW   ); printw("\n");
       printw("Arrow Pointing Up           "); addch(ACS_UARROW   ); printw("\n");
       printw("Board of squares            "); addch(ACS_BOARD    ); printw("\n");
       printw("Lantern Symbol              "); addch(ACS_LANTERN  ); printw("\n");
       printw("Solid Square Block          "); addch(ACS_BLOCK    ); printw("\n");
       printw("Less/Equal sign             "); addch(ACS_LEQUAL   ); printw("\n");
       printw("Greater/Equal sign          "); addch(ACS_GEQUAL   ); printw("\n");
       printw("Pi                          "); addch(ACS_PI       ); printw("\n");
       printw("Not equal                   "); addch(ACS_NEQUAL   ); printw("\n");
       printw("UK pound sign               "); addch(ACS_STERLING ); printw("\n");

       refresh();
       getch();
       endwin();

       return 0;
     }
   #+END_SRC

# * 15. Other libraries
* 15. Otras librerias

  # Apart from the curses library, there are few text mode libraries,
  # which provide more functionality and a lot of features. The
  # following sections explain three standard libraries which are
  # usually distributed along with curses.
  Además de la libreria curses, hay algunas librerias en modo texto,
  que proporcionan una mayor funcionalidad y un montón de
  características. Las siguientes secciones describen tres librerias
  estándar que normalmente se distribullen junto a curses.

# * 16. Panel Library
* 16. Libreria Panel

  # Now that you are proficient in curses, you wanted to do some thing
  # big.  You created a lot of overlapping windows to give a
  # professional windows-type look. Unfortunately, it soon becomes
  # difficult to manage these. The multiple refreshes, updates plunge
  # you into a nightmare. The overlapping windows create blotches,
  # whenever you forget to refresh the windows in the proper order.
  Ahora que eres competente en curses, buscaras hacer algo grande.
  Como crear una gran cantidad de ventanas superpuestas para dar un
  aspecto profesional tipo ventana. Por desgracia, esto se hace
  dificil de manejar en poco tiempo. Las actualizaciones múltiples, te
  sumergiran en una pesadilla. Las ventanas superpuestas generan
  manchas, cada vez que olvida actualizar las ventanas en el orden
  correcto.

  # Don't despair. There's an elegant solution provided in panels
  # library.  In the words of developers of ncurses
  No caiga en la desesperacion. Hay una solución elegante
  proporcionada en la libreria Parel. En palabras de los
  desarrolladores de ncurses

  # #+BEGIN_ITALIC
  #   When your interface design is such that windows may dive deeper
  #   into the visibility stack or pop to the top at runtime, the
  #   resulting ¤book-keeping can be tedious and difficult to get
  #   right. Hence the panels library.
  # #+END_ITALIC

  #+BEGIN_ITALIC
    Cuando el diseño de su interfaz es tal que las ventanas pueden
    sumergirse más profundamente en la pila de visibilidad o saltar a
    la cima en tiempo de ejecución, puede ser tedioso y difícil
    mantener un resultado de forma correcta. Para eso esta la librería
    panel.
  #+END_ITALIC

  # If you have lot of overlapping windows, then panels library is the
  # way to go. It obviates the need of doing series of wnoutrefresh(),
  # doupdate() and relieves the burden of doing it correctly(bottom
  # up). The library maintains information about the order of windows,
  # their overlapping and update the screen properly. So why wait? Let's
  # take a close peek into panels.
  Si tiene muchas ventanas superpuestas, la libreria panel es el
  camino a seguir. Es obvia la necesidad de realizar una serie de
  =wnoutrefresh()=, =doupdate()= y aliviar la carga de hacerlo
  correctamente (abajo arriba). La libreria mantiene información sobre
  el orden de las ventanas, su superposición y en consecuencia
  actualiza la pantalla correctamente. Así que ¿por qué esperar?
  Echemos un vistazo de cerca a los paneles.

# ** 16.1. The Basics
** 16.1. Lo basico

   # Panel object is a window that is implicitly treated as part of a
   # deck including all other panel objects. The deck is treated as a
   # stack with the top panel being completely visible and the other
   # panels may or may not be obscured according to their positions. So
   # the basic idea is to create a stack of overlapping panels and use
   # panels library to display them correctly. There is a function
   # similar to refresh() which, when called , displays panels in the
   # correct order. Functions are provided to hide or show panels, move
   # panels, change its size etc.. The overlapping problem is managed by
   # the panels library during all the calls to these functions.
   Un objeto panel es una ventana que se trata implícitamente como
   parte de una baraja incluyendo a todos los otros objetos panel. La
   baraja se trata como una pila con un panel superior que es
   completamente visible y los otros paneles pueden o no ser
   oscurecidos respecto a sus posiciones. Asi que La idea básica es
   crear una pila de paneles superpuestos y utilizal la libreria panel
   para desplegarlos correctamente. Hay una función similar a
   =refresh()= que, cuando es llamada, despliega los paneles en el
   orden correcto. Se proporcionan funciones para ocultar o mostrar
   paneles, mover paneles, cambiar su tamaño, etc.. El problema de
   superposicion es gestionado por la libreria panel durante todas las
   llamadas a estas funciones.

   # The general flow of a panel program goes like this:
   El flujo general de un programa panel es el siguiente:

   # 1. Create the windows (with newwin()) to be attached to the panels.
   1. Crear las ventanas (con =newwin()=) que seran ligadas a paneles.

   # 2. Create panels with the chosen visibility order. Stack them up
   #    according to the desired visibility. The function =new_panel()=
   #    is used to created panels.
   2. Cree paneles con el ordend de visibilidad elegido. Apilarlos de
      acuerdo con la visibilidad deseada. La función =new_panel()= se
      utiliza para crear paneles.

   # 3. Call =update_panels()= to write the panels to the virtual screen
   #    in correct visibility order. Do a doupdate() to show it on the
   #    screen.
   3. Llame a =update_panels()= para escribir los paneles en la
      pantalla virtual en el orden correcto de visibilidad. llame a
      =doupdate()= para mostrarlo en pantalla.

   # 4. Mainpulate the panels with =show_panel()=, =hide_panel()=,
   #    =move_panel()= etc. Make use of helper functions like
   #    =panel_hidden()= and =panel_window()=. Make use of user pointer
   #    to store custom data for a panel. Use the functions
   #    =set_panel_userptr()= and =panel_userptr()= to set and get the
   #    user pointer for a panel.
   4. Manipule los paneles con =show_panel()=, =hide_panel()=,
      =move_panel()= etc. Haga uso de funciones auxiliares como
      =panel_hidden()= y =panel_window()=. Haga uso del puntero de
      usuario para almacenar datos personalizados para un
      panel. Utilice las funciones =set_panel_userptr()= y
      =panel_userptr()= para establecer y obtener el puntero de
      usuario de un panel.

   # 5. When you are done with the panel use =del_panel()= to delete the
   #    panel.
   5. Cuando haya terminado de utilizar el panel llame a =del_panel()=
      para eliminar el panel.


   # Let's make the concepts clear, with some programs. The following is
   # a simple program which creates 3 overlapping panels and shows them
   # on the screen.

   Hagamos los conceptos claros, con algunos programas. El siguiente
   es un sencillo programa que crea 3 paneles superpuestos y les
   muestra en la pantalla.

# ** 16.2. Compiling With the Panels Library
** 16.2. Compilación con la Librería Panel

   # To use panels library functions, you have to include panel.h and to
   # link the program with panels library the flag =-lpanel= should be
   # added along with =-lncurses= in that order.
   Para utilizar las funciones de la libreria panel, tiene que incluir
   =panel.h= y vincular el programa a la dicha libreria con la bandera
   =-lpanel= junto con =-lncurses= en ese orden.

   #+BEGIN_EXAMPLE
     #include <panel.h>
     .
     .
     .

     compilacion y enlace: gcc <fichero del programa> -lpanel -lncurses
   #+END_EXAMPLE

   # *Example 14. Panel basics*
   [[file:ncurses_programs/panels/panel_simple.c][*Ejemplo 14. Panel conceptos basicos*]]

   #+BEGIN_SRC c
     #include <panel.h>

     int main()
     { WINDOW *my_wins[3];
       PANEL  *my_panels[3];
       int lines = 10, cols = 40, y = 2, x = 4, i;

       initscr();
       cbreak();
       noecho();

       /* Creacion de ventanas para los paneles */
       my_wins[0] = newwin(lines, cols, y, x);
       my_wins[1] = newwin(lines, cols, y + 1, x + 5);
       my_wins[2] = newwin(lines, cols, y + 2, x + 10);

       /*
        * Creacion de bordes alrededor de las ventanas para ver el efecto
        * de los paneles
        */
       for(i = 0; i < 3; ++i)
         box(my_wins[i], 0, 0);

       /* Unir un panel a cada ventana */      /* ordenar de abajo hacia arriba  */
       my_panels[0] = new_panel(my_wins[0]);   /* agregar 0, orden: stdscr-0     */
       my_panels[1] = new_panel(my_wins[1]);   /* agregar 1, orden: stdscr-0-1   */
       my_panels[2] = new_panel(my_wins[2]);   /* agregar 2, orden: stdscr-0-1-2 */

       /* Actualizar en orden de apilamiento. El 2nd panel estara en la cima     */
       update_panels();

       /* Mostrar en la pantalla */
       doupdate();

       getch();
       endwin();
     }
   #+END_SRC

   # As you can see, above program follows a simple flow as
   # explained. The windows are created with newwin() and then they are
   # attached to panels with =new_panel()=. As we attach one panel after
   # another, the stack of panels gets updated. To put them on screen
   # =update_panels()= and doupdate() are called.
   Como se puede ver, el programa anterior sigue un flujo simple. Las
   ventanas se crean con =newwin()= y luego son unidas a paneles con
   =new_panel()=. La pila de paneles se actualiza, a medida que
   agregamos un panel después otro. Para mostrarlos en pantalla
   llamamos a =update_panels()= y =doupdate()=.

# ** 16.3. Panel Window Browsing
** 16.3. Navegacion en Paneles de Ventana

   # A slightly complicated example is given below. This program creates
   # 3 windows which can be cycled through using tab. Have a look at the
   # code.
   El siguiente es un ejemplo un poco complicado. Este programa crea 3
   ventanas que se puede rotar ciclicamente mediante el uso de /tab/.
   Echa un vistazo al código.

   # *Example 15. Panel Window Browsing Example*
   [[file:ncurses_programs/panels/panel_browse.c][*Ejemplo 15. Navegacion en Paneles de Ventana*]]

   #+BEGIN_SRC c
     #include <panel.h>
     #include <string.h>

     #define NLINES 10
     #define NCOLS 40

     void init_wins(WINDOW **wins, int n);
     void win_show(WINDOW *win, char *label, int label_color);
     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

     int main()
     { WINDOW *my_wins[3];
       PANEL  *my_panels[3];
       PANEL  *top;
       int ch;

       /* Inicializa curses */
       initscr();
       start_color();
       cbreak();
       noecho();
       keypad(stdscr, TRUE);

       /* Inicializa todos los colores */
       init_pair(1, COLOR_RED,   COLOR_BLACK);
       init_pair(2, COLOR_GREEN, COLOR_BLACK);
       init_pair(3, COLOR_BLUE,  COLOR_BLACK);
       init_pair(4, COLOR_CYAN,  COLOR_BLACK);

       init_wins(my_wins, 3);

       /* Unir un panel a cada ventana */      /* Ordenar de abajo hacia arriba  */
       my_panels[0] = new_panel(my_wins[0]);   /* Agregar 0, orden: stdscr-0     */
       my_panels[1] = new_panel(my_wins[1]);   /* Agregar 1, orden: stdscr-0-1   */
       my_panels[2] = new_panel(my_wins[2]);   /* Agregar 2, orden: stdscr-0-1-2 */

       /* Crear el puntero de usuario al siguiente panel */
       set_panel_userptr(my_panels[0], my_panels[1]);
       set_panel_userptr(my_panels[1], my_panels[2]);
       set_panel_userptr(my_panels[2], my_panels[0]);

       /* Actualizar el orden de apilamiento. El 2nd panel estara en la parte superior */
       update_panels();

       /* Mostrar en la pantalla */
       attron(COLOR_PAIR(4));
       mvprintw(LINES - 2, 0, "Utilice tab para navegar a traves de las ventanas (F1 para Salir)");
       attroff(COLOR_PAIR(4));
       doupdate();

       top = my_panels[2];
       while((ch = getch()) != KEY_F(1))
         {   switch(ch)
             {   case 9:
                 top = (PANEL *)panel_userptr(top);
                 top_panel(top);
                 break;
             }
           update_panels();
           doupdate();
         }
       endwin();
       return 0;
     }

     /* Coloca todas las ventanas */
     void init_wins(WINDOW **wins, int n)
     { int x, y, i;
       char label[80];

       y = 2;
       x = 10;
       for(i = 0; i < n; ++i)
         { wins[i] = newwin(NLINES, NCOLS, y, x);
           sprintf(label, "Ventana Numero %d", i + 1);
           win_show(wins[i], label, i + 1);
           y += 3;
           x += 7;
         }
     }

     /* Muestra la ventana con un borde y una etiqueta */
     void win_show(WINDOW *win, char *label, int label_color)
     { int startx, starty, height, width;

       getbegyx(win, starty, startx);
       getmaxyx(win, height, width);

       box(win, 0, 0);
       mvwaddch(win, 2, 0, ACS_LTEE);
       mvwhline(win, 2, 1, ACS_HLINE, width - 2);
       mvwaddch(win, 2, width - 1, ACS_RTEE);

       print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
     }

     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
     { int length, x, y;
       float temp;

       if(win == NULL)
         win = stdscr;
       getyx(win, y, x);
       if(startx != 0)
         x = startx;
       if(starty != 0)
         y = starty;
       if(width == 0)
         width = 80;

       length = strlen(string);
       temp = (width - length)/ 2;
       x = startx + (int)temp;
       wattron(win, color);
       mvwprintw(win, y, x, "%s", string);
       wattroff(win, color);
       refresh();
     }
   #+END_SRC

# ** 16.4. Using User Pointers
** 16.4. Utilizando punteros de usuario

   # In the above example I used user pointers to find out the next
   # window in the cycle. We can attach custom information to the panel
   # by specifying a user pointer, which can point to any information
   # you want to store. In this case I stored the pointer to the next
   # panel in the cycle. User pointer for a panel can be set with the
   # function =set_panel_userptr()=.  It can be accessed using the
   # function =panel_userptr()= which will return the user pointer for
   # the panel given as argument. After finding the next panel in the
   # cycle It's brought to the top by the function =top_panel()=. This
   # function brings the panel given as argument to the top of the panel
   # stack.
   En el ejemplo anterior utilice punteros de usuario para obtener la
   siguiente ventana en el ciclo. Podemos vincular información
   personalizada al panel especificando un puntero de usuario, que
   puede apuntar a cualquier información desea almacenar. En este caso
   guardé el puntero al siguiente panel en el ciclo. El puntero de
   usuario de un panel se puede establecer con la función
   =set_panel_userptr()=. Se puede acceder a dicha informacion
   mediante la función =panel_userptr()= que devolverá el puntero de
   usuario de el panel dado como argumento. Después localizar el
   siguiente panel en el ciclo se establece en la cima con la función
   =top_panel()=. Esta función trae a el panel dado como argumento a
   la parte superior de la pila de paneles.

# ** 16.5. Moving and Resizing Panels
** 16.5. Mover y Redimensionar Paneles

   # The function =move_panel()= can be used to move a panel to the
   # desired location. It does not change the position of the panel in
   # the stack.  Make sure that you use =move_panel()= instead mvwin()
   # on the window associated with the panel.
   Puede utilizar la función =move_panel()= para mover un panel a la
   posicion deseada. Esto no cambia la posición del panel en la
   pila. Asegúrese utilizar =move_panel()= en lugar de =mvwin()= en la
   ventana asociada a el panel.

   # Resizing a panel is slightly complex. There is no straight forward
   # function just to resize the window associated with a panel. A
   # solution to resize a panel is to create a new window with the
   # desired sizes, change the window associated with the panel using
   # =replace_panel()=.  Don't forget to delete the old window. The
   # window associated with a panel can be found by using the function
   # =panel_window()=.
   Cambiar el tamaño de un panel es ligeramente complejo. No hay una
   función directa para cambiar el tamaño de la ventana asociada a un
   un panel. Una solución para cambiar el tamaño de un panel es crear
   una nueva ventana con el tamaño deseado, cambie la ventana asociada
   a el panel utilizando =replace_panel()=. No olvides borrar la
   ventana anterior. Puede obtener la ventana asociada con un panel
   mediante el uso de la función =panel_window()=.

   # The following program shows these concepts, in supposedly simple
   # program. You can cycle through the window with <TAB> as usual. To
   # resize or move the active panel press 'r' for resize 'm' for
   # moving. Then use arrow keys to resize or move it to the desired way
   # and press enter to end your resizing or moving. This example makes
   # use of user data to get the required data to do the operations.
   El siguiente programa muestra estos conceptos, en suposicion es un
   programa sencillo. Como es costumbre, puede rotar entre ventanas
   con <TAB>. Para cambiar el tamaño o mover el panel activo presione
   "r" por "resize", 'm' para mover. A continuación, utilice las
   teclas de flecha para cambiar el tamaño o mover a la forma deseada
   y pulse enter para terminar el cambio. En ejemplo hace uso de los
   datos del usuario para obtener los datos necesarios para hacer las
   operaciones.

   # *Example 16. Panel Moving and Resizing example*
   [[file:ncurses_programs/panels/panel_resize.c][*Ejemplo 16. Mover y Redimencionar un Panel*]]

   #+BEGIN_SRC c
     #include <panel.h>
     #include <stdlib.h>
     #include <string.h>

     typedef struct _PANEL_DATA {
       int x, y, w, h;
       char label[80];
       int label_color;
       PANEL *next;
     } PANEL_DATA;

     #define NLINES 10
     #define NCOLS 40

     void init_wins(WINDOW **wins, int n);
     void win_show(WINDOW *win, char *label, int label_color);
     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);
     void set_user_ptrs(PANEL **panels, int n);

     int main()
     { WINDOW *my_wins[3];
       PANEL  *my_panels[3];
       PANEL_DATA  *top;
       PANEL *stack_top;
       WINDOW *temp_win, *old_win;
       int ch;
       int newx, newy, neww, newh;
       int size = FALSE, move = FALSE;

       /* Inicializar curses */
       initscr();
       start_color();
       cbreak();
       noecho();
       keypad(stdscr, TRUE);

       /* Inicializar todos los colores */
       init_pair(1, COLOR_RED, COLOR_BLACK);
       init_pair(2, COLOR_GREEN, COLOR_BLACK);
       init_pair(3, COLOR_BLUE, COLOR_BLACK);
       init_pair(4, COLOR_CYAN, COLOR_BLACK);

       init_wins(my_wins, 3);

       /* Unir un panel a cada ventana */      /* Ordenar de abajo hacia arriba  */
       my_panels[0] = new_panel(my_wins[0]);   /* Agregar 0, orden: stdscr-0     */
       my_panels[1] = new_panel(my_wins[1]);   /* Agregar 1, orden: stdscr-0-1   */
       my_panels[2] = new_panel(my_wins[2]);   /* Agregar 2, orden: stdscr-0-1-2 */

       set_user_ptrs(my_panels, 3);

       /* Actualizar el orden de apilamiento. El 2nd panel estara en la parte superior */
       update_panels();

       /* Mostrar en la pantalla */
       attron(COLOR_PAIR(4));
       mvprintw(LINES - 3, 0, "Use 'm' para mover, 'r' para redimencionar");
       mvprintw(LINES - 2, 0, "Use tab para navegar a traves de las ventanas (F1 para Salir)");
       attroff(COLOR_PAIR(4));
       doupdate();

       stack_top = my_panels[2];
       top = (PANEL_DATA *)panel_userptr(stack_top);
       newx = top->x;
       newy = top->y;
       neww = top->w;
       newh = top->h;
       while((ch = getch()) != KEY_F(1))
         {   switch(ch)
             {   case 9:     /* Tab */
                 top = (PANEL_DATA *)panel_userptr(stack_top);
                 top_panel(top->next);
                 stack_top = top->next;
                 top = (PANEL_DATA *)panel_userptr(stack_top);
                 newx = top->x;
                 newy = top->y;
                 neww = top->w;
                 newh = top->h;
                 break;
             case 'r':   /* Redimencion */
               size = TRUE;
               attron(COLOR_PAIR(4));
               mvprintw(LINES - 4, 0, "Ingrese dimencion: Use las teclas de flecha y pulse <ENTER> para redimencionar");
               refresh();
               attroff(COLOR_PAIR(4));
               break;
             case 'm':   /* Movimiento  */
               attron(COLOR_PAIR(4));
               mvprintw(LINES - 4, 0, "Ingrese movimiento: Use las teclas de flecha y pulse <ENTER> para mover");
               refresh();
               attroff(COLOR_PAIR(4));
               move = TRUE;
               break;
             case KEY_LEFT:
               if(size == TRUE)
                 { --newx;
                   ++neww;
                 }
               if(move == TRUE)
                 --newx;
               break;
             case KEY_RIGHT:
               if(size == TRUE)
                 { ++newx;
                   --neww;
                 }
               if(move == TRUE)
                 ++newx;
               break;
             case KEY_UP:
               if(size == TRUE)
                 { --newy;
                   ++newh;
                 }
               if(move == TRUE)
                 --newy;
               break;
             case KEY_DOWN:
               if(size == TRUE)
                 { ++newy;
                   --newh;
                 }
               if(move == TRUE)
                 ++newy;
               break;
             case 10:    /* Enter */
               move(LINES - 4, 0);
               clrtoeol();
               refresh();
               if(size == TRUE)
                 { old_win = panel_window(stack_top);
                   temp_win = newwin(newh, neww, newy, newx);
                   replace_panel(stack_top, temp_win);
                   win_show(temp_win, top->label, top->label_color);
                   delwin(old_win);
                   size = FALSE;
                 }
               if(move == TRUE)
                 { move_panel(stack_top, newy, newx);
                   move = FALSE;
                 }
               break;

             }
           attron(COLOR_PAIR(4));
           mvprintw(LINES - 3, 0, "Use 'm' para mover, 'r' para redimencionar");
           mvprintw(LINES - 2, 0, "Use tab para navegar a traves de las ventanas (F1 para Salir)");
           attroff(COLOR_PAIR(4));
           refresh();
           update_panels();
           doupdate();
         }
       endwin();
       return 0;
     }

     /* Colocar todas las ventanas */
     void init_wins(WINDOW **wins, int n)
     { int x, y, i;
       char label[80];

       y = 2;
       x = 10;
       for(i = 0; i < n; ++i)
         { wins[i] = newwin(NLINES, NCOLS, y, x);
           sprintf(label, "Ventana Numero %d", i + 1);
           win_show(wins[i], label, i + 1);
           y += 3;
           x += 7;
         }
     }

     /* Establece la estructura PANEL_DATA para paneneles individualmente */
     void set_user_ptrs(PANEL **panels, int n)
     { PANEL_DATA *ptrs;
       WINDOW *win;
       int x, y, w, h, i;
       char temp[80];

       ptrs = (PANEL_DATA *)calloc(n, sizeof(PANEL_DATA));

       for(i = 0;i < n; ++i)
         { win = panel_window(panels[i]);
           getbegyx(win, y, x);
           getmaxyx(win, h, w);
           ptrs[i].x = x;
           ptrs[i].y = y;
           ptrs[i].w = w;
           ptrs[i].h = h;
           sprintf(temp, "Ventana numero %d", i + 1);
           strcpy(ptrs[i].label, temp);
           ptrs[i].label_color = i + 1;
           if(i + 1 == n)
             ptrs[i].next = panels[0];
           else
             ptrs[i].next = panels[i + 1];
           set_panel_userptr(panels[i], &ptrs[i]);
         }
     }

     /* Muestra la ventana con un borde y una etiqueta */
     void win_show(WINDOW *win, char *label, int label_color)
     { int startx, starty, height, width;

       getbegyx(win, starty, startx);
       getmaxyx(win, height, width);

       box(win, 0, 0);
       mvwaddch(win, 2, 0, ACS_LTEE);
       mvwhline(win, 2, 1, ACS_HLINE, width - 2);
       mvwaddch(win, 2, width - 1, ACS_RTEE);

       print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
     }

     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
     { int length, x, y;
       float temp;

       if(win == NULL)
         win = stdscr;
       getyx(win, y, x);
       if(startx != 0)
         x = startx;
       if(starty != 0)
         y = starty;
       if(width == 0)
         width = 80;

       length = strlen(string);
       temp = (width - length)/ 2;
       x = startx + (int)temp;
       wattron(win, color);
       mvwprintw(win, y, x, "%s", string);
       wattroff(win, color);
       refresh();
     }
   #+END_SRC

   # Concentrate on the main while loop. Once it finds out the type of
   # key pressed, it takes appropriate action. If 'r' is pressed
   # resizing mode is started. After this the new sizes are updated as
   # the user presses the arrow keys. When the user presses <ENTER>
   # present selection ends and panel is resized by using the concept
   # explained. While in resizing mode the program doesn't show how the
   # window is getting resized. It's left as an exercise to the reader
   # to print a dotted border while it gets resized to a new position.
   Concéntrese en el bucle =while= principal. Una vez que se descubre
   que tecla se ha pulsado, se toma la accion correspondiente. Si se
   presiona 'r' se inicia el modo de tamaño. Después de esto, los
   nuevos tamaños se actualizan a medida que el usuario presiona las
   teclas de flecha. Cuando el usuario pulsa <ENTER> termina la
   presente selección y el panel cambia de tamaño utilizando el
   concepto explicado anteriormente. Dentro del modo de tamaño el
   programa no muestra cómo se redimensiona la ventana. Se deja como
   ejercicio para el lector imprimir un borde de puntos mientras se
   cambia el tamaño a una nueva posición.

   # When the user presses 'm' the move mode starts. This is a bit
   # simpler than resizing. As the arrow keys are pressed the new
   # position is updated and pressing of <ENTER> causes the panel to be
   # moved by calling the function =move_panel()=.
   Cuando el usuario presiona 'm' inicia el modo de movimiento. Esto
   es un poco más simple que el cambio de tamaño. Cuando pulsa las
   teclas de flecha se actualiza la nueva posición y al presionar
   <ENTER> el panel es movido llamando a la función =move_panel()=.

   # In this program the user data which is represented as =PANEL_DATA=,
   # plays very important role in finding the associated information
   # with a panel.  As written in the comments, the =PANEL_DATA= stores
   # the panel sizes, label, label color and a pointer to the next panel
   # in the cycle.
   En este programa los datos de usuario representados como
   =PANEL_DATA=, juega papel muy importante en la búsqueda de la
   información asociada a un panel. Como está escrito en los
   comentarios, =PANEL_DATA= almacena el tamaño del panel, la
   etiqueta, color de la etiqueta y un puntero al siguiente panel en
   el ciclo.

# ** 16.6. Hiding and Showing Panels
** 16.6. Ocultar y Mostrar Paneles

   # A Panel can be hidden by using the function =hide_panel()=. This
   # function merely removes it form the stack of panels, thus hiding it
   # on the screen once you do =update_panels()= and doupdate(). It
   # doesn't destroy the PANEL structure associated with the hidden
   # panel. It can be shown again by using the =show_panel()= function.
   Un panel se puede ocultar mediante el uso de la función
   =hide_panel()=. Esta función simplemente lo quita de la pila de
   paneles, de esta forma lo oculta en pantalla cuando llama a
   =update_panels()= y =doupdate()=. Esto no destruye la estructura
   =PANEL= asociada con el panel oculto. Puede mostrar nuevamente el
   panel utilizando la funcion =show_panel()=.

   # The following program shows the hiding of panels. Press 'a' or 'b'
   # or 'c' to show or hide first, second and third windows
   # respectively. It uses a user data with a small variable hide, which
   # keeps track of whether the window is hidden or not. For some reason
   # the function =panel_hidden()= which tells whether a panel is hidden
   # or not is not working. A bug report was also presented by Michael
   # Andres [[http://www.geocrawler.com/archives/3/344/1999/9/0/2643549/][here]]
   El siguiente programa muestra como ocultar paneles. Pulse 'a' o 'b'
   o 'c' para mostrar u ocultar la primera, segunda y tercera ventana
   respectivamente. Se utilizan los datos de usuario con la pequeña
   variable =hide=, que realiza un seguimiento de si la ventana está
   oculta o no. Por alguna razón la función =panel_hidden()= que
   indica si un panel está oculto o no, no está funcionando. Un
   informe de error fue también presentado por Michael Andres [[http://www.geocrawler.com/archives/3/344/1999/9/0/2643549/][aqui]]

   # *Example 17. Panel Hiding and Showing example*
   [[file:ncurses_programs/panels/panel_hide.c][*Ejemplo 17. Ocultar y Mostrar Paneles*]]

   #+BEGIN_SRC c
     #include <panel.h>
     #include <string.h>

     typedef struct _PANEL_DATA {
       int hide;   /* TRUE si el panel esta oculto */
     }PANEL_DATA;

     #define NLINES 10
     #define NCOLS 40

     void init_wins(WINDOW **wins, int n);
     void win_show(WINDOW *win, char *label, int label_color);
     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

     int main()
     { WINDOW *my_wins[3];
       PANEL  *my_panels[3];
       PANEL_DATA panel_datas[3];
       PANEL_DATA *temp;
       int ch;

       /* Inicializar curses */
       initscr();
       start_color();
       cbreak();
       noecho();
       keypad(stdscr, TRUE);

       /* Inicializar todos los colores */
       init_pair(1, COLOR_RED, COLOR_BLACK);
       init_pair(2, COLOR_GREEN, COLOR_BLACK);
       init_pair(3, COLOR_BLUE, COLOR_BLACK);
       init_pair(4, COLOR_CYAN, COLOR_BLACK);

       init_wins(my_wins, 3);

       /* Unir un panel a cada ventana */      /* Ordenar de abajo hacia arriba  */
       my_panels[0] = new_panel(my_wins[0]);   /* Agregar 0, orden: stdscr-0     */
       my_panels[1] = new_panel(my_wins[1]);   /* Agregar 1, orden: stdscr-0-1   */
       my_panels[2] = new_panel(my_wins[2]);   /* Agregar 2, orden: stdscr-0-1-2 */

       /* Inicializa datos de panel diciendo que no hay nada oculto */
       panel_datas[0].hide = FALSE;
       panel_datas[1].hide = FALSE;
       panel_datas[2].hide = FALSE;

       set_panel_userptr(my_panels[0], &panel_datas[0]);
       set_panel_userptr(my_panels[1], &panel_datas[1]);
       set_panel_userptr(my_panels[2], &panel_datas[2]);

       /* Actualizar el orden de apilamiento. El 2nd panel estara en la parte superior */
       update_panels();

       /* Mostrar en la pantalla */
       attron(COLOR_PAIR(4));
       mvprintw(LINES - 3, 0, "Mostrar u ocultar una ventana con 'a'(primer ventana)  'b'(segunda ventana)  'c'(tercer ventana)");
       mvprintw(LINES - 1, 0, "F1 para salir");

       attroff(COLOR_PAIR(4));
       doupdate();

       while((ch = getch()) != KEY_F(1))
         {   switch(ch)
             {   case 'a':
                 temp = (PANEL_DATA *)panel_userptr(my_panels[0]);
                 if(temp->hide == FALSE)
                   { hide_panel(my_panels[0]);
                     temp->hide = TRUE;
                   }
                 else
                   { show_panel(my_panels[0]);
                     temp->hide = FALSE;
                   }
                 break;
             case 'b':
               temp = (PANEL_DATA *)panel_userptr(my_panels[1]);
               if(temp->hide == FALSE)
                 { hide_panel(my_panels[1]);
                   temp->hide = TRUE;
                 }
               else
                 { show_panel(my_panels[1]);
                   temp->hide = FALSE;
                 }
               break;
             case 'c':
               temp = (PANEL_DATA *)panel_userptr(my_panels[2]);
               if(temp->hide == FALSE)
                 { hide_panel(my_panels[2]);
                   temp->hide = TRUE;
                 }
               else
                 {   show_panel(my_panels[2]);
                   temp->hide = FALSE;
                 }
               break;
             }
           update_panels();
           doupdate();
         }
       endwin();
       return 0;
     }

     /* Colocar todas las ventanas */
     void init_wins(WINDOW **wins, int n)
     { int x, y, i;
       char label[80];

       y = 2;
       x = 10;
       for(i = 0; i < n; ++i)
         { wins[i] = newwin(NLINES, NCOLS, y, x);
           sprintf(label, "Ventana Numero %d", i + 1);
           win_show(wins[i], label, i + 1);
           y += 3;
           x += 7;
         }
     }

     /* Muestra la ventana con un borde y una etiqueta */
     void win_show(WINDOW *win, char *label, int label_color)
     { int startx, starty, height, width;

       getbegyx(win, starty, startx);
       getmaxyx(win, height, width);

       box(win, 0, 0);
       mvwaddch(win, 2, 0, ACS_LTEE);
       mvwhline(win, 2, 1, ACS_HLINE, width - 2);
       mvwaddch(win, 2, width - 1, ACS_RTEE);

       print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
     }

     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
     { int length, x, y;
       float temp;

       if(win == NULL)
         win = stdscr;
       getyx(win, y, x);
       if(startx != 0)
         x = startx;
       if(starty != 0)
         y = starty;
       if(width == 0)
         width = 80;

       length = strlen(string);
       temp = (width - length)/ 2;
       x = startx + (int)temp;
       wattron(win, color);
       mvwprintw(win, y, x, "%s", string);
       wattroff(win, color);
       refresh();
     }
   #+END_SRC

# ** 16.7. =panel_above()= and =panel_below()= Functions
** 16.7. Funciones =panel_above()= y =panel_below()=

   # The functions =panel_above()= and =panel_below()= can be used to
   # find out the panel above and below a panel. If the argument to
   # these functions is NULL, then they return a pointer to bottom panel
   # and top panel respectively.
   Puede utilizar las funciones =panel_above()= y =panel_below()= para
   averiguar el panel superiar e inferiar a un panel. Si el argumento
   de estas funciones es =NULL=, devuelven un puntero al panel
   inferior y superior, respectivamente.

# * 17. Menus Library
* 17. Libreria Menu

  # The menus library provides a nice extension to basic curses, through
  # which you can create menus. It provides a set of functions to create
  # menus. But they have to be customized to give a nicer look, with
  # colors etc. Let's get into the details.
  La libreria menu proporciona una buena extensión al curses básico, a
  través de esta se pueden crear menús. Proporciona un conjunto de
  funciones para crear menús. Pero tiene que personalizarce para dar
  un aspecto más agradable, con colores etc. Entremos a los detalles.

  # A menu is a screen display that assists the user to choose some
  # subset of a given set of items. To put it simple, a menu is a
  # collection of items from which one or more items can be chosen. Some
  # readers might not be aware of multiple item selection
  # capability. Menu library provides functionality to write menus from
  # which the user can chose more than one item as the preferred
  # choice. This is dealt with in a later section. Now it is time for
  # some rudiments.
  Un menú es una visualización de pantalla que ayuda al usuario a
  elegir un cierto subconjunto de un conjunto dado de elementos. Para
  ponerlo simple, un menú es una colección de elementos de los que se
  pueden elegir uno o más elementos. Algunos lectores podrían no ser
  conscientes de la capacidad de seliccion de elementos multiples.  La
  libreria menu ofrece funcionalidad para escribir menús de los cuales
  es usuario puede elegir más de un elemento. Esto se trata en una
  sección posterior. Ahora es el momento para algunas nociones.

# ** 17.1. The Basics
** 17.1. Lo basico

   # To create menus, you first create items, and then post the menu to
   # the display. After that, all the processing of user responses is
   # done in an elegant function =menu_driver()= which is the work horse
   # of any menu program.
   Para crear menús, primero debe crear elementos, y luego colocar el
   menú en la pantalla. Después de eso, todo el procesamiento de las
   respuestas del usuario es hecho en una función elegante llamada
   =menu_driver()= que es el caballo de trabajo de cualquier programa
   de menú.

   # The general flow of control of a menu program looks like this.
   El flujo general de control de un programa de menú se parece a
   esto.

   # 1. Initialize curses
   1. Inicializar curses

   # 2. Create items using =new_item()=. You can specify a name and
   #    description for the items.
   2. Cree elementos usando =new_item()=. Puede especificar un nombre
      y una descripción de los elementos.

   # 3. Create the menu with =new_menu()= by specifying the items to be
   #    attached with.
   3. Crear el menú con =new_menu()= especificando los elementos que
      se agregaran a este.

   # 4. Post the menu with =menu_post()= and refresh the screen.
   4. Publicar el menú con =menu_post()= y refrescar la pantalla.

   # 5. Process the user requests with a loop and do necessary updates
   #    to menu with =menu_driver=.
   5. Procesar las las peticiones de los usuarios con un bucle y hacer
      las actualizaciones necesarias al menú con =menu_driver=.

   # 6. Unpost the menu with =menu_unpost()=
   6. Quitar el menú con =menu_unpost()=

   # 7. Free the memory allocated to menu by =free_menu()=
   7. Liberar la memoria asignada al menú con =free_menu()=

   # 8. Free the memory allocated to the items with =free_item()=
   8. Liberar la memoria asignada a los elementos con =free_item()=

   # 9. End curses
   9. Finalizar curses


   # Let's see a program which prints a simple menu and updates the
   # current selection with up, down arrows.

   Vamos a ver un programa que imprime un menú sencillo y actualiza la
   selección actual con las teclas de flecha arriba, abajo.

# ** 17.2. Compiling With the Menu Library
** 17.2. Compilación con la Libreria Menú

   # To use menu library functions, you have to include menu.h and to
   # link the program with menu library the flag =-lmenu= should be
   # added along with =-lncurses= in that order.
   Para utilizar las funciones de libreria de menu, tiene que incluir
   =menu.h= y enlazar el programa con la libreria menu mediante la
   bandera =-lmenu= debe ser añadido junto con =-lncurses= en ese
   orden.

   #+BEGIN_EXAMPLE
     #include <menu.h>
     .
     .
     .

     compilacion y enlace: gcc <fichero del programa> -lmenu -lncurses
   #+END_EXAMPLE

   # *Example 18. Menu Basics*
   [[file:ncurses_programs/menus/menu_simple.c][*Ejemplo 18. Conceptos básicos de Menu*]]

   #+BEGIN_SRC c
     #include <stdlib.h>
     #include <curses.h>
     #include <menu.h>

     #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
     #define CTRLD   4

     char *choices[] = {
       "Eleccion 1",
       "Eleccion 2",
       "Eleccion 3",
       "Eleccion 4",
       "Salir",
     };

     int main()
     { ITEM **my_items;
       int c;
       MENU *my_menu;
       int n_choices, i;
       ITEM *cur_item;


       initscr();
       cbreak();
       noecho();
       keypad(stdscr, TRUE);

       n_choices = ARRAY_SIZE(choices);
       my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));

       for(i = 0; i < n_choices; ++i)
         my_items[i] = new_item(choices[i], choices[i]);
       my_items[n_choices] = (ITEM *)NULL;

       my_menu = new_menu((ITEM **)my_items);
       mvprintw(LINES - 2, 0, "F1 para Salir");
       post_menu(my_menu);
       refresh();

       while((c = getch()) != KEY_F(1))
         {   switch(c)
             {   case KEY_DOWN:
                 menu_driver(my_menu, REQ_DOWN_ITEM);
                 break;
             case KEY_UP:
               menu_driver(my_menu, REQ_UP_ITEM);
               break;
             }
         }

       free_item(my_items[0]);
       free_item(my_items[1]);
       free_menu(my_menu);
       endwin();
     }
   #+END_SRC

   # This program demonstrates the basic concepts involved in creating a
   # menu using menus library. First we create the items using
   # =new_item()= and then attach them to the menu with =new_menu()=
   # function. After posting the menu and refreshing the screen, the
   # main processing loop starts. It reads user input and takes
   # corresponding action. The function =menu_driver()= is the main work
   # horse of the menu system. The second parameter to this function
   # tells what's to be done with the menu.  According to the parameter,
   # =menu_driver()= does the corresponding task.  The value can be
   # either a menu navigational request, an ascii character, or a
   # =KEY_MOUSE= special key associated with a mouse event.
   Este programa demuestra los conceptos básicos que intervienen en la
   creación de un menú con libreria menu. Primero creamos los
   elementos mediante =new_item()= y luego los agregamos al menu con
   la funcion =new_menu()=. Después de publicar el menu y actualizar
   la pantalla, inicia el bucle principal de procesamiento. Se lee la
   entrada del usuario y se toma la acción correspondiente. La función
   =menu_driver()= es el principal caballo de trabajo del sistema de
   menus. El segundo parámetro para esta función dice lo que hay que
   hacer con el menu. De acuerdo con el parámetro, =menu_driver()=
   hace la tarea correspondiente. El valor puede ser ya sea una
   solicitud de navegación, un carácter ASCII, o una clave especial
   =KEY_MOUSE= asociada a un evento de ratón.

   # The =menu_driver= accepts following navigational requests.
   =menu_driver= acepta las siguientes solicitudes de navegación.

   # #+BEGIN_EXAMPLE
   #   REQ_LEFT_ITEM       Move left to an item.
   #   REQ_RIGHT_ITEM      Move right to an item.
   #   REQ_UP_ITEM         Move up to an item.
   #   REQ_DOWN_ITEM       Move down to an item.
   #   REQ_SCR_ULINE       Scroll up a line.
   #   REQ_SCR_DLINE       Scroll down a line.
   #   REQ_SCR_DPAGE       Scroll down a page.
   #   REQ_SCR_UPAGE       Scroll up a page.
   #   REQ_FIRST_ITEM      Move to the first item.
   #   REQ_LAST_ITEM       Move to the last item.
   #   REQ_NEXT_ITEM       Move to the next item.
   #   REQ_PREV_ITEM       Move to the previous item.
   #   REQ_TOGGLE_ITEM     Select/deselect an item.
   #   REQ_CLEAR_PATTERN   Clear the ¤menu pattern buffer.
   #   REQ_BACK_PATTERN    Delete the previous character from the pattern buffer.
   #   REQ_NEXT_MATCH      Move to the next item matching the pattern match.
   #   REQ_PREV_MATCH      Move to the previous item matching the pattern match.
   # #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     REQ_LEFT_ITEM      	 Mover un elemento a la izquierda.
     REQ_RIGHT_ITEM     	 Mover un elemento a la derecha.
     REQ_UP_ITEM        	 Mover un elemento hacia arriba.
     REQ_DOWN_ITEM      	 Mover un elemento hacia abajo.
     REQ_SCR_ULINE      	 Desplácese una línea arriba.
     REQ_SCR_DLINE      	 Desplácese una línea abajo.
     REQ_SCR_DPAGE      	 Desplazarse una página hacia arriba.
     REQ_SCR_UPAGE      	 Desplazarse una página hacia abajo.
     REQ_FIRST_ITEM     	 Mover al primer elemento.
     REQ_LAST_ITEM      	 Mover al último elemento.
     REQ_NEXT_ITEM      	 Mover al siguiente elemento.
     REQ_PREV_ITEM      	 Mover al elemento anterior.
     REQ_TOGGLE_ITEM    	 Seleccionar/deseleccionar un elemento.
     REQ_CLEAR_PATTERN  	 Borrar el buffer de patrones menu.
     REQ_BACK_PATTERN   	 Eliminar el carácter anterior desde el buffer de patrones.
     REQ_NEXT_MATCH     	 Mover al elemento siguiente que coincida con el patron.
     REQ_PREV_MATCH     	 Mover al elemento anterior que coincida con el patron.
   #+END_EXAMPLE

   # Don't get overwhelmed by the number of options. We will see them
   # slowly one after another. The options of interest in this example
   # are =REQ_UP_ITEM= and =REQ_DOWN_ITEM=. These two options when
   # passed to =menu_driver=, menu driver updates the current item to
   # one item up or down respectively.
   No se deje abrumar por el número de opciones. Vamos a verlos
   lentamente una tras otro. Las opciones de interés en este ejemplo
   son =REQ_UP_ITEM= y =REQ_DOWN_ITEM=. Estas dos opciones son pasadas
   a =menu_driver=, que actualiza el elemento actual a un elemento
   hacia arriba o hacia abajo, respectivamente.

# ** 17.3. Menu Driver: The work horse of the menu system
** 17.3. Menu Driver: El caballo de trabajo del sistema de menus

   # As you have seen in the above example, =menu_driver= plays an
   # important role in updating the menu. It is very important to
   # understand various options it takes and what they do. As explained
   # above, the second parameter to =menu_driver()= can be either a
   # navigational request, a printable character or a =KEY_MOUSE=
   # key. Let's dissect the different navigational requests.
   Como se ha visto en el ejemplo anterior, =menu_driver= juega un
   papel importante en la actualización del menu. Es muy importante
   comprender las diversas opciones y lo que hacen. Como se ha
   explicado, el segundo parámetro de =menu_driver()= puede ser una
   solicitud de navegación, un carácter imprimible o una clave
   =KEY_MOUSE=. Vamos a analizar las diferentes solicitudes de
   navegación.

   - =REQ_LEFT_ITEM= y =REQ_RIGHT_ITEM=

     # A Menu can be displayed with multiple columns for more than one
     # item.  This can be done by using the
     # =menu_format()=function. When a multi columnar menu is displayed
     # these requests cause the menu driver to move the current
     # selection to left or right.
     Se puede visualizar un menu con varias columnas de más de un
     ítem. Esto se realiza mediante la funcion =menu_format()=. Cuando
     se muestra un menu de columnas múltiples estas peticiones hacen
     que =menu_driver= de menu mueva la eleccion actual a la izquierda
     o la derecha.

   - =REQ_UP_ITEM= and =REQ_DOWN_ITEM=

     # These two options you have seen in the above example. These
     # options when given, makes the =menu_driver= to move the current
     # selection to an item up or down.
     Estas dos opciones se han visto en el ejemplo anterior. Cuando se
     pasan estas opciones, hacen que =menu_driver= mueva la eleccion
     actual un elemento hacia arriba o hacia abajo.

   - Opciones =REQ_SCR_*=

     # The four options =REQ_SCR_ULINE=, =REQ_SCR_DLINE=,
     # =REQ_SCR_DPAGE=, =REQ_SCR_UPAGE= are related to scrolling. If all
     # the items in the menu cannot be displayed in the menu sub window,
     # then the menu is scrollable. These requests can be given to the
     # =menu_driver= to do the scrolling either one line up, down or one
     # page down or up respectively.
     Las cuatro opciones =REQ_SCR_ULINE=, =REQ_SCR_DLINE=,
     =REQ_SCR_DPAGE=, =REQ_SCR_UPAGE= están relacionadas con el
     desplazamiento. Si no se pueden mostrar todos los elementos de el
     menu en la subventana menu, el menu es desplazable. Estas
     solicitudes se pueden pasar a =menu_driver= para realizar el
     desplazamiento, ya sea por línea o por pagina hacia arriba o
     hacia abajo respectivamente.

   - =REQ_FIRST_ITEM=, =REQ_LAST_ITEM=, =REQ_NEXT_ITEM= and
     =REQ_PREV_ITEM=

     # These requests are self explanatory.
     Estas solicitudes se explica por sí mismas.

   - =REQ_TOGGLE_ITEM=

     # This request when given, toggles the present selection. This
     # option is to be used only in a multi valued menu. So to use this
     # request the option =O_ONEVALUE= must be off. This option can be
     # made off or on with =set_menu_opts()=.
     Quando se pasa esta solicitud, se alterna la selección actual.
     Solo se utiliza esta opción en un menu de valores múltiples. Para
     utilizar esta solicitud la opción =O_ONEVALUE= debe estar
     apagada. Esta opción puede ser apagar o encender con
     =set_menu_opts()=.

   # - /Pattern Requests/
   - /Solicitud por Patrones/

     # Every menu has an associated pattern buffer, which is used to
     # find the nearest match to the ascii characters entered by the
     # user.  Whenever ascii characters are given to =menu_driver=, it
     # puts in to the pattern buffer. It also tries to find the nearest
     # match to the pattern in the items list and moves current
     # selection to that item.  The request =REQ_CLEAR_PATTERN= clears
     # the pattern buffer. The request =REQ_BACK_PATTERN= deletes the
     # previous character in the pattern buffer. In case the pattern
     # matches more than one item then the matched items can be cycled
     # through =REQ_NEXT_MATCH= and =REQ_PREV_MATCH= which move the
     # current selection to the next and previous matches respectively.
     Cada menu tiene una buffer de patrones asociado, que se utiliza
     para encontrar la coincidencia más cercana a los caracteres ASCII
     introducidos por el usuario. Siempre que se pasan caracteres
     ASCII a =menu_driver=, se colocan el el buffer de patrones. Este
     inteta encontrar la coincida más cercana con el patrón en la
     lista de elementos y mueve la seleccion a ese elemento. La
     solicitud =REQ_CLEAR_PATTERN= limpia el buffer de patrones. La
     solicitud =REQ_BACK_PATTERN= borra el carácter anterior en el
     buffer de patrones. En caso de que el patrón coincida con mas de
     un elemento se puede rotar por los elementos coincidentes con
     =REQ_NEXT_MATCH= y =REQ_PREV_MATCH= que mueven la selección a la
     conicidencia siguiente y anterior, respectivamente.

   # - /Mouse Requests/
   - /Solicitudes del raton/

     # In case of =KEY_MOUSE= requests, according to the mouse position
     # an action is taken accordingly. The action to be taken is
     # explained in the man page as,
     En caso de solicitudes =KEY_MOUSE=, de acuerdo con la posición
     del ratón se toma una acción en consecuencia. La acción a tomar
     se explica en la página man como,

     # #+BEGIN_QUOTE
     #   If  the  second argument is the KEY_MOUSE special key, the
     #   associated mouse event is translated into one of the above
     #   pre-defined  requests.   Currently only clicks in the user
     #   window (e.g. inside the menu display area or  the  decora­
     #   tion  window)  are handled. If you click above the display
     #   region of the menu, a REQ_SCR_ULINE is generated,  if  you
     #   doubleclick  a  REQ_SCR_UPAGE  is  generated  and  if  you
     #   tripleclick a REQ_FIRST_ITEM is generated.  If  you  click
     #   below  the  display region of the menu, a REQ_SCR_DLINE is
     #   generated, if you doubleclick a REQ_SCR_DPAGE is generated
     #   and  if  you  tripleclick a REQ_LAST_ITEM is generated. If
     #   you click at an item inside the display area of the  menu,
     #   the menu cursor is positioned to that item.
     # #+END_QUOTE

     #+BEGIN_QUOTE
       Si el segundo argumento es la clave especial =KEY_MOUSE=, el
       evento de ratón asociado se traduce en una de las anteriores
       solicitudes pre-definidas. Actualmente, solo se manejan los
       clics en la ventana de usuario (por ejemplo, dentro del área de
       visualización del menu o la decoracion de ventana). Si hace
       clic sobre la zona de visualizacion del menu, se genera un
       =REQ_SCR_ULINE=, con doble clic se genera =REQ_SCR_UPAGE= y con
       triple clic =REQ_FIRST_ITEM=. Si hace clic por debajo de la
       zona de visualización del menu, se genera un =REQ_SCR_DLINE=,
       un doble clic =REQ_SCR_DPAGE= y un triple click genera
       =REQ_LAST_ITEM=.  Si hace clic en un elemento dentro del área
       de visualización del menu, el cursor del menu se coloca en
       dicho elemento.
     #+END_QUOTE


   # Each of the above requests will be explained in the following lines
   # with several examples whenever appropriate.

   Cada una de las solicitudes anteriores se explicará en las
   siguientes líneas con varios ejemplos siempre que sea apropiado.

# ** 17.4. Menu Windows
** 17.4. Ventanas de Menu

   # Every menu created is associated with a window and a sub
   # window. The menu window displays any title or border associated
   # with the menu. The menu sub window displays the menu items
   # currently available for selection. But we didn't specify any window
   # or sub window in the simple example. When a window is not
   # specified, stdscr is taken as the main window, and then menu system
   # calculates the sub window size required for the display of
   # items. Then items are displayed in the calculated sub window. So
   # let's play with these windows and display a menu with a border and
   # a title.
   Cada menu creado se asocia con una ventana y una sub ventana. La
   ventana menu muestra cualquier título o borde asociado con el
   menu. La ventana submenu muestra los elementos del menu actualmente
   disponible para su selección. Pero no especificamos ninguna ventana
   o subventana en el ejemplo. Cuando no se especifica una ventana,
   =stdscr= se toma como la ventana principal y, el sistema de menus
   calcula el tamaño requerido de la subventana para la visualización
   de elementos. A continuación se muestran los elementos en la
   subventana. Asi que vamos a jugar con estas ventanas, mostrado un
   menu con un borde y un título.

   # *Example 19. Menu Windows Usage example*
   [[file:ncurses_programs/menus/menu_win.c][*Ejemplo 19. Uso de Ventanas Menu*]]

   #+BEGIN_SRC c
     #include <menu.h>
     #include <stdlib.h>
     #include <string.h>

     #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
     #define CTRLD   4

     char *choices[] = {
       "Opcion 1",
       "Opcion 2",
       "Opcion 3",
       "Opcion 4",
       "Salir",
       (char *)NULL,
     };

     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

     int main()
     { ITEM **my_items;
       int c;
       MENU *my_menu;
       WINDOW *my_menu_win;
       int n_choices, i;

       /* Inicializa curses */
       initscr();
       start_color();
       cbreak();
       noecho();
       keypad(stdscr, TRUE);
       init_pair(1, COLOR_RED, COLOR_BLACK);

       /* Crea los elementos */
       n_choices = ARRAY_SIZE(choices);
       my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
       for(i = 0; i < n_choices; ++i)
         my_items[i] = new_item(choices[i], choices[i]);

       /* Crea el menu */
       my_menu = new_menu((ITEM **)my_items);

       /* Crea la ventana que sera asociada con el menu */
       my_menu_win = newwin(10, 40, 4, 4);
       keypad(my_menu_win, TRUE);

       /* Establece la ventana principal y la subventana */
       set_menu_win(my_menu, my_menu_win);
       set_menu_sub(my_menu, derwin(my_menu_win, 6, 38, 3, 1));

       /* Establece la marca del menu con la cadena " * " */
       set_menu_mark(my_menu, " * ");

       /* Imprime un margen alrededor de la ventana pricipal e imprime el titulo */
       box(my_menu_win, 0, 0);
       print_in_middle(my_menu_win, 1, 0, 40, "Mi Menu", COLOR_PAIR(1));
       mvwaddch(my_menu_win, 2, 0, ACS_LTEE);
       mvwhline(my_menu_win, 2, 1, ACS_HLINE, 38);
       mvwaddch(my_menu_win, 2, 39, ACS_RTEE);
       mvprintw(LINES - 2, 0, "F1 para Salir");
       refresh();

       /* Publica el menu */
       post_menu(my_menu);
       wrefresh(my_menu_win);

       while((c = wgetch(my_menu_win)) != KEY_F(1)){
         switch(c){
         case KEY_DOWN:
           menu_driver(my_menu, REQ_DOWN_ITEM);
           break;
         case KEY_UP:
           menu_driver(my_menu, REQ_UP_ITEM);
           break;
         }
         wrefresh(my_menu_win);
       }

       /* remueve el menu y libera toda la memoria tomada */
       unpost_menu(my_menu);
       free_menu(my_menu);
       for(i = 0; i < n_choices; ++i)
         free_item(my_items[i]);
       endwin();
     }

     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
     { int length, x, y;
       float temp;

       if(win == NULL)
         win = stdscr;
       getyx(win, y, x);
       if(startx != 0)
         x = startx;
       if(starty != 0)
         y = starty;
       if(width == 0)
         width = 80;

       length = strlen(string);
       temp = (width - length)/ 2;
       x = startx + (int)temp;
       wattron(win, color);
       mvwprintw(win, y, x, "%s", string);
       wattroff(win, color);
       refresh();
     }
   #+END_SRC

   # This example creates a menu with a title, border, a fancy line
   # separating title and the items. As you can see, in order to attach
   # a window to a menu the function =set_menu_win()= has to be
   # used. Then we attach the sub window also. This displays the items
   # in the sub window.  You can also set the mark string which gets
   # displayed to the left of the selected item with =set_menu_mark()=.
   En este ejemplo se crea un menu con un título, margen, una
   fantastica línea separa el título y los elementos. Como puede ver,
   con el fin de unir una ventana a un menu se utiliza la función
   =set_menu_win()=. A continuación agregamos tambien la ventana
   secundaria. Esto despliega los elementos en la subventana. También
   puede establecer la cadena de marca que se muestra a la izquierda
   del elemento seleccionado con =set_menu_mark()=.

# ** 17.5. Scrolling Menus
** 17.5. Desplazamiento en Menus

   # If the sub window given for a window is not big enough to show all
   # the items, then the menu will be scrollable. When you are on the
   # last item in the present list, if you send =REQ_DOWN_ITEM=, it gets
   # translated into =REQ_SCR_DLINE= and the menu scrolls by one
   # item. You can manually give =REQ_SCR_= operations to do
   # scrolling. Let's see how it can be done.
   Si la subventana dada no es lo suficientemente grande para mostrar
   todo los elementos, el menu serán desplazable. Cuando se está en el
   último elemento de la lista actual, si envía =REQ_DOWN_ITEM=, sera
   traducido como =REQ_SCR_DLINE= y el menu se desplaza un elemento.
   Puede pasar manualmente operaciones =REQ_SCR_= para realizar el
   desplazamiento. Veamos cómo se puede realizar.

   # *Example 20. Scrolling Menus example*
   [[file:ncurses_programs/menus/menu_scroll.c][*Ejemplo 20. Menu con Desplazamiento*]]

   #+BEGIN_SRC c
     #include <curses.h>
     #include <menu.h>
     #include <stdlib.h>
     #include <string.h>

     #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
     #define CTRLD   4

     char *choices[] = {
       "Opcion 1",
       "Opcion 2",
       "Opcion 3",
       "Opcion 4",
       "Opcion 5",
       "Opcion 6",
       "Opcion 7",
       "Opcion 8",
       "Opcion 9",
       "Opcion 10",
       "Salir",
       (char *)NULL,
     };

     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

     int main(){
       ITEM **my_items;
       int c;
       MENU *my_menu;
       WINDOW *my_menu_win;
       int n_choices, i;

       /* Inicializa curses */
       initscr();
       start_color();
       cbreak();
       noecho();
       keypad(stdscr, TRUE);
       init_pair(1, COLOR_RED, COLOR_BLACK);
       init_pair(2, COLOR_CYAN, COLOR_BLACK);

       /* Crea los elementos */
       n_choices = ARRAY_SIZE(choices);
       my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
       for(i = 0; i < n_choices; ++i)
         my_items[i] = new_item(choices[i], choices[i]);

       /* Crea el menu */
       my_menu = new_menu((ITEM **)my_items);

       /* Crea la ventana que sera asociada con el menu */
       my_menu_win = newwin(10, 40, 4, 4);
       keypad(my_menu_win, TRUE);

       /* Establece la ventana principal y la subventana */
       set_menu_win(my_menu, my_menu_win);
       set_menu_sub(my_menu, derwin(my_menu_win, 6, 38, 3, 1));
       set_menu_format(my_menu, 5, 1);

       /* Establece la marca del menu con la cadena " * " */
       set_menu_mark(my_menu, " * ");

       /* Imprime un margen alrededor de la ventana pricipal e imprime el titulo */
       box(my_menu_win, 0, 0);
       print_in_middle(my_menu_win, 1, 0, 40, "Mi Menu", COLOR_PAIR(1));
       mvwaddch(my_menu_win, 2, 0, ACS_LTEE);
       mvwhline(my_menu_win, 2, 1, ACS_HLINE, 38);
       mvwaddch(my_menu_win, 2, 39, ACS_RTEE);

       /* Publica el menu */
       post_menu(my_menu);
       wrefresh(my_menu_win);

       attron(COLOR_PAIR(2));
       mvprintw(LINES - 2, 0, "Use PageUp y PageDown para desplazar una pagina de elementos abajo o arriba");
       mvprintw(LINES - 1, 0, "Las flechas para navegar (F1 Para Salir)");
       attroff(COLOR_PAIR(2));
       refresh();

       while((c = wgetch(my_menu_win)) != KEY_F(1)){
         switch(c){
         case KEY_DOWN:
           menu_driver(my_menu, REQ_DOWN_ITEM);
           break;
         case KEY_UP:
           menu_driver(my_menu, REQ_UP_ITEM);
           break;
         case KEY_NPAGE:
           menu_driver(my_menu, REQ_SCR_DPAGE);
           break;
         case KEY_PPAGE:
           menu_driver(my_menu, REQ_SCR_UPAGE);
           break;
         }
         wrefresh(my_menu_win);
       }

       /* Remueve el menu y libera toda la memoria tomada */
       unpost_menu(my_menu);
       free_menu(my_menu);
       for(i = 0; i < n_choices; ++i)
         free_item(my_items[i]);
       endwin();
     }

     void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color){
       int length, x, y;
       float temp;

       if(win == NULL)
         win = stdscr;
       getyx(win, y, x);
       if(startx != 0)
         x = startx;
       if(starty != 0)
         y = starty;
       if(width == 0)
         width = 80;

       length = strlen(string);
       temp = (width - length)/ 2;
       x = startx + (int)temp;
       wattron(win, color);
       mvwprintw(win, y, x, "%s", string);
       wattroff(win, color);
       refresh();
     }
   #+END_SRC

   # This program is self-explanatory. In this example the number of
   # choices has been increased to ten, which is larger than our sub
   # window size which can hold 6 items. This message has to be
   # explicitly conveyed to the menu system with the function
   # =set_menu_format()=. In here we specify the number of rows and
   # columns we want to be displayed for a single page. We can specify
   # any number of items to be shown, in the rows variables, if it is
   # less than the height of the sub window. If the key pressed by the
   # user is a PAGE UP or PAGE DOWN, the menu is scrolled a page due to
   # the requests (=REQ_SCR_DPAGE= and =REQ_SCR_UPAGE=) given to
   # =menu_driver()=.
   Este programa se explica por sí. En este ejemplo, el número de
   opciones ha sido aumentado a diez, que es más grande que el tamaño
   que nuestra subventana puede albergar (6 elementos). Este mensaje
   tiene que ser transmitido explícitamente al sistema de menus con la
   función =set_menu_format()=. Aquí especificamos el número de filas
   y columnas que queremos que se muestren para una sola página.
   Podemos especificar cualquier número de elementos a mostrar, en la
   variable rows, si este es menor que la altura de la subventana. Si
   la tecla presionada por el usuario es PAGE UP o PAGE DOWN, el menu
   se desplaza una página debido a la las solicitudes (=REQ_SCR_DPAGE=
   y =REQ_SCR_UPAGE=) dadas a =menu_driver()=.

# ** 17.6. Multi Columnar Menus
** 17.6. Menu de Multiples Columnas

   # In the above example you have seen how to use the function
   # =set_menu_format()=. I didn't mention what the cols variable (third
   # parameter) does. Well, If your sub window is wide enough, you can
   # opt to display more than one item per row. This can be specified in
   # the cols variable. To make things simpler, the following example
   # doesn't show descriptions for the items.
   En el ejemplo anterior se vio cómo utilizar la función
   =set_menu_format()=. No mencioné lo que hace la variable =cols=
   (tercer parámetro). Si la subventana es lo suficientemente amplia,
   puede optar por mostrar más de un elemento por fila. Esto se puede
   especificar en la variable =cols=. Para aclarar las cosas, El
   siguiente ejemplo no muestra la descripcion de los elementos.

   # *Example 21. Milt Columnar Menus Example*
   [[file:ncurses_programs/menus/menu_multi_column.c][*Ejemplo 21. Menu con Columnas Multiples*]]

   #+BEGIN_SRC c
     #include <curses.h>
     #include <menu.h>
     #include <stdlib.h>

     #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
     #define CTRLD   4

     char *choices[] = {
       "Opcion 1",  "Opcion 2",  "Opcion 3",  "Opcion 4",  "Opcion 5",
       "Opcion 6",  "Opcion 7",  "Opcion 8",  "Opcion 9",  "Opcion 10",
       "Opcion 11", "Opcion 12", "Opcion 13", "Opcion 14", "Opcion 15",
       "Opcion 16", "Opcion 17", "Opcion 18", "Opcion 19", "Opcion 20",
       "Salir",
       (char *)NULL,
     };

     int main(){
       ITEM **my_items;
       int c;
       MENU *my_menu;
       WINDOW *my_menu_win;
       int n_choices, i;

       /* Tnicializa curses */
       initscr();
       start_color();
       cbreak();
       noecho();
       keypad(stdscr, TRUE);
       init_pair(1, COLOR_RED, COLOR_BLACK);
       init_pair(2, COLOR_CYAN, COLOR_BLACK);

       /* Crea los elementos */
       n_choices = ARRAY_SIZE(choices);
       my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
       for(i = 0; i < n_choices; ++i)
         my_items[i] = new_item(choices[i], choices[i]);

       /* Crea el menu */
       my_menu = new_menu((ITEM **)my_items);

       /* Configura la opcion del menu para no mostar la descripcion */
       menu_opts_off(my_menu, O_SHOWDESC);

       /* Crea la ventana que sera asociada al menu */
       my_menu_win = newwin(10, 70, 4, 4);
       keypad(my_menu_win, TRUE);

       /* Establece la vetana principal y la subventana */
       set_menu_win(my_menu, my_menu_win);
       set_menu_sub(my_menu, derwin(my_menu_win, 6, 68, 3, 1));
       set_menu_format(my_menu, 5, 3);
       set_menu_mark(my_menu, " * ");

       /* Imprime un margen alrededor de la ventana pricipal e imprime el titulo */
       box(my_menu_win, 0, 0);

       attron(COLOR_PAIR(2));
       mvprintw(LINES - 3, 0, "Use PageUp y PageDown para el desplazamiento");
       mvprintw(LINES - 2, 0, "Use Las flechas para navegar (F1 Para Salir)");
       attroff(COLOR_PAIR(2));
       refresh();

       /* Publica el menu */
       post_menu(my_menu);
       wrefresh(my_menu_win);

       while((c = wgetch(my_menu_win)) != KEY_F(1)){
         switch(c){
         case KEY_DOWN:
           menu_driver(my_menu, REQ_DOWN_ITEM);
           break;
         case KEY_UP:
           menu_driver(my_menu, REQ_UP_ITEM);
           break;
         case KEY_LEFT:
           menu_driver(my_menu, REQ_LEFT_ITEM);
           break;
         case KEY_RIGHT:
           menu_driver(my_menu, REQ_RIGHT_ITEM);
           break;
         case KEY_NPAGE:
           menu_driver(my_menu, REQ_SCR_DPAGE);
           break;
         case KEY_PPAGE:
           menu_driver(my_menu, REQ_SCR_UPAGE);
           break;
         }
         wrefresh(my_menu_win);
       }

       /* Remueve el menu y libera toda la memoria tomada */
       unpost_menu(my_menu);
       free_menu(my_menu);
       for(i = 0; i < n_choices; ++i)
         free_item(my_items[i]);
       endwin();
     }
   #+END_SRC

   # Watch the function call to =set_menu_format()=. It specifies the
   # number of columns to be 3, thus displaying 3 items per row. We have
   # also switched off the showing descriptions with the function
   # =menu_opts_off()=. There are couple of functions =set_menu_opts()=,
   # =menu_opts_on()= and =menu_opts()= which can be used to manipulate
   # menu options. The following menu options can be specified.

   Ver la llamada a la función = set_menu_format()=. Especifica el
   número de columnas a ser 3, mostrando de este modo 3 artículos por fila. Tenemos
   También apagado las descripciones que muestran con la función
   menu_opts_off()=. Hay par de funciones = set_menu_opts()=,
   menu_opts_on()= y = menu_opts()= que se pueden utilizar para manipular
   opciones de menu. Las siguientes opciones de menu se pueden especificar.

   # #+BEGIN_EXAMPLE
   #   O_ONEVALUE
   #        Only one item can be selected for this menu.

   #   O_SHOWDESC
   #        Display  the  item  descriptions  when  the  menu  is
   #        posted.

   #   O_ROWMAJOR
   #        Display the menu in row-major order.

   #   O_IGNORECASE
   #        Ignore the case when pattern-matching.

   #   O_SHOWMATCH
   #        Move the cursor to within the item  name  while  pat­
   #        tern-matching.

   #   O_NONCYCLIC
   #        ¤Don't   wrap   around  next-item  and  previous-item,
   #        requests to the other end of the menu.
   # #+END_EXAMPLE

   - =O_ONEVALUE=   :: Solo un elemento puede seleccionarse para este
                       menu.

   - =O_SHOWDESC=   :: Mostrar las descripciones de los elementos
                       cuando el menu es publicado.

   - =O_ROWMAJOR=   :: Mostrar el menu en orden de importancia de las
                       filas.

   - =O_IGNORECASE= :: Ignorar el caso en cuando el patron coincida.

   - =O_SHOWMATCH=  :: Mueve el cursor dentro del nombre del elemento,
                       mientras el patron coincide.

   - =O_NONCYCLIC=  :: No rotar entre el siguiente/anterior elemento,
                       solicitar por por el otro extremo del menu.


   # All options are on by default. You can switch specific attributes
   # on or off with =menu_opts_on()= and =menu_opts_off()=
   # functions. You can also use =set_menu_opts()= to directly specify
   # the options. The argument to this function should be a OR ed value
   # of some of those above constants.  The function =menu_opts()= can
   # be used to find out a menu's present options.
   Todas las opciones están habilitadas de forma predeterminada. Puede
   cambiar los atributos específicos a encendido o apagado con las
   funciones =menu_opts_on()= y =menu_opts_off()=. También puede
   utilizar =set_menu_opts()= para especificar directamente las
   opciones. El argumento para esta función debe ser un valor OR de
   algunas de las constantes anteriores. Puede utilazar la función
   =menu_opts()= para optener las opciones actuales de un menu.

# ** 17.7. Multi Valued Menus
** 17.7. Menu de Valores Multiples

   # You might be wondering what if you switch off the option
   # =O_ONEVALUE=.  Then the menu becomes multi-valued. That means you
   # can select more than one item. This brings us to the request
   # =REQ_TOGGLE_ITEM=. Let's see it in action.
   Tal vez se pregunte lo que ocurre si apaga la opción =O_ONEVALUE=.
   Esto crea un menu de valores multiples. Eso significa que se puede
   seleccionar más de un elemento. Esto nos lleva a la solicitud
   =REQ_TOGGLE_ITEM=. Veamoslo en acción.

   # *Example 22. Multi Valued Menus example*
   [[file:ncurses_programs/menus/menu_toggle.c][*Ejemplo 22. Menu de Valores Multiples*]]

   #+BEGIN_SRC c
     #include <curses.h>
     #include <menu.h>
     #include <stdlib.h>
     #include <string.h>

     #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
     #define CTRLD   4

     char *choices[] = {
       "Opcion 1",
       "Opcion 2",
       "Opcion 3",
       "Opcion 4",
       "Opcion 5",
       "Opcion 6",
       "Opcion 7",
       "Salir",
     };

     int main(){
       ITEM **my_items;
       int c;
       MENU *my_menu;
       int n_choices, i;
       ITEM *cur_item;

       /* Inicializa curses */
       initscr();
       cbreak();
       noecho();
       keypad(stdscr, TRUE);

       /* Inicializa elementos */
       n_choices = ARRAY_SIZE(choices);
       my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
       for(i = 0; i < n_choices; ++i)
         my_items[i] = new_item(choices[i], choices[i]);
       my_items[n_choices] = (ITEM *)NULL;

       my_menu = new_menu((ITEM **)my_items);

       /* Crea el menu de valores multiples */
       menu_opts_off(my_menu, O_ONEVALUE);

       mvprintw(LINES - 3, 0, "Use <SPACE> para seleccionar o deseleccionar un elemento.");
       mvprintw(LINES - 2, 0, "<ENTER> para ver los elementos seleccionados(F1 Para Salir)");
       post_menu(my_menu);
       refresh();

       while((c = getch()) != KEY_F(1)){
         switch(c){
         case KEY_DOWN:
           menu_driver(my_menu, REQ_DOWN_ITEM);
           break;
         case KEY_UP:
           menu_driver(my_menu, REQ_UP_ITEM);
           break;
         case ' ':
           menu_driver(my_menu, REQ_TOGGLE_ITEM);
           break;
         case 10:    /* Enter */
           { char temp[200];
             ITEM **items;

             items = menu_items(my_menu);
             temp[0] = '\0';
             for(i = 0; i < item_count(my_menu); ++i)
               if(item_value(items[i]) == TRUE){
                 strcat(temp, item_name(items[i]));
                 strcat(temp, " ");
               }
             move(20, 0);
             clrtoeol();
             mvprintw(20, 0, temp);
             refresh();
           }
           break;
         }
       }

       free_item(my_items[0]);
       free_item(my_items[1]);
       free_menu(my_menu);
       endwin();
     }
   #+END_SRC

   # Whew, A lot of new functions. Let's take them one after another.
   # Firstly, the =REQ_TOGGLE_ITEM=. In a multi-valued menu, the user
   # should be allowed to select or un select more than one item. The
   # request =REQ_TOGGLE_ITEM= toggles the present selection. In this
   # case when space is pressed =REQ_TOGGLE_ITEM= request is sent to
   # =menu_driver= to achieve the result.
   Menos mal, un montón de nuevas funciones. Vamos a tomar una tras
   otra.  En primer lugar, =REQ_TOGGLE_ITEM=. En un menu de valores
   multiples, se debe permitir a el usuario seleccionar o anular más
   de un elemento. La solicitud =REQ_TOGGLE_ITEM= alterna la selección
   actual. En esto caso cuando se pulsa espacio se envia la solicitud
   =REQ_TOGGLE_ITEM= a =menu_driver= para conseguir el resultado.

   # Now when the user presses <ENTER> we show the items he presently
   # selected. First we find out the items associated with the menu
   # using the function =menu_items()=. Then we loop through the items
   # to find out if the item is selected or not. The function
   # =item_value()= returns TRUE if an item is selected. The function
   # =item_count()= returns the number of items in the menu. The item
   # name can be found with =item_name()=. You can also find the
   # description associated with an item using =item_description()=.
   Ahora, cuando el usuario presiona <ENTER> se muestran los elementos
   actualmente seleccionados. Primero debemos encontrar los elementos
   asociados con el menu empleando la función =menu_items()=. A
   continuación, recorrer los elementos para saber si el elemento se
   selecciona o no. La función =item_value()= devuelve =TRUE= si el
   elemento se ha seleccionado. La función =item_count()= devuelve el
   número de elementos en el menu. El objeto nombre se puede optener
   con =item_name()=. También puede optener la descripción asociado
   con un elemento utilizando =item_description()=.

# ** 17.8. Menu Options
** 17.8. Opciones de Menu

   # Well, by this time you must be itching for some difference in your
   # menu, with lots of functionality. I know. You want Colors !!!. You
   # want to create nice menus similar to those text mode [[http://www.jersey.net/~debinjoe/games/][dos games]]. The
   # functions =set_menu_fore()= and =set_menu_back()= can be used to
   # change the attribute of the selected item and unselected item. The
   # names are misleading. They don't change menu's foreground or
   # background which would have been useless.
   Bueno, a estas alturas ya debe estar buscando alguna diferencia en
   su menu, con un montón de funcionalidades. Lo sé. Quiere Colores
   !!!. Quiere crear menus agradables similares a las de aquellos
   [[http://www.jersey.net/~debinjoe/games/][juegos dos]] en modo texto. Puede utilizar las funciones
   =set_menu_fore()= y =set_menu_back()= para cambiar el atributo de
   los elementos seleccionados y no seleccionados. Los nombres son
   engañosos. No cambian el primer plano o el fondo del menu lo cual
   los haria menos utiles.

   # The function =set_menu_grey()= can be used to set the display
   # attribute for the non-selectable items in the menu. This brings us
   # to the interesting option for an item the one and only
   # =O_SELECTABLE=. We can turn it off by the function
   # =item_opts_off()= and after that that item is not selectable. It's
   # like a grayed item in those fancy windows menus.  Let's put these
   # concepts in practice with this example
   Puede utilizar la función =set_menu_grey()= para establecer el
   atributo de pantalla para los elementos no seleccionables en el
   menu. Esto nos lleva a la interesante opción para un unico elemento
   =O_SELECTABLE=. Podemos apagar dicha opcion con la función
   =item_opts_off()= y luego el elemento deja de ser seleccionable.
   Esto es parecido a atenuar un elemento en alquellos fantasticos
   menus.  Vamos a poner estos conceptos en práctica con este ejemplo

   # *Example 23. Menu Options example*
   [[file:ncurses_programs/menus/menu_attrib.c][*Ejemplo 23. Opciones del Menu*]]

   #+BEGIN_SRC c
     #include <menu.h>
     #include <stdlib.h>

     #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
     #define CTRLD   4

     char *choices[] = {
       "Opcion 1",
       "Opcion 2",
       "Opcion 3",
       "Opcion 4",
       "Opcion 5",
       "Opcion 6",
       "Opcion 7",
       "Salir",
     };

     int main(){
       ITEM **my_items;
       int c;
       MENU *my_menu;
       int n_choices, i;
       ITEM *cur_item;

       /* Inicializa curses */
       initscr();
       start_color();
       cbreak();
       noecho();
       keypad(stdscr, TRUE);
       init_pair(1, COLOR_RED, COLOR_BLACK);
       init_pair(2, COLOR_GREEN, COLOR_BLACK);
       init_pair(3, COLOR_MAGENTA, COLOR_BLACK);

       /* Inicializa los elementos */
       n_choices = ARRAY_SIZE(choices);
       my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
       for(i = 0; i < n_choices; ++i)
         my_items[i] = new_item(choices[i], choices[i]);
       my_items[n_choices] = (ITEM *)NULL;
       item_opts_off(my_items[3], O_SELECTABLE);
       item_opts_off(my_items[6], O_SELECTABLE);

       /* Crea el menu */
       my_menu = new_menu((ITEM **)my_items);

       /* Establece el primer plano y el fondo del menu */
       set_menu_fore(my_menu, COLOR_PAIR(1) | A_REVERSE);
       set_menu_back(my_menu, COLOR_PAIR(2));
       set_menu_grey(my_menu, COLOR_PAIR(3));

       /* Post the menu */
       mvprintw(LINES - 3, 0, "Presione <ENTER> para ver la opcion seleccionada");
       mvprintw(LINES - 2, 0, "Flechas Arriba y Abajo para navegar (F1 para Salir)");
       post_menu(my_menu);
       refresh();

       while((c = getch()) != KEY_F(1)){
         switch(c){
         case KEY_DOWN:
           menu_driver(my_menu, REQ_DOWN_ITEM);
           break;
         case KEY_UP:
           menu_driver(my_menu, REQ_UP_ITEM);
           break;
         case 10: /* Enter */
           move(20, 0);
           clrtoeol();
           mvprintw(20, 0, "El elemento seleccionado es : %s",
                    item_name(current_item(my_menu)));
           pos_menu_cursor(my_menu);
           break;
         }
       }

       unpost_menu(my_menu);
       for(i = 0; i < n_choices; ++i)
         free_item(my_items[i]);
       free_menu(my_menu);
       endwin();
     }
   #+END_SRC

# ** 17.9. The useful User Pointer
** 17.9. El conveniente Puntero de Usuario

   # We can associate a user pointer with each item in the menu. It
   # works the same way as user pointer in panels. It's not touched by
   # menu system. You can store any thing you like in that. I usually
   # use it to store the function to be executed when the menu option is
   # chosen (It's selected and may be the user pressed <ENTER>);
   Podemos asociar un puntero de usuario a cada elemento del
   menu. Esto funciona de la misma forma que en los paneles. Esto no
   es tocado por el sistema de menus. Puede almacenar cualquier cosa
   en estos. Yo suelo utilizarlo para almacenar la función a ejecutar
   cuando se elige la opcion de menu (Esta seleccionada y el usuario
   pulsa <ENTER>);


   # *Example 24. Menu User Pointer Usage*
   [[file:ncurses_programs/menus/menu_userptr.c][*Ejemplo 24. Menu con Puntero de Usuario*]]

   #+BEGIN_SRC c
     #include <curses.h>
     #include <menu.h>
     #include <stdlib.h>

     #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
     #define CTRLD   4

     char *choices[] = {
       "Opcion 1",
       "Opcion 2",
       "Opcion 3",
       "Opcion 4",
       "Opcion 5",
       "Opcion 6",
       "Opcion 7",
       "Salir",
     };

     void func(char *name);

     int main(){
       ITEM **my_items;
       int c;
       MENU *my_menu;
       int n_choices, i;
       ITEM *cur_item;

       /* Inicializa curses */
       initscr();
       start_color();
       cbreak();
       noecho();
       keypad(stdscr, TRUE);
       init_pair(1, COLOR_RED, COLOR_BLACK);
       init_pair(2, COLOR_GREEN, COLOR_BLACK);
       init_pair(3, COLOR_MAGENTA, COLOR_BLACK);

       /* Inicializa los elementos */
       n_choices = ARRAY_SIZE(choices);
       my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
       for(i = 0; i < n_choices; ++i){
         my_items[i] = new_item(choices[i], choices[i]);
         /* Establece el puntero de usuario */
         set_item_userptr(my_items[i], func);
       }
       my_items[n_choices] = (ITEM *)NULL;

       /* Crea el menu */
       my_menu = new_menu((ITEM **)my_items);

       /* Publica el menu */
       mvprintw(LINES - 3, 0, "Presione <ENTER> para ver la opcion seleccionada");
       mvprintw(LINES - 2, 0, "Flechas Arriba y Abajo para navegar (F1 para Salir)");
       post_menu(my_menu);
       refresh();

       while((c = getch()) != KEY_F(1)){
         switch(c){
         case KEY_DOWN:
           menu_driver(my_menu, REQ_DOWN_ITEM);
           break;
         case KEY_UP:
           menu_driver(my_menu, REQ_UP_ITEM);
           break;
         case 10: /* Enter */
           { ITEM *cur;
             void (*p)(char *);

             cur = current_item(my_menu);
             p = item_userptr(cur);
             p((char *)item_name(cur));
             pos_menu_cursor(my_menu);
             break;
           }
           break;
         }
       }

       unpost_menu(my_menu);
       for(i = 0; i < n_choices; ++i)
         free_item(my_items[i]);
       free_menu(my_menu);
       endwin();
     }

     void func(char *name){
       move(20, 0);
       clrtoeol();
       mvprintw(20, 0, "El elemento seleccionado es : %s", name);
     }
   #+END_SRC

# * 18. Forms Library
* 18. Libreria Form

  # Well. If you have seen those forms on web pages which take input
  # from users and do various kinds of things, you might be wondering
  # how would any one create such forms in text mode display. It's quite
  # difficult to write those nifty forms in plain ncurses. Forms library
  # tries to provide a basic frame work to build and maintain forms with
  # ease. It has lot of features(functions) which manage validation,
  # dynamic expansion of fields etc.. Let's see it in full flow.
  Bien. Si usted ha visto esos formularios en páginas web que toman la
  entrada del usuario y hacen varios tipos de cosas, puede que se
  pregunte cómo crear formularios en pantalla en modo texto. Es
  bastante difícil escribir esos elegantes formularios en ncurses
  puro. La libreria form intenta proporcionar un marco de trabajo
  básico para construir y mantener formularios con facilidad. Cuenta
  con gran cantidad de características (funciones) que gestionan la
  validación, expansión dinámica de campos, etc.. Veamos esto en pleno
  desarrollo.

  # A form is a collection of fields; each field can be either a
  # label(static text) or a data-entry location. The forms also library
  # provides functions to divide forms into multiple pages.
  Un formulario es una colección de campos; Cada campo puede ser o
  bien una etiqueta (texto estático) o un lugar de entrada de datos.
  La libreria también proporciona funciones para dividir los
  formularios en varias páginas.

# ** 18.1. The Basics
** 18.1. Lo basico

   # Forms are created in much the same way as menus. First the fields
   # related to the form are created with =new_field()=. You can set
   # options for the fields, so that they can be displayed with some
   # fancy attributes, validated before the field looses focus
   # etc.. Then the fields are attached to form. After this, the form
   # can be posted to display and is ready to receive inputs. On the
   # similar lines to =menu_driver()=, the form is manipulated with
   # =form_driver()=. We can send requests to =form_driver= to move
   # focus to a certain field, move cursor to end of the field
   # etc.. After the user enters values in the fields and validation
   # done, form can be unposted and memory allocated can be freed.
   Los formularios se crean en la misma manera que los menus. Primero
   se crean los campos relacionados con el formulario con
   =new_field()=.  Puede configurar las opciones de los campos, de
   manera que se pueden mostrar con ciertos atributos, validar el
   contenido antes de perder el foco del campo etc.. A continuación,
   los campos se agregan al formulario. Después de esto, el formulario
   puede ser publicado y está listo para recibir entradas. En líneas
   similares a =menu_driver()=, los formularios se manejan con
   =form_driver()=. Podemos enviar solicitudes a =form_driver= para
   mover el foco a un cierto campo, mover el cursor al final del campo
   etc.. Después de que el usuario introduce los valores en los campos
   y se termina la validación, su puede remover el formulario liberar
   la menoria asignada.

   # The general flow of control of a forms program looks like this.
   El flujo de control general de un programa de formulario se vee
   como esto.

   # 1. Initialize curses
   1. Inicializar curses

   # 2. Create fields using =new_field()=. You can specify the height and
   #    width of the field, and its position on the form.
   2. Crear campos utilizando =new_field()=. Puede especificar la
      altura y anchura del campo, y su posición en el formulario.

   # 3. Create the forms with =new_form()= by specifying the fields to
   #    be attached with.
   3. Crear los formularios con =new_form()= especificando los campos
      a agregar.

   # 4. Post the form with =form_post()= and refresh the screen.
   4. Publicar el formulario con =form_post()= y refrescar la
      pantalla.

   # 5. Process the user requests with a loop and do necessary updates
   #    to form with =form_driver=.
   5. Procesar las peticiones de usuarios con un bucle y hacer las
      actualizaciones necesarias al formulario con =form_driver=.

   # 6. Unpost the menu with =form_unpost()=
   6. Remover  el menu con =form_unpost()=

   # 7. Free the memory allocated to menu by =free_form()=
   7. Liberar la memoria asignada al menu con =free_form()=

   # 8. Free the memory allocated to the items with =free_field()=
   8. Liberar la memoria asignada a los elementos con =free_field()=

   # 9. End curses
   9. Finalizar curses

   # As you can see, working with forms library is much similar to
   # handling menu library. The following examples will explore various
   # aspects of form processing. Let's start the journey with a simple
   # example. first.
   Como puede ver, trabajar con la libreria form es muy similar a el
   manejo de la libreria menu. Los siguientes ejemplos explorarán
   diversos aspectos de procesamiento de formularios. Vamos a empezar
   el viaje con un simple ejemplo. antes.

# ** 18.2. Compiling With the Forms Library
** 18.2. Compilación con la Libreria Form

   # To use forms library functions, you have to include form.h and to
   # link the program with forms library the flag =-lform= should be
   # added along with =-lncurses= in that order.
   Para utilizar funciones de la libreria form, tiene que incluir
   =form.h= y vincular el programa a la libreria con la bandera
   =-lform= se debe añadir junto con =-lncurses= en ese orden.

   #+BEGIN_EXAMPLE
     #include <form.h>
     .
     .
     .

     compilacion y enlace: gcc <fichero del programa> -lform -lncurses
   #+END_EXAMPLE

   # *Example 25. Forms Basics*
   [[file:ncurses_programs/forms/form_simple.c][*Ejemplo 25. Formularios Básicos*]]

   #+BEGIN_SRC c
     #include <form.h>

     int main(){
       FIELD *field[3];
       FORM  *my_form;
       int ch;

       /* Inicializar curses */
       initscr();
       cbreak();
       noecho();
       keypad(stdscr, TRUE);

       /* Inicializar los campos */
       field[0] = new_field(1, 10, 4, 18, 0, 0);
       field[1] = new_field(1, 10, 6, 18, 0, 0);
       field[2] = NULL;

       /* Establecer las opciones de campo */
       set_field_back(field[0], A_UNDERLINE);  /* Imprime una linea para la opcion */
       field_opts_off(field[0], O_AUTOSKIP);   /* No ir al siguente campo si este  */
                                               /* campo es llenado                 */
       set_field_back(field[1], A_UNDERLINE);
       field_opts_off(field[1], O_AUTOSKIP);

       /* Crear el formulario y publicarlo */
       my_form = new_form(field);
       post_form(my_form);
       refresh();

       mvprintw(4, 10, "Valor 1:");
       mvprintw(6, 10, "Valor 2:");
       refresh();

       /* Ciclo para optener solicitudes del usuario */
       while((ch = getch()) != KEY_F(1)){
         switch(ch){
         case KEY_DOWN:
           /* Ir al siguiente campo */
           form_driver(my_form, REQ_NEXT_FIELD);
           /* Ir al final del buffer actual */
           /* Deja en el ultimo caracter    */
           form_driver(my_form, REQ_END_LINE);
           break;
         case KEY_UP:
           /* Ir al campo anterior */
           form_driver(my_form, REQ_PREV_FIELD);
           form_driver(my_form, REQ_END_LINE);
           break;
         default:
           /* Si este es un caracter normal, se optiene */
           /* Imprime                                   */
           form_driver(my_form, ch);
           break;
         }
       }

       /* Remueve el formulario y libera la memoria */
       unpost_form(my_form);
       free_form(my_form);
       free_field(field[0]);
       free_field(field[1]);

       endwin();
       return 0;
     }
   #+END_SRC

   # Above example is pretty straight forward. It creates two fields
   # with =new_field()=. =new_field()= takes height, width, starty,
   # startx, number of offscreen rows and number of ¤additional working
   # buffers. The fifth argument number of offscreen rows specifies how
   # much of the field to be shown. If it is zero, the entire field is
   # always displayed otherwise the form will be scrollable when the
   # user accesses not displayed parts of the field. The forms library
   # allocates one buffer per field to store the data user enters. ¤Using
   # the last parameter to =new_field()= we can specify it to allocate
   # some additional buffers. These can be used for any purpose you
   # like.
   El ejemplo anterior es bastante sencillo. Se crean dos campos con
   =new_field()=. =new_field()= toma altura, anchura, starty, startx,
   número de filas fuera de la pantalla y el número de buffers de
   trabajo adicional. El quinto argumento especifica cómo mostrar gran
   parte del campo. Si es cero, todo el campo se muestra simpre de
   otra manera el formulario será desplazable cuando el campo no
   muestre partes de la entrada de usuario. La libreria de formularios
   asigna un búfer por campo para almacenar los datos que el usuario
   ingresa. Con el ultimo parametro de =new_field()= podemos
   especificar si se almacena en buffers adicionales. Estos puede
   utilizarse ​​para cualquier propósito.

   # After creating the fields, back ground attribute of both of them is
   # set to an underscore with =set_field_back()=. The AUTOSKIP option
   # is turned off using =field_opts_off()=. If this option is turned
   # on, focus will move to the next field in the form once the active
   # field is filled up completely.
   Después de crear los campos, el atributo de fondo de ambos es
   establecido como subrayado con =set_field_back()=. La opción
   =AUTOSKIP= se desactiva usando =field_opts_off()=. Si esta opción
   está activada, el foco se desplazará al siguiente campo en el
   formulario una vez que el campo activo se llene por completo.

   # After attaching the fields to the form, it is posted. Here on, user
   # inputs are processed in the while loop, by making corresponding
   # requests to =form_driver=. The details of all the requests to the
   # =form_driver()= are explained later.
   Después de colocar los campos en el formulario, se publica. Aquí,
   se procesa la entrada de usuario en un bucle =while=, haciendo las
   peticiones correspondientes a =form_driver=. Los detalles de todas
   las solicitudes a =form_driver()= se explican más adelante.

# ** 18.3. Playing with Fields
** 18.3. Jugando con Campos

   # Each form field is associated with a lot of attributes. They can be
   # manipulated to get the required effect and to have fun !!!. So why
   # wait?
   Cada campo del formulario se asocia con una gran cantidad de
   atributos. Estos se pueden manipular para conseguir el efecto
   deseado y divertirse !!!. Asi que ¿por que esperar?

# *** 18.3.1. Fetching Size and Location of Field
*** 18.3.1. Recuperar el Tamaño y Posicion del campo

    # The parameters we have given at the time of creation of a field
    # can be retrieved with =field_info()=. It returns height, width,
    # starty, startx, number of offscreen rows, and number of additional
    # buffers into the parameters given to it. It is a sort of inverse
    # of =new_field()=.
    Los parámetros dados a el momento de la creación de un campo
    pueden ser recuperados con =field_info()=. Devuelve la altura,
    anchura, starty, startx, número de filas fuera de la pantalla, y
    el número buffers adicionales en los parámetros que le son dados.
    Es una especie de =new_field()= inversa.

    #+BEGIN_SRC c
      int field_info(     FIELD *field,              /* campo a extraer datos                */
                          int *height, *int width,   /* tamaño de campo                      */
                          int *top, int *left,       /* esquina superior izquierda           */
                          int *offscreen,            /* numero de columnas fuera de pantalla */
                          int *nbuf);                /* numero de buffers de trabajo         */
    #+END_SRC

# *** 18.3.2. Moving the field
*** 18.3.2. Mover el campo

    # The location of the field can be moved to a different position
    # with =move_field()=.
    Puede mover el campo a una posición diferente con =move_field()=.

    #+BEGIN_SRC c
      int move_field(    FIELD *field,              /* campo a modificar                */
                         int top, int left);        /* nueva esquina superior izquierda */
    #+END_SRC

    # As usual, the changed position can be queried with
    # =field_infor()=.
    Puede consultar la posición modificada =field_infor()=.

# *** 18.3.3. Field Justification
*** 18.3.3. Justificar un campo

    # The justification to be done for the field can be fixed using the
    # function =set_field_just()=.
    Puede justificar un campo mediante la función =set_field_just()=.

    #+BEGIN_SRC c
      int set_field_just(FIELD *field,       /* campo a modificar  */
                         int justmode);      /* modo de ajuste     */
      int field_just(FIELD *field);          /* obtener el modo de justificacion de un campo */
    #+END_SRC

    # The justification mode valued accepted and returned by these
    # functions are =NO_JUSTIFICATION=, =JUSTIFY_RIGHT=, =JUSTIFY_LEFT=,
    # or =JUSTIFY_CENTER=.
    Los valores aceptados y devueltos para el modo de justificación
    son =NO_JUSTIFICATION=, =JUSTIFY_RIGHT=, =JUSTIFY_LEFT=, o
    =JUSTIFY_CENTER=.

# *** 18.3.4. Field Display Attributes
*** 18.3.4. Atributos de Visualizacion del Campo

    # As you have seen, in the above example, display attribute for the
    # fields can be set with =set_field_fore()= and
    # =setfield_back()=. These functions set foreground and background
    # attribute of the fields. You can also specify a pad character
    # which will be filled in the unfilled portion of the field. The pad
    # character is set with a call to =set_field_pad()=.  Default pad
    # value is a space. The functions =field_fore()=, =field_back=,
    # =field_pad()= can be used to query the present foreground,
    # background attributes and pad character for the field. The
    # following list gives the usage of functions.
    Como se ha visto, en el ejemplo anterior, se pueden establecer los
    atributos de visualización del campo con =set_field_fore()= y
    =set_field_back()=. Estas funciones establecen el atributo de
    campo para el primer y segundo plano. También puede especificar un
    carácter de relleno que llenará la porción restante del campo. El
    carácter de relleno se establece con una llamada a
    =set_field_pad()=. Este valor por defecto es espacio. Puede
    utilizar las funciones =field_fore()=, =field_back=, =field_pad()=
    para consultar los atributos de relleno, del primer y segundo
    plano. El siguiente listado muestra el uso de estas funciones.

    #+BEGIN_SRC c
      int set_field_fore(FIELD *field,        /* campo a modificar                 */
                         chtype attr);        /* atributo a establecer             */

      chtype field_fore(FIELD *field);        /* campo a consultar                 */
                                              /* devuelve atributo de primer plano */

      int set_field_back(FIELD *field,        /* campo a modificar                 */
                         chtype attr);        /* atributo a establecer             */

      chtype field_back(FIELD *field);        /* campo a consultar                 */
                                              /* devuelve atributo de fondo        */

      int set_field_pad(FIELD *field,         /* campo a modificar                */
                        int pad);             /* caracter de relleno a establecer */

      chtype field_pad(FIELD *field);         /* campo a consultar                */
                                              /* devuelve el caracter de relleno */
    #+END_SRC

    # Though above functions seem quite simple, using colors with
    # =set_field_fore()= may be frustrating in the beginning. Let me
    # first explain about foreground and background attributes of a
    # field. The foreground attribute is associated with the
    # character. That means a character in the field is printed with the
    # attribute you have set with =set_field_fore()=. Background
    # attribute is the attribute used to fill background of field,
    # whether any character is there or not. So what about colors? Since
    # colors are always defined in pairs, what is the right way to
    # display colored fields? Here's an example clarifying color
    # attributes.
    A pesar de que el uso de las funciones anteriores parece bastante
    simple, utilizar de colores con =set_field_fore()= puede ser
    frustrante al principio. Primero dejame explicar acerca de los
    atributos de primer plano y fondo de un campo. El atributo de
    primer plano está asociado con el caracter. Eso significa que un
    carácter en el campo se imprime con el atributo que ha configurado
    con =set_field_fore()=. El atributo de fondo es utilizado para
    llenar el fondo del campo, si algún caracter está allí o
    no. Entonces, ¿qué hay acerca de los colores? Los colores siempre
    se definen en pares, ¿cuál es la manera correcta de mostrar
    colores en los campos? He aquí un ejemplo para aclara el uso de
    atributos de color.

    # *Example 26. Form Attributes example*
    [[file:ncurses_programs/forms/form_attrib.c][*Ejemplo 26. Atributos de Campo*]]

    #+BEGIN_SRC c
      #include <form.h>

      int main(){
        FIELD *field[3];
        FORM  *my_form;
        int ch;

        /* Inicializa curses */
        initscr();
        start_color();
        cbreak();
        noecho();
        keypad(stdscr, TRUE);

        /* Inicializa unos pocos pares de color */
        init_pair(1, COLOR_WHITE, COLOR_BLUE);
        init_pair(2, COLOR_WHITE, COLOR_BLUE);

        /* Inicializa los campos */
        field[0] = new_field(1, 10, 4, 18, 0, 0);
        field[1] = new_field(1, 10, 6, 18, 0, 0);
        field[2] = NULL;

        /* Establece las opciones de campo */
        set_field_fore(field[0], COLOR_PAIR(1));     /* Coloca el campo con el fordo azul  */
        set_field_back(field[0], COLOR_PAIR(2));     /* y el frente blanco (los caracteres */
                                                     /* son impresos en BLANCO             */
        field_opts_off(field[0], O_AUTOSKIP);        /* No ir al siguiente campo cuando    */
                                                     /* este campo se llene por completo   */
        set_field_back(field[1], A_UNDERLINE);
        field_opts_off(field[1], O_AUTOSKIP);

        /* Crea el formulario y lo publica */
        my_form = new_form(field);
        post_form(my_form);
        refresh();

        set_current_field(my_form, field[0]);        /* Establece foco en campo coloreado  */
        mvprintw(4, 10, "Valor 1:");
        mvprintw(6, 10, "Valor 2:");
        mvprintw(LINES - 2, 0, "Utilice las teclas de flecha UP, DOWN para cambiar entre campos");
        refresh();

        /* Ciclo para optener solicitudes del usuario */
        while( (ch = getch()) != KEY_F(1) ){
          switch( ch ){
          case KEY_DOWN:
            /* Ir al siguiente campo */
            form_driver(my_form, REQ_NEXT_FIELD);
            /* Ir al final del buffer actual  */
            /* Deja en el ultimo caracter     */
            form_driver(my_form, REQ_END_LINE);
            break;
          case KEY_UP:
            /* Ir al campo anterior */
            form_driver(my_form, REQ_PREV_FIELD);
            form_driver(my_form, REQ_END_LINE);
            break;
          default:
            /* Si este es un caracter normal, se optiene */
            /* Imprime                                   */
            form_driver(my_form, ch);
            break;
          }
        }

        /* Remueve el formulario y libera la memoria */
        unpost_form(my_form);
        free_form(my_form);
        free_field(field[0]);
        free_field(field[1]);

        endwin();
        return 0;
      }
    #+END_SRC


    # Play with the color pairs and try to understand the foreground and
    # background attributes. In my programs using color attributes, I
    # usually set only the background with =set_field_back()=. curses
    # simply doesn't allow defining individual color attributes.
    Juega con los pares de color y tratar de entender los atributos de
    de fondo y primer plano. En mis programas cuando utilizo atributos
    de color, por lo general estableco sólo el fondo con
    =set_field_back()=. curses simplemente no permite definir
    atributos de color individuales.

# *** 18.3.5. Field Option Bits
*** 18.3.5. Bits de Opcion de Campo

    # There is also a large collection of field option bits you can set to
    # control various aspects of forms processing. You can manipulate them
    # with these functions:
    Hay también una gran colección de bits de opcion de campo que
    puede configurar para controlar varios aspectos al procesar
    formularios. Puede manipularlos con estas funciones:

    #+BEGIN_SRC c
      int set_field_opts(FIELD *field,          /* campo a modificar          */
                         int attr);             /* atributo a establecer      */

      int field_opts_on(FIELD *field,           /* campo a modificar          */
                        int attr);              /* atributo a encender        */

      int field_opts_off(FIELD *field,          /* campo a modificar          */
                         int attr);             /* atributo a apagar          */

      int field_opts(FIELD *field);             /* campo a consultar          */
    #+END_SRC

    # The function =set_field_opts()= can be used to directly set
    # attributes of a field or you can choose to switch a few attributes
    # on and off with =field_opts_on()= and =field_opts_off()=
    # selectively. Anytime you can query the attributes of a field with
    # =field_opts()=. The following is the list of available options. By
    # default, all options are on.
    Puede utilizar la función =set_field_opts()= para establecer
    directamente atributos de un campo o puede optar por
    encender/apagar algunos atributos con =field_opts_on()= y
    =field_opts_off()= . En cualquier momento puede consultar los
    atributos de un campo con =field_opts()=. La siguiente es la lista
    de opciones disponibles. De forma predeterminada, todas las
    opciones están encedidas.

    # - =O_VISIBLE=  :: Controls whether the field is visible on the
    #                   screen.  Can be used during form processing to
    #                   hide or pop up fields depending on the value of
    #                   parent fields.
    - =O_VISIBLE=  :: Controla si el campo es visible en pantalla.
                      Puede ser utilizado al procesar el formulario
                      para ocultar o mostar campos en función del
                      valor de campos padre.

    # - =O_ACTIVE=   :: Controls whether the field is active during
    #                   forms processing (i.e. visited by form
    #                   navigation keys). Can be used to make labels or
    #                   derived fields with buffer values alterable by
    #                   the forms application, not the user.
    - =O_ACTIVE=   :: Controla si el campo está activo durante el
                      procesamiento de formularios (es decir, se puede
                      visitar el formulario con las teclas de
                      navegación). Se puede utilizar para crear
                      etiquetas o campos derivados con valores de
                      buffer modificados por la aplicación, no el
                      usuario.

    # - =O_PUBLIC=   :: Controls whether data is displayed during field
    #                   entry.  If this option is turned off on a field,
    #                   the library will accept and edit data in that
    #                   field, but it will not be displayed and the
    #                   visible field cursor will not move. You can turn
    #                   off the =O_PUBLIC= bit to define password
    #                   fields.
    - =O_PUBLIC=   :: Controla si se muestran los datos durante lo
                      entrada. Si se desactiva esta opción en un
                      campo, la libreria va a aceptar y editar datos
                      en ese campo, pero no se mostrarán y el cursor
                      no se moverá. Puede apagar el bit =O_PUBLIC=
                      para definir campos de contraseña.

    # - =O_EDIT=     :: Controls whether the field's data can be
    #                   modified. When this option is off, all editing
    #                   requests except =REQ_PREV_CHOICE= and
    #                   =REQ_NEXT_CHOICE= will fail. Such read-only
    #                   fields may be useful for help messages.
    - =O_EDIT=     :: Controla si los datos del campo pueden ser
                      modificados. Cuando esta opción está
                      desactivada, fallaran todas las peticiones de
                      edición excepto =REQ_PREV_CHOICE= y
                      =REQ_NEXT_CHOICE=. Estos campos de sólo lectura
                      pueden ser útiles para mensajes de ayuda.

    # - =O_WRAP=     :: Controls word-wrapping in multi-line
    #                   fields. Normally, when any character of a
    #                   (blank-separated) word reaches the end of the
    #                   current line, the entire word is wrapped to the
    #                   next line (assuming there is one). When this
    #                   option is off, the word will be split across the
    #                   line break.
    - =O_WRAP=     :: Controla el ajuste de texto en campos
                      multi-linea. Normalmente, cuando cualquier
                      carácter o (espacio separador) palabra llega al
                      final de la línea actual, se envuelve la palabra
                      entera y salta a la línea siguiente (suponiendo
                      que la hay). Cuando esto opción está
                      desactivada, la palabra se dividirá atraves del
                      salto de línea.

    # - =O_BLANK=    :: Controls field blanking. When this option is on,
    #                   entering a character at the first field position
    #                   erases the entire field (except for the
    #                   just-entered character).
    - =O_BLANK=    :: Controla la suprecion de caracteres. Cuando esta
                      opción está activa, al introducir un carácter en
                      la primera posición del campo se borra todo el
                      campo (excepto el caracter ingresado).

    # - =O_AUTOSKIP= :: Controls automatic skip to next field when this
    #                   one fills. Normally, when the forms user tries
    #                   to type more data into a field than will fit,
    #                   the editing location jumps to next field. When
    #                   this option is off, the user's cursor will hang
    #                   at the end of the field. This option is ignored
    #                   in dynamic fields that have not reached their
    #                   size limit.
    - =O_AUTOSKIP= :: Controla el salto automático al siguiente campo
                      cuando el actual se llena. Normalmente, cuando
                      el usuario trata de ingresar mas datos en un
                      campo hasta llenarlo, la ubicación de edición
                      salta al siguiente campo. Cuando esta opción
                      está desactivada, el cursor cuelga al final del
                      campo. Esta opción se ignora en los campos
                      dinámicos que no han alcanzado su límite de
                      tamaño.

    # - =O_NULLOK=   :: Controls whether validation is applied to blank
    #                   fields.  Normally, it is not; the user can leave
    #                   a field blank without invoking the usual
    #                   validation check ¤on exit. If this option is off
    #                   on a field, exit from it will invoke a
    #                   validation check.
    - =O_NULLOK=   :: Controla si la validación se aplica a campos en
                      blanco. Normalmente, no es asi; el usuario puede
                      dejar un campo en blanco sin invocar la
                      comprobación de validación al salir. Si esta
                      opción está desactivada en un campo, la salida
                      invocará una comprobación de validación.

    # - =O_PASSOK=   :: Controls whether validation occurs on every
    #                   exit, or only after the field is
    #                   modified. Normally the latter is true.  Setting
    #                   =O_PASSOK= may be useful if your field's
    #                   validation function may change during forms
    #                   processing.
    - =O_PASSOK=   :: Controla si la validación ocurre en cada salida,
                      o sólo después de que el campo es
                      modificado. Normalmente es cierto esto
                      último. Ajustar =O_PASSOK= puede ser útil si su
                      funcion de validación puede cambiar durante el
                      tratamiento de formularios.

    # - =O_STATIC=   :: Controls whether the field is fixed to its
    #                   initial dimensions. If you turn this off, the
    #                   field becomes dynamic and will stretch to fit
    #                   entered data.
    - =O_STATIC=   :: Controla si el campo se fija a su dimensiones
                      iniciales. Si se desactiva, el campo se vuelve
                      dinámico y se extiende para adaptarse a los
                      datos introducidos.


    # A field's options cannot be changed while the field is currently
    # selected. However, options may be changed on posted fields that
    # are not current.

    Las opciones de un campo no se puede cambiar mientras el campo se
    encuentra seleccionado. Sin embargo, se pueden cambiar las
    opciones en los demas campos.

    # The option values are bit-masks and can be composed with
    # logical-or in the obvious way. You have seen the usage of
    # switching off =O_AUTOSKIP= option. The following example clarifies
    # usage of some more options.  Other options are explained where
    # appropriate.
    Los valores de las opciones son mascaras de bits y se pueden
    componer con puertas logicas OR de manera obvia. Usted ha visto el
    uso de apagar la opcion =O_AUTOSKIP=. El siguiente ejemplo aclara
    uso de algunas opciones más. Las otras opciones se explicaran
    cuando sea apropiado.

    # *Example 27. Field Options Usage example*
    [[file:ncurses_programs/forms/form_options.c][*Ejemplo 27. Opciones de Campo*]]

    #+BEGIN_SRC c
      #include <form.h>

      #define STARTX 15
      #define STARTY 4
      #define WIDTH 25

      #define N_FIELDS 3

      int main(){
        FIELD *field[N_FIELDS];
        FORM  *my_form;
        int ch, i;

        /* Inicializa curses */
        initscr();
        cbreak();
        noecho();
        keypad(stdscr, TRUE);

        /* Inicializa los campos */
        for(i = 0; i < N_FIELDS - 1; ++i)
          field[i] = new_field(1, WIDTH, STARTY + i * 2, STARTX, 0, 0);
        field[N_FIELDS - 1] = NULL;

        /* Establecer las opciones de campo */
        set_field_back(field[1], A_UNDERLINE);    /* Imprime una linea pora la opcion       */

        field_opts_off(field[0], O_ACTIVE);       /* Este campo es una etiqueta estatica    */
        field_opts_off(field[1], O_PUBLIC);       /* Este es un campo estilo contraseña     */
        field_opts_off(field[1], O_AUTOSKIP);     /* Evita entrar en algun otro campo       */
                                                  /* despues de ingresar el ultimo caracter */

        /* Crea el formulario y lo publica */
        my_form = new_form(field);
        post_form(my_form);
        refresh();

        set_field_just(field[0], JUSTIFY_CENTER); /* Justificar al centro                   */
        set_field_buffer(field[0], 0, "Este es un campo estatico");

        /* Inicializa el campo  */
        mvprintw(STARTY, STARTX - 10, "Campo 1:");
        mvprintw(STARTY + 2, STARTX - 10, "Campo 2:");
        refresh();

        /* Ciclo para optener solicitudes del usuario */
        while( (ch = getch()) != KEY_F(1) ){
          switch( ch ){
          case KEY_DOWN:
            /* Ir al siguiente campo */
            form_driver(my_form, REQ_NEXT_FIELD);
            /* Ir al final del buffer actual */
            /* Deja en el ultimo caracter    */
            form_driver(my_form, REQ_END_LINE);
            break;
          case KEY_UP:
            /* Ir al campo anterior */
            form_driver(my_form, REQ_PREV_FIELD);
            form_driver(my_form, REQ_END_LINE);
            break;
          default:
            /* Si este es un caracter normal, se optiene */
            /* Imprime                                   */
            form_driver(my_form, ch);
            break;
          }
        }

        /* Remueve el formulario y libera la memoria */
        unpost_form(my_form);
        free_form(my_form);
        free_field(field[0]);
        free_field(field[1]);

        endwin();
        return 0;
      }
    #+END_SRC

    # This example, though useless, shows the usage of options. If used
    # properly, they can present information very effectively in a
    # form. The second field being not =O_PUBLIC=, does not show the
    # characters you are typing.
    En este ejemplo, aunque inútil, muestra el uso de opciones. Si se
    usan adecuadamente, puede presentar la información de manera muy
    eficaz. El segundo campo es no =O_PUBLIC=, no muestra los
    caracteres que se están escribiendo.

# *** 18.3.6. Field Status
*** 18.3.6. Estado del Campo

    # The field status specifies whether the field has got edited or
    # not. It is initially set to FALSE and when user enters something
    # and the data buffer gets modified it becomes TRUE. So a field's
    # status can be queried to find out whether it has been modified or
    # not. The following functions can assist in those operations.
    El estado de campo especifica si el campo ha sido editado o
    no. Inicialmente se establece en =FALSE= y cuando el usuario
    escribe algo y los datos del buffer son modificados se convierte
    en =TRUE=. Por lo tanto se puede consultar el estado de un campo
    para saber si se ha modificado o no. Las siguientes funciones
    pueden ayudar a esas operaciones.

    #+BEGIN_SRC c
      int set_field_status(FIELD *field,      /* campo a modificar       */
                           int status);       /* estado a entablecer     */

      int field_status(FIELD *field);         /* obtener estado de campo */
    #+END_SRC

    # It's better to check the field's status only after after leaving
    # the field, as data buffer might not have been updated yet as the
    # validation is still due. To guarantee that right status is
    # returned, call =field_status()= either (1) in the field's exit
    # validation check routine, (2) ¤from the field's or form's
    # initialization or termination hooks, or (3) just after a
    # =REQ_VALIDATION= request has been processed by the forms driver
    Es mejor comprobar el estado de un campo sólo después de salir de
    este, ya que los datos del buffer podrian no haber sido
    actualizados aun, mientras la validacion no se ha teminado. Para
    garantizar que es regresado el estado correcto, llamade a
    =field_status()= ya sea (1) cuando termina la rutina de validacion
    del campo, (2) a partir de la inicializacion o terminacion de los
    campos o formularios, o (3) enseguida de que una solicitud
    =REQ_VALIDATION= ha sido procesada por =form_driver()=.

# *** 18.3.7. Field User Pointer
*** 18.3.7. Puntero de Usuario de Campo

    # Every field structure contains one pointer that can be used by the
    # user for various purposes. It is not touched by forms library and
    # can be used for any purpose by the user. The following functions
    # set and fetch user pointer.
    Cada estructura de campo contiene un puntero que puede ser
    utilizado por el usuario para diversos fines. No es empleado por
    la libreria form y puede ser utilizado por el usuario para
    cualquier propósito. Las siguientes funciones establecen y
    obtienen el puntero del usuario.

    #+BEGIN_SRC c
      int set_field_userptr(FIELD *field,
                            char *userptr);   /* el puntero de usuario que desea asociar */
                                              /* con el campo                            */

      char *field_userptr(FIELD *field);      /* obtener el puntero de usuario del campo */
    #+END_SRC

# *** 18.3.8. Variable-Sized Fields
*** 18.3.8. Campos de Tamaño Variable

    # If you want a dynamically changing field with variable width, this
    # is the feature you want to put to full use. This will allow the
    # user to enter more data than the original size of the field and
    # let the field grow. According to the field orientation it will
    # scroll horizontally or vertically to incorporate the new data.
    Si quiere un campo que cambie su anchura dinámicamente, esta es la
    característica que desea poner a pleno uso. Esto permite que el
    usuario introdusca más datos que el tamaño original del campo y
    deja crecer el campo. De acuerdo con la orientación del campo lo
    hará desplazarse horizontal o verticalmente para incorporar los
    nuevos datos.

    # To make a field dynamically growable, the option =O_STATIC= should
    # be turned off. This can be done with a
    Para obtener un campo con crecimiento dinámico, la debe apagar la
    opción =O_STATIC=. Esto se puede hacer con

    #+BEGIN_SRC c
      field_opts_off(field_pointer, O_STATIC);
    #+END_SRC

    # But it's usually not advisable to allow a field to grow
    # infinitely. You can set a maximum limit to the growth of the field
    # with
    Pero por lo general no es aconsejable permitir a un campo para
    crecer infinitamente. Puede establecer un límite máximo para el
    crecimiento con

    #+BEGIN_SRC c
      int set_max_field(FIELD *field,    /* Campo sabre el cual operar                 */
                        int max_growth); /* Crecimiento maximo permitido para el campo */
    #+END_SRC

    # The field info for a dynamically growable field can be retrieved
    # by
    La informacion de un campo con crecimiento dinamico se puede
    recuperar utilizando

    #+BEGIN_SRC c
      int dynamic_field_info( FIELD *field,     /* campo sobre el cual operar   */
                              int   *prows,     /* numero de filas              */
                              int   *pcols,     /* number de columnas           */
                              int   *pmax)      /* maximo crecimiento permitido */
    #+END_SRC

    # Though =field_info= work as usual, it is advisable to use this
    # function to get the proper attributes of a dynamically growable
    # field.  Recall the library routine =new_field=; a new field
    # created with height set to one will be defined to be a one line
    # field. A new field created with height greater than one will be
    # defined to be a multi line field.
    Aunque =field_info= funciona como de costumbre, es aconsejable
    utilizar esta función para obtener los atributos correctos de un
    campo con crecimiento dinamico. Recordemos la rutina =new_field=
    de libreria; un campo creado con la altura establecida en uno
    define un campo de una sola línea. Un campo creado con una altura
    mayor a uno define un campo de múltiples líneas.

    # A one line field with =O_STATIC= turned off (dynamically growable
    # field) will contain a single fixed row, but the number of columns
    # can increase if the user enters more data than the initial field
    # will hold. The number of columns displayed will remain fixed and
    # the additional data will scroll horizontally.
    Un campo de una línea con =O_STATIC= apagado (campo con
    crecimiento dinamico) contendrá una sola fila fija, pero el número
    de columnas puede aumentar si el usuario introduce más datos que
    los fijados originalmente. El número de columnas mostradas
    permanecerá fijo y los datos adicionales podran desplazarse
    horizontalmente.

    # A multi line field with =O_STATIC= turned off (dynamically
    # growable field) will contain a fixed number of columns, but the
    # number of rows can increase if the user enters more data than the
    # initial field will hold. The number of rows displayed will remain
    # fixed and the additional data will scroll vertically.
    Un campo multilínea con =O_STATIC= apagado (campo con crecimiento
    dinamico) contendrá un número fijo de columnas, pero el número de
    filas puede aumentar si el usuario introduce más datos que los
    fijados originalmnte. El número de filas que se muestra
    permanecerá fijo y los datos adicionales podran desplazarse
    verticalmente.

    # The above two paragraphs pretty much describe a dynamically
    # growable field's behavior. The way other parts of forms library
    # behaves is described below:
    Los dos párrafos anteriores describen más o menos el
    comportamiento de un campo dinamico. La forma en que se comportan
    otras partes de libreria se describen a continuacion:

   # 1. The field option =O_AUTOSKIP= will be ignored if the option
   #    =O_STATIC= is off and there is no maximum growth specified for
   #    the field.  Currently, =O_AUTOSKIP= generates an automatic
   #    =REQ_NEXT_FIELD= form driver request when the user types in the
   #    last character position of a field. On a growable field with no
   #    maximum growth specified, there is no last character
   #    position. If a maximum growth is specified, the =O_AUTOSKIP=
   #    option will work as normal if the field has grown to its maximum
   #    size.
   1. La opción de campo =O_AUTOSKIP= se ignorará si =O_STATIC= está
      apagado y no se ha especificado un crecimiento máxima para el
      campo. Actualmente, =O_AUTOSKIP= genera automaticamente una
      solicitud =REQ_NEXT_FIELD= cuando el usuario escribe sobre la
      posición del ultimo carácter de un campo. En un campo sin
      crecimiento máximo especificado, no hay un último carácter. Si
      se especifica un crecimiento máximo, la opcion =O_AUTOSKIP=
      funcionará de forma normal si el campo ha crecido a su máximo
      tamaño.

   # 2. The field justification will be ignored if the option =O_STATIC=
   #    is off. Currently, =set_field_just= can be used to
   #    =JUSTIFY_LEFT=, =JUSTIFY_RIGHT=, =JUSTIFY_CENTER= the contents
   #    of a one line field. A growable one line field will, by
   #    definition, grow and scroll horizontally and may contain more
   #    data than can be justified. The return from =field_just= will be
   #    unchanged.
   2. Se ignora la justificación de campo si se ha apagado la opción
      =O_STATIC=. Actualmente se puede utilizar, =set_field_just= con
      =JUSTIFY_LEFT=, =JUSTIFY_RIGHT=, =JUSTIFY_CENTER= para los
      contenidos de un campo de una línea. Un campo creciente de una
      linea, por definición, crece y se desplaza horizontalmente y
      puede contener más datos de los que se pueden justificar. El
      retorno de =field_just= será =NO_JUSTIFICATION=.

   # 3. The overloaded form driver request =REQ_NEW_LINE= will operate
   #    the same way regardless of the =O_NL_OVERLOAD= form option if
   #    the field option =O_STATIC= is off and there is no maximum
   #    growth specified for the field. Currently, if the form option
   #    =O_NL_OVERLOAD= is on, =REQ_NEW_LINE= implicitly generates a
   #    =REQ_NEXT_FIELD= if called from the last line of a field. If a
   #    field can grow without bound, there is no last line, so
   #    =REQ_NEW_LINE= will never implicitly generate a
   #    =REQ_NEXT_FIELD=. If a maximum growth limit is specified and the
   #    =O_NL_OVERLOAD= form option is on, =REQ_NEW_LINE= will only
   #    implicitly generate =REQ_NEXT_FIELD= if the field has grown to
   #    its maximum size and the user is on the last line.
   3. Sobrecargar =form_driver= con la solicitud =REQ_NEW_LINE=
      operará de la misma manera independientemente de la opción
      =O_NL_OVERLOAD= si la opción de campo =O_STATIC= está apagada y
      no hay un crecimiento máximo especificado para el campo.
      Actualmente, si la opción =O_NL_OVERLOAD= está encendida,
      =REQ_NEW_LINE= genera implícitamente una solicitud
      =REQ_NEXT_FIELD= si se llama desde la última línea de un
      campo. Si una campo puede crecer sin límite, no hay última
      línea, por lo que =REQ_NEW_LINE= nunca generará implícitamente
      una solicitud =REQ_NEXT_FIELD=. Si se especifica un límite
      máximo de crecimiento y se activa la opcion =O_NL_OVERLOAD=,
      =REQ_NEW_LINE= sólo se generar =REQ_NEXT_FIELD= si el campo ha
      crecido hasta su tamaño máximo y el usuario está en la última
      línea.

   # 4. The library call =dup_field= will work as usual; it will
   #    duplicate the field, including the current buffer size and
   #    contents of the field being duplicated. Any specified maximum
   #    growth will also be duplicated.
   4. La funcion =dup_field= trabajara como de costumbre; duplicara el
      campo, incluyendo el tamaño del búfer actual y el contenido del
      campo. Cualquier crecimiento máximo especificado también se
      duplicará.

   # 5. The library call =link_field= will work as usual; it will
   #    duplicate all field attributes and share buffers with the field
   #    being linked.  If the =O_STATIC= field option is subsequently
   #    changed by a field sharing buffers, how the system reacts to an
   #    attempt to enter more data into the field than the buffer will
   #    currently hold will depend on the setting of the option in the
   #    current field.
   5. La llamada =link_field= funcionará como de costumbre; duplicara
      todos los atributos de campo y compartira buffers con el campo
      enlazado. Si la opcion de campo =O_STATIC= se cambia
      posteriormente por buffers de campo compatidos, la reaccion del
      sistema a un intento de introducir más datos en el campo
      actualmente fijo dependerá de la configuración de la opción en
      el campo actual.

   # 6. The library call =field_info= will work as usual; the variable
   #    nrow will contain the value of the original call to
   #    =new_field=. The user should use =dynamic_field_info=, described
   #    above, to query the current size of the buffer.
   6. La llamada =field_info= funcionará como de costumbre; la
      variable =nrow= contendrá el valor de la llamada original a
      =new_field=. El usuario debe utilizar =dynamic_field_info=,
      descrito anteriormente, para consultar el tamaño actual del
      buffer.


   # Some of the above points make sense only after explaining form
   # driver.  We will be looking into that in next few sections.

   Algunos de los puntos anteriores tienen sentido sólo después de
   explicar =form_driver=. Cosa que buscaremos hacer en próximas
   secciones.

# ** 18.4. Form Windows
** 18.4. Ventanas de Formulario

   # The form windows concept is pretty much similar to menu
   # windows. Every form is associated with a main window and a sub
   # window. The form main window displays any title or border
   # associated or whatever the user wishes. Then the sub window
   # contains all the fields and displays them according to their
   # position. This gives the flexibility of manipulating fancy form
   # displaying very easily.
   El concepto de ventana de formulario es más o menos similar al de
   ventana de menu. Cada formulario está asociada con una ventana
   principal y una sub ventana. La ventana principal del formulario
   muestra cualquier título o borde asociado o lo que sea que desee.
   La sub ventana contiene todos los campos y los muestra en función
   de su posición. Esto le da la flexibilidad de manipular la
   presentacion de los formularios muy fácilmente.

   # Since this is pretty much similar to menu windows, I am providing
   # an example with out much explanation. The functions are similar and
   # they work the same way.
   Dado que esto es muy similar a las ventanas de menu, proporciono un
   ejemplo con una mayor explicación. Las funciones son similares y
   funcionan de la misma manera.

   # *Example 28. Form Windows Example*
   [[file:ncurses_programs/forms/form_win.c][*Ejemplo 28. Ventanas de Formulario*]]

   #+BEGIN_SRC c
     #include <form.h>
     #include <string.h>

     void print_in_middle( WINDOW *win, int starty, int startx,
                           int width, char *string, chtype color );

     int main(){
       FIELD *field[3];
       FORM  *my_form;
       WINDOW *my_form_win;
       int ch, rows, cols;

       /* Inicialiaza curses */
       initscr();
       start_color();
       cbreak();
       noecho();
       keypad( stdscr, TRUE );

       /* Inicializa un par de color */
       init_pair( 1, COLOR_RED, COLOR_BLACK );

       /* Inicializa los campos */
       field[0] = new_field( 1, 10, 6, 1, 0, 0 );
       field[1] = new_field( 1, 10, 8, 1, 0, 0 );
       field[2] = NULL;

       /* Establece las opciones de campo */
       set_field_back( field[0], A_UNDERLINE );
       field_opts_off( field[0], O_AUTOSKIP ); /* No ir al siguiente campo cuando  */
                                               /* este campa se llene por completo */
       set_field_back( field[1], A_UNDERLINE );
       field_opts_off( field[1], O_AUTOSKIP );

       /* Crea el formulario y lo publica */
       my_form = new_form( field );

       /* Calcula el area requerida por el formulario */
       scale_form( my_form, &rows, &cols );

       /* Crea la venta que sera asociada con el formulario */
       my_form_win = newwin( rows + 4, cols + 4, 4, 4 );
       keypad( my_form_win, TRUE );

       /* Establece la ventana principal y la subventana */
       set_form_win( my_form, my_form_win );
       set_form_sub( my_form, derwin( my_form_win, rows, cols, 2, 2 ) );

       /* Imprime un margen alrededor de la ventana principal e imprime el titulo */
       box( my_form_win, 0, 0 );
       print_in_middle( my_form_win, 1, 0, cols + 4, "Mi formulario", COLOR_PAIR(1) );

       post_form( my_form );
       wrefresh( my_form_win );

       mvprintw( LINES - 2, 0, "Utilice las flechas UP, DOWN para cambiar entre campos" );
       refresh();

       /* Ciclo para optener solicitudes del usuario */
       while( (ch = wgetch(my_form_win)) != KEY_F(1) ){
         switch( ch ){
         case KEY_DOWN:
           /* Ir al siguiente campo */
           form_driver(my_form, REQ_NEXT_FIELD);
           /* Ir al final del buffer actual  */
           /* Deja en el ultimo caracter     */
           form_driver(my_form, REQ_END_LINE);
           break;
         case KEY_UP:
           /* Ir al campo anterior */
           form_driver(my_form, REQ_PREV_FIELD);
           form_driver(my_form, REQ_END_LINE);
           break;
         default:
           /* Si este es un caracter normal, se optiene */
           /* Imprime                                   */
           form_driver(my_form, ch);
           break;
         }
       }

       /* Remueve el formulario y lebera la memoria */
       unpost_form(my_form);
       free_form(my_form);
       free_field(field[0]);
       free_field(field[1]);

       endwin();
       return 0;
     }

     void print_in_middle( WINDOW *win, int starty, int startx,
                          int width, char *string, chtype color ){
       int length, x, y;
       float temp;

       if( win == NULL )
         win = stdscr;
       getyx( win, y, x );
       if( startx != 0 )
         x = startx;
       if( starty != 0 )
         y = starty;
       if( width == 0 )
         width = 80;

       length = strlen( string );
       temp = ( width - length )/ 2;
       x = startx + (int)temp;
       wattron( win, color );
       mvwprintw( win, y, x, "%s", string );
       wattroff( win, color );
       refresh();
     }
   #+END_SRC

# ** 18.5. Field Validation
** 18.5. Validación de Campo

   # By default, a field will accept any data input by the user. It is
   # possible to attach validation to the field. Then any attempt by the
   # user to leave the field, while it contains data that doesn't match
   # the validation type will fail. Some validation types also have a
   # character-validity check for each time a character is entered in
   # the field.
   Por defecto, un campo aceptará cualquier entrada de datos por parte
   del usuario. Es posible colocar la validación en el campo. Por
   tanto, fallará cualquier intento por parte del usuario de abandonar
   el campo, mientras este contiene datos que no concuerdan con el
   tipo de validación. Algunos tipos de validación también tienen
   validacion por carácter para verificar cada vez que se introduce un
   carácter en el campo.

   # Validation can be attached to a field with the following function.
   La validación a un campo se pude agregar con la siguiente función.

   #+BEGIN_SRC c
     int set_field_type(FIELD *field,          /* campo a modificar      */
                        FIELDTYPE *ftype,      /* tipo asociado          */
                        ...);                  /* argumentos adicionales */
   #+END_SRC

   # Once set, the validation type for a field can be queried with
   Una vez establecido, el tipo de validación de un campo se puede
   consultar con

   #+BEGIN_SRC c
     FIELDTYPE *field_type(FIELD *field);      /* campo a consultar       */
   #+END_SRC

   # The form driver validates the data in a field only when data is
   # entered by the end-user. Validation does not occur when
   El controlador de formulario valida los datos en un campo solo
   cuando los datos son ingresados por el usuario final. La Validación
   no se produce cuando

   # - the application program changes the field value by calling
   #   =set_field_buffer=.
   - El programa de aplicación cambia el valor del campo llamando a
     =set_field_buffer=.

   # - linked field values are changed indirectly -- by changing the
   #   field to which they are linked
   - Vincular valores de campo y cambiarlos indicertamente --
     cambiando el campo al que está vinculado


   # The following are the pre-defined validation types. You can also
   # specify custom validation, though it's a bit tricky and cumbersome.

   Los siguientes son los tipos de validación predefinidos. También
   puede especificar una validación personalizada, aunque es un poco
   complicado y engorroso.

*** =TYPE_ALPHA=

    # This field type accepts alphabetic data; no blanks, no digits, no
    # special characters (this is checked at character-entry time). It is
    # set up with:
    Este tipo de campo acepta datos alfabéticos; sin espacios, digitos
    o caracteres especiales (esto se comprueba en cada ingreso de
    caracter). Este se crea con:

    #+BEGIN_SRC c
      int set_field_type(FIELD *field,          /* campo a modificar     */
                         TYPE_ALPHA,            /* tipo asociado         */
                         int width);            /* ancho minimo de campo */
    #+END_SRC

    # The width argument sets a minimum width of data. The user has to
    # enter at-least width number of characters before he can leave the
    # field.  Typically you'll want to set this to the field width; if
    # it's greater than the field width, the validation check will always
    # fail. A minimum width of zero makes field completion optional.
    El argumento =width= establece una anchura minima de datos. El
    usuario tiene que ingresar un número de al menos el ancho de
    caracteres antes poder salir del campo. Normalmente, querrá
    establecer esto a la anchura del campo; si es mayor que el ancho
    del campo, la comprobación de validación siempre fallara. Una
    anchura menor a cero crea un campo con terminación opcional.

*** =TYPE_ALNUM=

    # This field type accepts alphabetic data and digits; no blanks, no
    # special characters (this is checked at character-entry time). It is
    # set up with:
    Este tipo de campo acepta datos alfanumericos; sin espacios en
    blanco, ni caracteres especiales (esto se comprueba en cada
    ingreso de caracter). Este se crea con:

    #+BEGIN_SRC c
      int set_field_type(FIELD *field,          /* campo a modificar     */
                         TYPE_ALNUM,            /* tipo asociado         */
                         int width);            /* ancho minimo de campo */
    #+END_SRC

    # The width argument sets a minimum width of data. As with
    # =TYPE_ALPHA=, typically you'll want to set this to the field width;
    # if it's greater than the field width, the validation check will
    # always fail. A minimum width of zero makes field completion
    # optional.
    El argumento =width= establece una anchura mínima de datos. Al
    igual que =TYPE_ALPHA=, normalmente, querrá establecer esto a la
    anchura del campo; si es mayor que el ancho del campo, la
    comprobación de validación siempre fallara. Una anchura menor a
    cero crea un campo con terminación opcional.

*** =TYPE_ENUM=

    # This type allows you to restrict a field's values to be among a
    # specified set of string values (for example, the two-letter postal
    # codes for U.S. states). It is set up with:
    Este tipo le permite restringir los valores de un campo a estar
    entre un conjunto de valores de cadena especifico (por ejemplo, el
    codigo postal de dos letras de los estados de Estados Unidos). Se
    crea con:

    #+BEGIN_SRC c
      int set_field_type(FIELD *field,          /* campo a modificar         */
                         TYPE_ENUM,             /* tipo asociado             */
                         char **valuelist;      /* lista de valores posibles */
                         int checkcase;         /* sensible a mayusculas?    */
                         int checkunique);      /* coincidencia unica?       */
    #+END_SRC

    # The valuelist parameter must point at a NULL-terminated list of
    # valid strings. The checkcase argument, if true, makes comparison
    # with the string case-sensitive.
    El parámetro =valuelist= debe apuntar a una lista de cadenas
    válidas terminada en =NULL=. Si el argumento =checkcase=, es
    verdadero, hace la comparación sensible a mayúsculas y minúsculas.

    # When the user exits a =TYPE_ENUM= field, the validation procedure
    # tries to complete the data in the buffer to a valid entry. If a
    # complete choice string has been entered, it is of course valid. But
    # it is also possible to enter a prefix of a valid string and have it
    # completed for you.
    Cuando el usuario sale de un campo =TYPE_ENUM=, el procedimiento
    de validación intenta completar los datos en el buffer a una
    entrada válida. Si ha ingresado una cadena completa de elección,
    por supuesto es válido. Pero también es posible introducir un
    prefijo de una cadena válido y que se complete para usted.

    # By default, if you enter such a prefix and it matches more than one
    # value in the string list, the prefix will be completed to the first
    # matching value. But the checkunique argument, if true, requires
    # prefix matches to be unique in order to be valid.
    Por defecto, si se introduce un prefijo y coincide con más de un
    valor en la lista de cadenas, el prefijo se completará al primer
    valor coincidente. Pero el argumento =checkunique=, de ser cierto,
    requiere que el prefijo coincida con un unico valor para ser
    válido.

    # The =REQ_NEXT_CHOICE= and =REQ_PREV_CHOICE= input requests can be
    # particularly useful with these fields.
    Las peticiones =REQ_NEXT_CHOICE= y =REQ_PREV_CHOICE= pueden ser
    particularmente útiles con estos campos.

*** =TYPE_INTEGER=

    # This field type accepts an integer. It is set up as follows:
    Este tipo de campo acepta un entero. Se configura de la siguiente
    manera:

    #+BEGIN_SRC c
      int set_field_type(FIELD *field,          /* campo a modificar           */
                         TYPE_INTEGER,          /* tipo asociado               */
                         int padding,           /* precision de relleno a cero */
                         int vmin, int vmax);   /* rango valido                */
    #+END_SRC

    # Valid characters consist of an optional leading minus and
    # digits. The range check is performed on exit. If the range maximum
    # is less than or equal to the minimum, the range is ignored.
    Los caracteres válidos consisten en un menos inicial opcional y
    dígitos. La prueba de rango se realiza a la salida. Si el rango
    máximo es menor o igual al mínimo, se ignora.

    # If the value passes its range check, it is padded with as many
    # leading zero digits as necessary to meet the padding argument.
    Si el valor pasa la prueva de rango, se rellena con ceros a la
    izquierda hasta cumplir con el argumento =padding=.

    # A =TYPE_INTEGER= value buffer can conveniently be interpreted with
    # the C library function atoi(3).
    Un buffer de valor =TYPE_INTEGER= es interpretado convenientemente
    con la funcion de la libreria C atoi(3).

*** =TYPE_NUMERIC=

    # This field type accepts a decimal number. It is set up as follows:
    Este tipo de campo acepta un número decimal. Se configura de la
    siguiente manera:

    #+BEGIN_SRC c
      int set_field_type(FIELD *field,          /* campo a modificar           */
                         TYPE_NUMERIC,          /* tipo asociado               */
                         int padding,           /* procicion de relleno a cero */
                         int vmin, int vmax);   /* rango valido                */
    #+END_SRC

    # Valid characters consist of an optional leading minus and digits.
    # possibly including a decimal point. The range check is performed on
    # exit. If the range maximum is less than or equal to the minimum, the
    # range is ignored.
    Los caracteres válidos consisten en un menos inicial opcional y
    dígitos, posiblemente incluyendo un punto decimal.  La prueba de
    rango se realiza a la salida. Si el rango máximo es menor o igual
    al mínimo, se ignora.

    # If the value passes its range check, it is padded with as many
    # trailing zero digits as necessary to meet the padding argument.
    Si el valor pasa la prueva de rango, se rellena con ceros a la
    izquierda hasta cumplir con el argumento =padding=.

    # A =TYPE_NUMERIC= value buffer can conveniently be interpreted with
    # the C library function atof(3).
    Un buffer de valor =TYPE_NUMERIC= es interpretado convenientemente
    con la funcion de la libreria C atof(3).

*** =TYPE_REGEXP=

    # This field type accepts data matching a regular expression. It is
    # set up as follows:
    Este tipo de campo acepta datos que coincidan con una expresión
    regular. Se configura de la siguiente manera:

    #+BEGIN_SRC c
      int set_field_type(FIELD *field,          /* campo a modificar   */
                         TYPE_REGEXP,           /* tipo asociado       */
                         char *regexp);         /* exprecion a empatar */
    #+END_SRC

    # The syntax for regular expressions is that of regcomp(3). The check
    # for regular-expression match is performed on exit.
    La sintaxis de las expresiones regulares es la de regcomp(3). La
    pueba de coincidencia de la expresión regular se ejecuta a la
    salida.

# ** 18.6. Form Driver: The work horse of the forms system
** 18.6. Controlador del Formulario: El caballo de trabajo del sistema de formularios

   # As in the menu system, =form_driver()= plays a very important role
   # in forms system. All types of requests to forms system should be
   # funneled through =form_driver()=.
   Al igual que en el sistema de menus, =form_driver()= juega un papel
   muy importante en el sistema de formularios. Todos los tipos de
   peticiones al sistema de formularios deben ser canalizado a través
   =form_driver()=.

   #+BEGIN_SRC c
     int form_driver(FORM *form,     /* formulario en el que operar */
                     int request)    /* codigo de solicitud         */
   #+END_SRC

   # As you have seen some of the examples above, you have to be in a
   # loop looking for user input and then decide whether it's a field
   # data or a form request. The form requests are then passed to
   # =form_driver()= to do the work.
   Como se ha visto en ejemplos anteriores, se tiene que estar en un
   bucle en busca de entrada del usuario y luego decidir si se trata
   de una solicitud de campo o una de formulario. Las solicitudes de
   formulario se pasan a =form_driver()= para hacer el trabajo.

   # The requests roughly can be divided into following
   # categories. Different requests and their usage is explained below:
   Se pueden dividir las peticiones aproximadamente en las siguientes
   categorías. Las diferentes solicitudes y su uso se explica a
   continuación:


# *** 18.6.1. Page Navigation Requests
*** 18.6.1. Solicitudes de Navegacion por Pagina

    # These requests cause page-level moves through the form, triggering
    # display of a new form screen. A form can be made of multiple
    # pages. If you have a big form with lot of fields and logical
    # sections, then you can divide the form into pages. The function
    # =set_new_page()= to set a new page at the field specified.
    Estas solicitudes causan que el nivel de página se mueve a través
    de la formulario, lo que provoca la visualización de una pantalla
    nueva de formulario. Una formulario puede estar hecho de múltiples
    páginas. Si tiene una formulario con gran cantidad de campos y
    secciones lógicas, puede dividir el formulario en páginas. La
    función =set_new_page()= para establecer una página nueva en un
    campo especifico.

    #+BEGIN_SRC c
      int set_new_page(FIELD *field,        /* Campo en el cual poner o quitar el salto de pagina */
                       bool new_page_flag); /* debe ser TRUE para colocar el salto                */
    #+END_SRC

    # The following requests allow you to move to different pages
    Las siguientes peticiones le permiten moverse a diferentes páginas

    # - =REQ_NEXT_PAGE= Move to the next form page.
    - =REQ_NEXT_PAGE= mover a la página siguiente.

    # - =REQ_PREV_PAGE= Move to the previous form page.
    - =REQ_PREV_PAGE= mover a la página anterior.

    # - =REQ_FIRST_PAGE= Move to the first form page.
    - =REQ_FIRST_PAGE= mover a la primer página.

    # - =REQ_LAST_PAGE= Move to the last form page.
    - =REQ_LAST_PAGE= mover a la última página.


    # These requests treat the list as cyclic; that is, =REQ_NEXT_PAGE=
    # from the last page goes to the first, and =REQ_PREV_PAGE= from the
    # first page goes to the last.

    Estas solicitudes manejan la lista de forma cíclica; es decir,
    desde la ultima pagina =REQ_NEXT_PAGE= va a la primera, y desde la
    primer pagina =REQ_PREV_PAGE= va a la última.

# *** 18.6.2. Inter-Field Navigation Requests
*** 18.6.2. Solicitudes de Navegación Entre Campos

    # These requests handle navigation between fields on the same page.
    Estas solicitudes manejar la navegación entre los campos de una
    misma página.

    # -  =REQ_NEXT_FIELD= Move to next field.
    - =REQ_NEXT_FIELD= mover al campo siguiente.

    # -  =REQ_PREV_FIELD= Move to previous field.
    - =REQ_PREV_FIELD= mover al campo anterior.

    # -  =REQ_FIRST_FIELD= Move to the first field.
    - =REQ_FIRST_FIELD= mover al primer campo.

    # -  =REQ_LAST_FIELD= Move to the last field.
    - =REQ_LAST_FIELD= Mover al último campo.

    # -  =REQ_SNEXT_FIELD= Move to sorted next field.
    - =REQ_SNEXT_FIELD= Mover al siguiente campo ordenado.

    # -  =REQ_SPREV_FIELD= Move to sorted previous field.
    - =REQ_SPREV_FIELD= Mover al anteriar campo ordenado.

    # -  =REQ_SFIRST_FIELD= Move to the sorted first field.
    - =REQ_SFIRST_FIELD= mover al primer campo ordenado.

    # -  =REQ_SLAST_FIELD= Move to the sorted last field.
    - =REQ_SLAST_FIELD= Mover al último campo ordenado.

    # -  =REQ_LEFT_FIELD= Move left to field.
    - =REQ_LEFT_FIELD= Mover a la izquierda del campo.

    # -  =REQ_RIGHT_FIELD= Move right to field.
    - =REQ_RIGHT_FIELD= Mover a la derecha del campo.

    # -  =REQ_UP_FIELD= Move up to field.
    - =REQ_UP_FIELD= mover hacia arriba un campo.

    # -  =REQ_DOWN_FIELD= Move down to field.
    - =REQ_DOWN_FIELD= mover hacia abajo un campo.

    # These requests treat the list of fields on a page as cyclic; that
    # is, =REQ_NEXT_FIELD= from the last field goes to the first, and
    # =REQ_PREV_FIELD= from the first field goes to the last. The order
    # of the fields for these (and the =REQ_FIRST_FIELD= and
    # =REQ_LAST_FIELD= requests) is simply the order of the field
    # pointers in the form array (as set up by =new_form()= or
    # =set_form_fields()=
    Estas peticiones manejan la lista de campos en una página de forma
    cíclica; ese es decir, desde el ultimo campo =REQ_NEXT_FIELD= va a
    el primero, y desde el primer campo =REQ_PREV_FIELD= va a el
    ultimo. El orden de los campos para estas peticiones (incluidas
    =REQ_FIRST_FIELD= y =REQ_LAST_FIELD=) es simplemente el orden de
    los punteros en el arreglo de formularios (establecido por
    =new_form()= o =set_form_field()=)

    # It is also possible to traverse the fields as if they had been
    # sorted in screen-position order, so the sequence goes
    # left-to-right and top-to-bottom. To do this, use the second group
    # of four sorted-movement requests.
    También es posible recorrer los campos como si hubieran sido
    ordenados deacuerdo a su posicion en pantalla, por lo que la
    secuencia va de izquierda a derecha y de arriba a abajo. Para
    ello, utilice el segundo grupo de cuatro movimientos por orden.

    # Finally, it is possible to move between fields using visual
    # directions up, down, right, and left. To accomplish this, use the
    # third group of four requests. Note, however, that the position of
    # a form for purposes of these requests is its upper-left corner.
    Por último, es posible moverse entre campos utilizando las
    direciones arriba, abajo, derecha, e izquierda. Para lograr esto,
    utilice el tercer grupo de cuatro movimientos. Sin embargo,
    observe que la posición de un formulario a efectos de estas
    peticiones es la esquina superior izquierda.

    # For example, suppose you have a multi-line field B, and two
    # single-line fields A and C on the same line with B, with A to the
    # left of B and C to the right of B. A =REQ_MOVE_RIGHT= from A will
    # go to B only if A, B, and C all share the same first line;
    # otherwise it will skip over B to C.
    Por ejemplo, suponga que tiene un campo B multilinea, y dos campos
    de una sola línea A y C en la misma línea con B, A a la izquierdo
    de B y C a la derecha de B. Desde A =REQ_MOVE_RIGHT= va a B sólo
    si A, B, y C comparten la misma primera línea; de lo contrario,
    saltar a C.

# *** 18.6.3. Intra-Field Navigation Requests
*** 18.6.3. Solicitudes de Navegacion dentro del Campo

    # These requests drive movement of the edit cursor within the
    # currently selected field.
    Estas solicitudes manejan el movimiento de el cursor de edición
    dentro del campo artalmente seleccionado.

    # -  =REQ_NEXT_CHAR= Move to next character.
    - =REQ_NEXT_CHAR= Mover al carácter siguiente.

    # -  =REQ_PREV_CHAR= Move to previous character.
    - =REQ_PREV_CHAR= Mover a carácter anterior.

    # -  =REQ_NEXT_LINE= Move to next line.
    - =REQ_NEXT_LINE= Mover a la línea siguiente.

    # -  =REQ_PREV_LINE= Move to previous line.
    - =REQ_PREV_LINE= Mover a la línea anterior.

    # -  =REQ_NEXT_WORD= Move to next word.
    - =REQ_NEXT_WORD= Mover a la palabra siguiente.

    # -  =REQ_PREV_WORD= Move to previous word.
    - =REQ_PREV_WORD= Mover a la palabra anterior.

    # -  =REQ_BEG_FIELD= Move to beginning of field.
    - =REQ_BEG_FIELD= Mover a inicio del campo.

    # -  =REQ_END_FIELD= Move to end of field.
    - =REQ_END_FIELD= Mover a final del campo.

    # -  =REQ_BEG_LINE= Move to beginning of line.
    - =REQ_BEG_LINE= Mover al incio de línea.

    # -  =REQ_END_LINE= Move to end of line.
    - =REQ_END_LINE= Mover a final de línea.

    # -  =REQ_LEFT_CHAR= Move left in field.
    - =REQ_LEFT_CHAR= Mover a la izquierda en el campo.

    # -  =REQ_RIGHT_CHAR= Move right in field.
    - =REQ_RIGHT_CHAR= Mover a la derecha en el campo.

    # -  =REQ_UP_CHAR= Move up in field.
    - =REQ_UP_CHAR= Mover hacia arriba en el campo.

    # -  =REQ_DOWN_CHAR= Move down in field.
    - =REQ_DOWN_CHAR= Mover hacia abajo en el campo.


    # Each word is separated from the previous and next characters by
    # whitespace. The commands to move to beginning and end of line or
    # ¤field look for the first or last non-pad character in their
    # ranges.

    Cada palabra se separa de los caracteres anteriores y siguientes
    por espacio en blanco. Los comandos para mover al inicio y fin de
    línea o camo buscan el primer o el ultimo caracter que no es de
    relleno en sus rangos.

# *** 18.6.4. Scrolling Requests
*** 18.6.4. Solicitudes de Desplazamiento

    # Fields that are dynamic and have grown and fields explicitly
    # created with offscreen rows are scrollable. One-line fields scroll
    # horizontally; multi-line fields scroll vertically. Most scrolling
    # is triggered by editing and intra-field movement (the library
    # scrolls the field to keep the cursor visible). It is possible to
    # explicitly request scrolling with the following requests:
    Los campos dinámicos y los creados explícitamente con filas fuera
    de pantalla son desplazables. Los campos de una linea se desplazan
    horizontalmente; los campos multilínea verticalmente. La mayoría
    de movimientos se acciona por la edición y el movimiento dentro
    del campo (la libreria desplaza el campo para mantener el cursor
    visible). Es posible solicitar explícitamente el desplazamiento
    con las siguientes solicitudes:

    # -  =REQ_SCR_FLINE= Scroll vertically forward a line.
    - =REQ_SCR_FLINE= Desplazar verticalmente hacia adelante una
      línea.

    # -  =REQ_SCR_BLINE= Scroll vertically backward a line.
    - =REQ_SCR_BLINE= Desplazar verticalmente hacia atrás una línea.

    # -  =REQ_SCR_FPAGE= Scroll vertically forward a page.
    - =REQ_SCR_FPAGE= Desplazar verticalmente hacia adelante una
      página.

    # -  =REQ_SCR_BPAGE= Scroll vertically backward a page.
    - =REQ_SCR_BPAGE= Desplazar verticalmente hacia atrás una página.

    # -  =REQ_SCR_FHPAGE= Scroll vertically forward half a page.
    - =REQ_SCR_FHPAGE= Desplazar verticalmente hacia adelante media
      página.

    # -  =REQ_SCR_BHPAGE= Scroll vertically backward half a page.
    - =REQ_SCR_BHPAGE= Desplazar verticalmente hacia atrás media
      página.

    # -  =REQ_SCR_FCHAR= Scroll horizontally forward a character.
    - =REQ_SCR_FCHAR= Desplazar horizontal hacia adelante un caracter.

    # -  =REQ_SCR_BCHAR= Scroll horizontally backward a character.
    - =REQ_SCR_BCHAR= Desplazar horizontal hacia atrás un caracter.

    # -  =REQ_SCR_HFLINE= Scroll horizontally one field width forward.
    - =REQ_SCR_HFLINE= Desplazar horizontal el ancho de campo hacia
      adelante.

    # -  =REQ_SCR_HBLINE= Scroll horizontally one field width backward.
    - =REQ_SCR_HBLINE= Desplazar horizontal el ancho de campo hacia
      atrás.

    # -  =REQ_SCR_HFHALF= Scroll horizontally one half field width
    #    forward.
    - =REQ_SCR_HFHALF= Desplazar horizontal medio ancho de campo hacia
      adelante.

    # -  =REQ_SCR_HBHALF= Scroll horizontally one half field width
    #    backward.
    - =REQ_SCR_HBHALF= Desplazar horizontal medio ancho de campo hacia
      atras.


    # For scrolling purposes, a page of a field is the height of its
    # visible part.

    A efectos de desplazamiento, la página de un campo es la altura de
    su parte visible.

# *** 18.6.5. Editing Requests
*** 18.6.5. Solicitudes de Edición

    # When you pass the forms driver an ASCII character, it is treated
    # as a request to add the character to the field's data
    # buffer. Whether this is an insertion or a replacement depends on
    # the field's edit mode (insertion is the default.
    Cuando se pasa un caracter ASCII al controlador de formulario, se
    trata como una solicitud para agregar el carácter a buffer de
    datos del campo. Si es un replazo o una inserción depende del modo
    de edición del campo (por defecto es inserción).

    # The following requests support editing the field and changing the
    # edit mode:
    Las siguientes solicitudes apoyan la edicion del campo y cambian
    de modo de edición:

    # - =REQ_INS_MODE= Set insertion mode.
    - =REQ_INS_MODE= Establece modo en inserción.

    # - =REQ_OVL_MODE= Set overlay mode.
    - =REQ_OVL_MODE= Establece modo de superposición.

    # - =REQ_NEW_LINE= New line request (see below for explanation).
    - =REQ_NEW_LINE= Solicita nueva línea (ver más abajo para la
      explicación).

    # - =REQ_INS_CHAR= Insert space at character location.
    - =REQ_INS_CHAR= Insertar espacio en la posicion de carácter.

    # - =REQ_INS_LINE= Insert blank line at character location.
    - =REQ_INS_LINE= Insertar línea en blanco en la posición del
      carácter.

    # - =REQ_DEL_CHAR= Delete character at cursor.
    - =REQ_DEL_CHAR= Eliminar el carácter en el cursor.

    # - =REQ_DEL_PREV= Delete previous word at cursor.
    - =REQ_DEL_PREV= Eliminar palabra anterior al cursor.

    # - =REQ_DEL_LINE= Delete line at cursor.
    - =REQ_DEL_LINE= Eliminar linea en el cursor.

    # - =REQ_DEL_WORD= Delete word at cursor.
    - =REQ_DEL_WORD= Eliminar la palabra en el cursor.

    # - =REQ_CLR_EOL= Clear to end of line.
    - =REQ_CLR_EOL= Borrar hasta el final de la línea.

    # - =REQ_CLR_EOF= Clear to end of field.
    - =REQ_CLR_EOF= Borrar hasta el final del campo.

    # - =REQ_CLR_FIELD= Clear entire field.
    - =REQ_CLR_FIELD= Borrar campo entero.


    # The behavior of the =REQ_NEW_LINE= and =REQ_DEL_PREV= requests is
    # complicated and partly controlled by a pair of forms options. The
    # special cases are triggered when the cursor is at the beginning of
    # a field, or on the last line of the field.
    El comportamiento de las peticiones =REQ_NEW_LINE= y
    =REQ_DEL_PREV= es complicado y en parte controlado por un par de
    opciones del formulario. Los casos especiales se activan cuando el
    cursor se encuentra al inicio o en la última línea del campo.

    # First, we consider =REQ_NEW_LINE=:
    En primer lugar, consideramos =REQ_NEW_LINE=:

    # The normal behavior of =REQ_NEW_LINE= in insert mode is to break
    # the current line at the position of the edit cursor, inserting the
    # portion of the current line after the cursor as a new line
    # following the current and moving the cursor to the beginning of
    # that new line (you may think of this as inserting a newline in the
    # field buffer).
    El comportamiento normal de =REQ_NEW_LINE= en modo de inserción es
    romper la línea actual en la posición del cursor, colocando el
    resto de linea despues del cursor como una nueva línea y moviendo
    el cursor al inicio de la nueva línea (puede pensar en esto como
    la inserción de una nueva línea en el buffer de campo).

    # The normal behavior of =REQ_NEW_LINE= in overlay mode is to clear
    # the current line from the position of the edit cursor to end of
    # line. The cursor is then moved to the beginning of the next line.
    El comportamiento normal de =REQ_NEW_LINE= en el modo de
    superposición es limpiar la línea actual desde la posición del
    cursor al fin de línea. El cursor se mueve entonces hasta el
    inicio de la línea siguiente.

    # However, =REQ_NEW_LINE= at the beginning of a field, or on the
    # last line of a field, instead does a
    # =REQ_NEXT_FIELD=. =O_NL_OVERLOAD= option is off, this special
    # action is disabled.
    Sin embargo, =REQ_NEW_LINE= al incio de un campo, o sobre la
    última línea de un campo, en cambio realiza =REQ_NEXT_FIELD=. Si
    la opcion =O_NL_OVERLOAD= esta desactivada, se desactiva esta
    acción especial.

    # Now, let us consider =REQ_DEL_PREV=:
    Ahora, consideremos =REQ_DEL_PREV=:

    # The normal behavior of =REQ_DEL_PREV= is to delete the previous
    # character. If insert mode is on, and the cursor is at the start of
    # a line, and the text on that line will fit on the previous one, it
    # instead appends the contents of the current line to the previous
    # one and deletes the current line (you may think of this as
    # deleting a newline from the field buffer).
    El comportamiento normal de =REQ_DEL_PREV= es eliminar el caracter
    anterior. Si el modo de inserción está activado, y el cursor se
    encuentra al inicio de una línea, y el texto en esa línea cabe en
    la anterior, se anexa el contenido de la línea actual a la
    anterior y se borra la línea actual (puede pensar en esto como la
    eliminación de un salto de línea del buffer de campo).

    # However, =REQ_DEL_PREV= at the beginning of a field is instead
    # treated as a =REQ_PREV_FIELD=.
    Sin embargo, =REQ_DEL_PREV= al inicio de un campo se trata como
    =REQ_PREV_FIELD=.

    # If the =O_BS_OVERLOAD= option is off, this special action is
    # disabled and the forms driver just returns =E_REQUEST_DENIED=.
    Si la opcion =O_BS_OVERLOAD= está desactivada, se desactiva esta
    acción especial y el controlador devuelve sólo =E_REQUEST_DENIED=.

# *** 18.6.6. Order Requests
*** 18.6.6. Solicitudes de Peticion

    # ¤If the type of your field is ordered, and has associated functions
    # for getting the next and previous values of the type from a given
    # value, there are requests that can fetch that value into the field
    # buffer:
    Si puede solicitar el contenido de un campo, y posse funciones
    asociadas para obtener los valores siguiente y anterior de tipo de
    un valor dado, estas son las solicitudes para obtener este valor
    dentro del buffer del campo:

    # - =REQ_NEXT_CHOICE= ¤Place the successor value of the current value
    #   in the buffer.
    - =REQ_NEXT_CHOICE= Coloca el volor succesor del actual valor en
      el buffer.

    # - =REQ_PREV_CHOICE= ¤Place the predecessor value of the current
    #   value in the buffer.
    - =REQ_PREV_CHOICE= Coloca el valor predecesor del actual valor en
      el buffer.


    # Of the built-in field types, only =TYPE_ENUM= has built-in
    # successor and predecessor functions. When you define a field type
    # of your own (see Custom Validation Types), you can associate our
    # own ordering functions.

    De los tipos de campo incorporados, solamente =TYPE_ENUM= ha
    incorporado funciones de sucesor y predecesor. Cuando define un
    tipo de campo por usted mismo (ver Validacion de Tipos
    Personalizados), puede asociar su propia funciones de peticion.

# *** 18.6.7. Application Commands
*** 18.6.7. Comandos de aplicacion

    # Form requests are represented as integers above the curses value
    # greater than =KEY_MAX= and less than or equal to the constant
    # =MAX_COMMAND=. A value within this range gets ignored by
    # =form_driver()=. So this can be used for any purpose by the
    # application. It can be treated as an application specific action
    # and take corresponding action.
    Las peticiones de formulario se representan como números enteros
    por encima del valor =KEY_MAX= y debajo o igual a la constante
    =MAX_COMMAND=. Un valor dentro de este rango es ignorado por
    =form_driver()=. Así que se puede utilizar para cualquier
    propósito de la aplicacion. Se puede tratar como una acción
    específica de la aplicación y tomar lao accion correspondiente.

# * 19. Tools and Widget Libraries
* 19. Librerias de Widgets y Herramientas

  # Now that you have seen the capabilities of ncurses and its sister
  # libraries, you are rolling your sleeves up and gearing for a project
  # that heavily manipulates screen. But wait.. It can be pretty
  # difficult to write and maintain complex GUI widgets in plain ncurses
  # or even with the additional libraries. There are some ready-to-use
  # tools and widget libraries that can be used instead of writing your
  # own widgets. You can use some of them, get ideas from the code, or
  # even extend them.
  Ahora que usted ha visto las capacidades de ncurses y sus librerias
  hermanas, se esta enrollando las mangas preparandose para un
  proyecto con una fuerte manipulacion de pantalla. Pero espere..
  Puede ser muy difícil escribir y mantener widgets complejos con puro
  ncurses o incluso con las librerias adicionales. Puede utilizar
  algunas librerias de widgets y herramientas listas para usar en
  lugar de escribir su propios widgets. Puede utilizar algunos de
  ellos, obtener ideas a partir del código, o incluso extenderlas.

# ** 19.1. CDK (curses Development Kit)
** 19.1. CDK (Kit de desarrollo de curses)

   # In the author's words
   En palabras del autor

   #+BEGIN_ITALIC
     CDK stands for 'curses Development Kit' and it currently contains
     21 ready to use widgets which facilitate the speedy development
     of full screen curses programs.
   #+END_ITALIC

     CDK significa 'Kit curses Desarrollo' y contiene actualmente
     21 listo para usar los widgets que facilitan el desarrollo rápido
     de pantalla completa curses programas.


   # The kit provides some useful widgets, which can be used in your
   # programs directly. It's pretty well written and the documentation
   # is very good.  The examples in the examples directory can be a good
   # place to start for beginners. The CDK can be downloaded from
   # [[http://invisible-island.net/cdk/]] . Follow the instructions in
   # README file to install it.
   El kit proporciona algunos widgets útiles, que se pueden utilizar en su
   programas directamente. Está muy bien escrito y la documentación
   es muy bueno. Los ejemplos en el directorio de ejemplos pueden ser una buena
   punto de partida para los principiantes. El CDK se puede descargar desde
   [[http://invisible-island.net/cdk/]]. Siga las instrucciones
   Archivo README para instalarlo.


# *** 19.1.1. Widget List

*** 19.1.1. Lista Widget

    # The following is the list of widgets provided with cdk and their
    # description.
    La siguiente es la lista de widgets provista de cdk y su
    descripción.

    #+BEGIN_EXAMPLE
    Widget Type           Quick Description
    ===========================================================================
    Alphalist             Allows a user to select from a list of words, with
                          the ability to narrow the search list by typing in a
                          few characters of the desired word.
    Buttonbox             This creates a multiple button widget.
    Calendar              Creates a little simple calendar widget.
    Dialog                Prompts the user with a message, and the user
                          can pick an answer from the buttons provided.
    Entry                 Allows the user to enter various types of information.
    File Selector         A file selector built from Cdk base widgets. This
                          example shows how to create more complicated widgets
                          using the Cdk widget library.
    Graph                 Draws a graph.
    Histogram             Draws a histogram.
    Item List             Creates a pop up field which allows the user to select
                          one of several choices in a small field. Very useful
                          for things like days of the week or month names.
    Label                 Displays messages in a pop up box, or the label can be
                          considered part of the screen.
    Marquee               Displays a message in a scrolling marquee.
    Matrix                Creates a complex matrix with lots of options.
    Menu                  Creates a pull-down menu interface.
    Multiple Line Entry   A multiple line entry field. Very useful
                          for long fields. (like a description
                          field)
    Radio List            Creates a radio button list.
    Scale                 Creates a numeric scale. Used for allowing a user to
                          pick a numeric value and restrict them to a range of
                          values.
    Scrolling List        Creates a scrolling list/menu list.
    Scrolling Window      Creates a scrolling log file viewer. Can add
                          information into the window while its running.
                          A good widget for displaying the progress of
                          something. (akin to a console window)
    Selection List        Creates a multiple option selection list.
    Slider                Akin to the scale widget, this widget provides a
                          visual slide bar to represent the numeric value.
    Template              Creates a entry field with character sensitive
                          positions. Used for pre-formatted fields like
                          dates and phone numbers.
    Viewer                This is a file/information viewer. Very useful
                          when you need to display loads of information.
    ===========================================================================
    #+END_EXAMPLE

    Tipo Widget Descripción rápida
    ================================================== =========================
    Alphalist Permite al usuario seleccionar entre una lista de palabras, con
                          la capacidad de reducir la lista de búsqueda escribiendo en un
                          caracteres de la palabra deseada.
    ButtonBox Esto crea un widget múltiple botón.
    Calendario Crea un pequeño widget de calendario simple.
    Diálogo solicita al usuario un mensaje, y el usuario
                          puede recoger una respuesta de los botones proporcionados.
    Entrada Permite al usuario introducir varios tipos de información.
    Selector de presentar una selección de archivos integrado de los widgets de base Cdk. Esta
                          ejemplo muestra cómo crear widgets de más complicadas
                          utilizando la librería de widgets CDK.
    Gráfico Dibuja un gráfico.
    Histograma Dibuja un histograma.
    Lista de elementos crea un campo emergente que permite al usuario seleccionar
                          una de las varias opciones en un campo pequeño. Muy útil
                          para cosas como día de la semana o mes nombres.
    Etiqueta Muestra los mensajes en una caja pop-up, o la etiqueta puede ser
                          considerado parte de la pantalla.
    Marquesina Muestra un mensaje en una marquesina de desplazamiento.
    Matrix Crea una matriz compleja con muchas opciones.
    Menu Crea una interfaz de menu desplegable.
    Múltiple Entrada Línea A campo de entrada de varias líneas. Muy útil
                          para los campos largos. (como una descripción
                          campo)
    Lista Radio Crea una lista de botones de radio.
    Escala Crea una escala numérica. Se utiliza para permitir a un usuario
                          elegir un valor numérico y restringirlos a una serie de
                          valores.
    Desplazamiento Listado Crea una lista lista / menu desplegable.
    Desplazamiento Ventana Crea un visor de archivos de registro de desplazamiento. Puede agregar
                          información en la ventana mientras su funcionamiento.
                          Un buen widget de para visualizar el progreso de
                          algo. (similar a una ventana de la consola)
    Lista de selección Crea una lista de selección de opción múltiple.
    Deslizador Akin al widget escala, este widget proporciona una
                          barra deslizante visual para representar el valor numérico.
    Plantilla Crea un campo de entrada con el carácter sensible
                          posiciones. Se utiliza para los campos pre-formateada como
                          fechas y números de teléfono.
    Visor Este es un visor de archivos / información. Muy útil
                          cuando se necesita para mostrar un montón de información.
    ================================================== =========================


    # A few of the widgets are modified by Thomas Dickey in recent
    # versions.
    Algunos de los widgets son modificados por Thomas Dickey en los últimos
    versiones.

# *** 19.1.2. Some Attractive Features
*** 19.1.2. Algunas características atractivas

    # Apart from making our life easier with readily usable widgets, cdk
    # solves one frustrating problem with printing multi colored
    # strings, justified strings elegantly. Special formatting tags can
    # be embedded in the strings which are passed to CDK functions. For
    # Example
    Aparte de hacer nuestra vida más fácil con widgets fácilmente utilizable, cdk
    resuelve un problema frustrante con la impresión Colorido
    cadenas, cuerdas justificadas elegantemente. Etiquetas de formato especiales puede
    ser incrustado en las cuerdas que se transmiten a las funciones de CDK. por
    Ejemplo

    # If the string
    Si la cadena de

    #+BEGIN_EXAMPLE
      "</B/1>This line should have a yellow foreground and a blue
      background.<!1>"
    #+END_EXAMPLE

      "</ B / 1> Esta línea debe tener un primer plano de color amarillo y un azul
      de fondo. <! 1> "

    # given as a parameter to newCDKLabel(), it prints the line with
    # yellow foreground and blue background. There are other tags
    # available for justifying string, embedding special drawing
    # characters etc.. Please refer to the man page =cdk_display(3X)=
    # for details. The man page explains the usage with nice examples.
    dada como parámetro para newCDKLabel(), se imprime la línea con
    primer plano amarillo y fondo azul. Hay otras etiquetas
    disponible para justificar la secuencia, la incrustación especial de giro
    caracteres etc .. Por favor, consulte la página de manual =cdk_display (3X) =
    para detalles. La página del manual explica el uso de ejemplos buenos.

# *** 19.1.3. Conclusion
*** 19.1.3. Conclusión

    # All in all, CDK is a well-written package of widgets, which if
    # used properly can form a strong frame work for developing complex
    # GUI.
    Con todo, CDK es un paquete bien escrito de widgets, que si
    se utiliza correctamente puede formar un fuerte marco de trabajo para el desarrollo de complejos
    GUI.

# ** 19.2. The dialog
** 19.2. El dialogo

   # Long long ago, in September 1994, when few people knew linux, Jeff
   # Tranter wrote an [[http://www2.linuxjournal.com/lj-issues/issue5/2807.html][article]] on dialog in Linux Journal. He starts the
   # article with these words..
   Hace mucho tiempo, mucho tiempo, en septiembre de 1994, cuando pocas personas sabían linux, Jeff
   Tranter escribió un [[http://www2.linuxjournal.com/lj-issues/issue5/2807.html][article]] en diálogo en el Linux Journal. Comienza la
   artículo con estas palabras ..

   #+BEGIN_ITALIC
     Linux is based on the Unix operating system, but also features a
     number of unique and useful kernel features and application
     programs that often go beyond what is available under Unix. One
     little-known gem is "dialog", a utility for creating
     professional-looking dialog boxes from within shell scripts. This
     article presents a tutorial introduction to the dialog utility,
     and shows examples of how and where it can be used
   #+END_ITALIC

     Linux se basa en el sistema operativo Unix, pero también cuenta con una
     número de características únicas y útiles del núcleo y la aplicación
     programas que a menudo van más allá de lo que está disponible en Unix. Uno
     joya poco conocida es "diálogo", una utilidad para crear
     de aspecto profesional cuadros de diálogo desde scripts de shell. Esta
     artículo presenta una introducción tutorial para la utilidad de diálogo,
     y muestra ejemplos de cómo y dónde se puede utilizar

   # As he explains, dialog is a real gem in making professional-looking
   # dialog boxes with ease. It creates a variety of dialog boxes,
   # menus, check lists etc.. It is usually installed by default. If
   # not, you can download it from [[http://invisible-island.net/dialog/][Thomas Dickey]]'s site.
   Como él mismo explica, de diálogo es una verdadera joya en la toma de aspecto profesional
   cuadros de diálogo con facilidad. Crea una variedad de cuadros de diálogo,
   menus, listas de verificación, etc .. Por lo general se instala de forma predeterminada. Si
   no, puede descargarlo desde [[http://invisible-island.net/dialog/][Thomas Dickey]] 's sitio.

   # The above-mentioned article gives a very good overview of its uses
   # and capabilites. The man page has more details. It can be used in
   # variety of situations. One good example is building of linux kernel
   # in text mode.  Linux kernel uses a modified version of dialog
   # tailored for its needs.
   El mencionado artículo da una muy buena descripción de sus usos
   y Capabilites. La página del manual tiene más detalles. Se puede utilizar en
   variedad de situaciones. Un buen ejemplo es la construcción del kernel linux
   en modo texto. Kernel de Linux utiliza una versión modificada del diálogo
   a medida para sus necesidades.

   # dialog was initially designed to be used with shell scripts. If you
   # want to use its functionality in a c program, then you can use
   # libdialog. The documentation regarding this is sparse. Definitive
   # reference is the dialog.h header file which comes with the
   # library. You may need to hack here and there to get the required
   # output. The source is easily customizable. I have used it on a
   # number of occasions by modifying the code.
   diálogo fue inicialmente diseñado para ser utilizado con scripts de shell. si tu
   desee utilizar su funcionalidad en el programa ac, entonces usted puede utilizar
   libdialog. La documentación relativa a esta es escasa. Definitivo
   referencia es el archivo de cabecera dialog.h que viene con el
   libreria. Puede que tenga que cortar aquí y allá para conseguir el necesario
   producción. La fuente es fácilmente personalizable. Lo he usado en un
   número de ocasiones mediante la modificación del código.

# ** 19.3. Perl curses Modules CURSES::FORM and CURSES::WIDGETS
** 19.3. Módulos Perl curses CURSES :: FORMULARIO y curses :: WIDGETS

   # The perl module curses, curses::Form and curses::Widgets give
   # access to curses from perl. If you have curses and basic perl is
   # installed, you can get these modules from [[http://www.cpan.org/modules/01modules.index.html][CPAN All Modules page]].
   # Get the three zipped modules in the curses category. Once installed
   # you can use these modules from perl scripts like any other
   # module. For more information on perl modules see perlmod man
   # page. The above modules come with good documentation and they have
   # some demo scripts to test the functionality. Though the widgets
   # provided are very rudimentary, these modules provide good access to
   # curses library from perl.
   Las curses módulo perl, curses :: Forma y curses :: Reproductores dan
   acceso a las curses de perl. Si usted tiene curses y perl básica es
   instalado, puede obtener estos módulos de [[http://www.cpan.org/modules/01modules.index.html][CPAN página de todos los módulos]].
   Obtener los tres módulos con cremallera en la categoría curses. Una vez instalada
   puede utilizar estos módulos de scripts de Perl como cualquier otro
   módulo. Para obtener más información sobre los módulos de perl ver al hombre perlmod
   página. Los módulos anteriores venir con una buena documentación y tienen
   algunos scripts de demostración para probar la funcionalidad. Aunque los widgets de
   siempre son muy rudimentarios, estos módulos proporcionan un buen acceso a
   curses libreria de perl.

   # Some of my code examples are converted to perl by Anuradha
   # Ratnaweera and they are available in the =perl= directory.
   Algunos de mis ejemplos de código se convierten en perl por Anuradha
   Ratnaweera y están disponibles en el perl =directorio.

   # For more information see man pages curses(3) , curses::Form(3) and
   # curses::Widgets(3). These pages are installed only when the above
   # modules are acquired and installed.
   Para obtener más información, consulte las páginas de manual curses (3), Maldice :: Formulario (3) y
   curses :: Widgets (3). Se instalan estas páginas sólo cuando la anterior
   módulos se adquieren y se instalan.

# * 20. Just For Fun !!!
* 20. Just For Fun !!!

  # This section contains few programs written by me just for fun. They
  # don't signify a better programming practice or the best way of using
  # ncurses. They are provided here so as to allow beginners to get
  # ideas and add more programs to this section. If you have written a
  # couple of nice, simple programs in curses and want them to included
  # here, contact [[mailto:ppadala@gmail.com][me]].
  Esta sección contiene algunos programas escritos por mí sólo por diversión. Ellos
  no significan una mejor práctica de programación o la mejor manera de utilizar
  ncurses. Se proporcionan aquí a fin de permitir que los principiantes a obtener
  Ideas y añaden más programas de esta sección. Si usted ha escrito un
  par de buenos programas, simple en las curses y los quieren incluido
  aquí, el contacto [[mailto: ppadala@gmail.com] [me]].

# ** 20.1. The Game of Life
** 20.1. El juego de la vida

   # Game of life is a wonder of math. In [[http://www.math.com/students/wonders/life/life.html][Paul Callahan]]'s words
   Juego de la vida es una maravilla de la matemáticas. En [[http://www.math.com/students/wonders/life/life.html][Paul Callahan]] 's palabras

   #+BEGIN_EXAMPLE
     The Game of Life (or simply Life) is not a game in the conventional sense. There
     are no players, and no winning or losing. Once the "pieces" are placed in the
     starting position, the rules determine everything that happens later.
     Nevertheless, Life is full of surprises! In most cases, it is impossible to look
     at a starting position (or pattern) and see what will happen in the future. The
     only way to find out is to follow the rules of the game.
   #+END_EXAMPLE

     El juego de la vida (o simplemente la vida) no es un juego en el sentido convencional. Ya está
     hay jugadores, y no ganar o perder. Una vez que las "piezas" se colocan en el
     posición inicial, las reglas determinan todo lo que sucede después.
     Sin embargo, la vida está llena de sorpresas! En la mayoría de los casos, es imposible mirar
     en una posición de partida (o patrón) y ver lo que sucederá en el futuro. los
     única manera de averiguarlo es seguir las reglas del juego.

   # This program starts with a simple inverted U pattern and shows how
   # wonderful life works. There is a lot of room for improvement in the
   # program. You can let the user enter pattern of his choice or even
   # take input from a file. You can also change rules and play with a
   # lot of variations. Search on [[http://www.google.com][google]] for interesting information on
   # game of life.
   Este programa comienza con un simple patrón de U invertida y muestra cómo
   maravillosa vida funciona. Hay mucho margen de mejora en el
   programa. Puede dejar que el usuario introduzca el patrón de su elección o incluso
   obtener información de un archivo. También puede cambiar las reglas y jugar con un
   gran cantidad de variaciones. Buscar en el [[http://www.google.com] [google]] para obtener información interesante sobre
   juego de vida.

   # /File Path: JustForFun/life.c/
   / Ruta del archivo: JustForFun / life.c /

# ** 20.2. Magic Square
** 20.2. Cuadrado Mágico

   # Magic Square, another wonder of math, is very simple to understand
   # but very difficult to make. In a magic square sum of the numbers in
   # each row, each column is equal. Even diagnol sum can be
   # equal. There are many variations which have special properties.
   Cuadrado Mágico, otra maravilla de matemáticas, es muy sencillo de entender
   pero muy difícil de hacer. En una suma cuadrado mágico de los números en
   cada fila, cada columna es igual. Incluso suma puede ser diagnol
   igual. Hay muchas variaciones que tienen propiedades especiales.

   # This program creates a simple magic square of odd order.
   Este programa crea un sencillo cuadrado mágico de orden impar.

   # /File Path: JustForFun/magic.c/
   / Ruta del archivo: JustForFun / magic.c /

# ** 20.3. Towers of Hanoi
** 20.3. Torres de Hanoi

   # The famous towers of hanoi solver. The aim of the game is to move
   # the disks on the first peg to last peg, using middle peg as a
   # temporary stay. The catch is not to place a larger disk over a
   # small disk at any time.
   Las famosas torres de hanoi solucionador. El objetivo del juego es mover
   los discos del primero al último peg peg, utilizando paridad central como
   estancia temporal. La captura no es colocar un disco más grande sobre un
   pequeño disco en cualquier momento.

   # /File Path: JustForFun/hanoi.c/
   / Ruta del archivo: JustForFun / hanoi.c /

# ** 20.4. Queens Puzzle
** 20.4. Queens Puzzle

   # The objective of the famous N-Queen puzzle is to put N queens on a
   # N X N chess board without attacking each other.
   El objetivo del famoso rompecabezas N-reina es poner N reinas en un
   N X N tablero de ajedrez sin atacarse unos a otros.

   # This program solves it with a simple backtracking technique.
   Este programa resuelve con una técnica de retroceso simple.

   # /File Path: JustForFun/queens.c/
   / Ruta del archivo: JustForFun / queens.c /

# ** 20.5. Shuffle
** 20.5. Barajar

   # A fun game, if you have time to kill.
   Un juego divertido, si tienes tiempo para matar.

   # /File Path: JustForFun/shuffle.c/
   / Ruta del archivo: JustForFun / barajar.c /

# ** 20.6. Typing Tutor
** 20.6. Typing Tutor

   # A simple typing tutor, I created more out of need than for ease of
   # use.  If you know how to put your fingers correctly on the
   # keyboard, but lack practice, this can be helpful.
   Un tutor de mecanografía simple, he creado más por necesidad que por la facilidad de
   usar. Si usted sabe cómo colocar los dedos correctamente en el
   teclado, pero la práctica la falta, esto puede ser útil.

   # /File Path: JustForFun/tt.c/
   / Ruta del archivo: JustForFun / tt.c /

# * 21. References
* 21. Referencias

  # - NCURSES man pages
  - Páginas man ncurses

  # - NCURSES FAQ at
  #   [[http://invisible-island.net/ncurses/ncurses.faq.html]]
  - Ncurses preguntas frecuentes en
    [[http://invisible-island.net/ncurses/ncurses.faq.html]]

  # - Writing programs with NCURSES by Eric Raymond and Zeyd M. Ben-Halim
  #   at [[http://invisible-island.net/ncurses/ncurses-intro.html]] -
  #   somewhat obsolete. I was inspired by this document and the structure
  #   of this HOWTO follows from the original document
  - Programas de escritura con Ncurses por Eric Raymond y Said M. Ben-Halim
    en [[http://invisible-island.net/ncurses/ncurses-intro.html]] -
    algo obsoleto. Me inspiré en este documento y la estructura
    de este COMO sigue del documento original
