<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>NCURSES Programming HOWTO</title>
<!-- 2015-12-18 vie 17:34 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="ppadala" />
<link rel="stylesheet" type="text/css" href="worg-data/worg.css" /
</head>
<body>
<div id="content">
<h1 class="title">NCURSES Programming HOWTO</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Revision History</a></li>
<li><a href="#sec-2">1. Introduction</a>
<ul>
<li><a href="#sec-2-1">1.1. What is NCURSES?</a></li>
<li><a href="#sec-2-2">1.2. What we can do with NCURSES</a></li>
<li><a href="#sec-2-3">1.3. Where to get it</a>
<ul>
<li><a href="#sec-2-3-1"><i>Compiling the package</i></a></li>
<li><a href="#sec-2-3-2"><i>Using the RPM</i></a></li>
</ul>
</li>
<li><a href="#sec-2-4">1.4. Purpose/Scope of the document</a></li>
<li><a href="#sec-2-5">1.5. About the Programs</a></li>
<li><a href="#sec-2-6">1.6. Other Formats of the document</a>
<ul>
<li><a href="#sec-2-6-1">1.6.1. Readily available formats from tldp.org</a></li>
<li><a href="#sec-2-6-2">1.6.2. Building from source</a></li>
</ul>
</li>
<li><a href="#sec-2-7">1.7. Credits</a></li>
<li><a href="#sec-2-8">1.8. Wish List</a></li>
<li><a href="#sec-2-9">1.9. Copyright</a></li>
</ul>
</li>
<li><a href="#sec-3">2. Hello World !!!</a>
<ul>
<li><a href="#sec-3-1">2.1. Compiling With the NCURSES Library</a></li>
<li><a href="#sec-3-2">2.2. Dissection</a>
<ul>
<li><a href="#sec-3-2-1">2.2.1. About initscr()</a></li>
<li><a href="#sec-3-2-2">2.2.2. The mysterious refresh()</a></li>
<li><a href="#sec-3-2-3">2.2.3. About endwin()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">3. The Gory Details</a></li>
<li><a href="#sec-5">4. Initialization                                                   </a>
<ul>
<li><a href="#sec-5-1">4.1. Initialization functions</a>
<ul>
<li><a href="#sec-5-1-1">4.1.1. <code>raw()</code> and <code>cbreak()</code></a></li>
<li><a href="#sec-5-1-2">4.1.2. <code>echo()</code> and <code>noecho()</code></a></li>
<li><a href="#sec-5-1-3">4.1.3. <code>keypad()</code></a></li>
<li><a href="#sec-5-1-4">4.1.4. <code>halfdelay()</code></a></li>
</ul>
</li>
<li><a href="#sec-5-2">4.2. Miscellaneous Initialization functions</a></li>
<li><a href="#sec-5-3">4.3. An Example</a></li>
</ul>
</li>
<li><a href="#sec-6">5. A Word about Windows</a></li>
<li><a href="#sec-7">6. Output functions</a>
<ul>
<li><a href="#sec-7-1">6.1. <code>addch()</code> class of functions</a></li>
<li><a href="#sec-7-2">6.2. <code>mvaddch()</code>, <code>waddch()</code> and <code>mvwaddch()</code></a></li>
<li><a href="#sec-7-3">6.3. <code>printw()</code> class of functions</a>
<ul>
<li><a href="#sec-7-3-1">6.3.1. <code>printw()</code> and <code>mvprintw</code></a></li>
<li><a href="#sec-7-3-2">6.3.2. <code>wprintw()</code> and <code>mvwprintw</code></a></li>
<li><a href="#sec-7-3-3">6.3.3. <code>vwprintw()</code></a></li>
<li><a href="#sec-7-3-4">6.3.4. A Simple printw example</a></li>
</ul>
</li>
<li><a href="#sec-7-4">6.4. <code>addstr()</code> class of functions</a></li>
<li><a href="#sec-7-5">6.5. A word of caution</a></li>
</ul>
</li>
<li><a href="#sec-8">7. Input functions</a>
<ul>
<li><a href="#sec-8-1">7.1. <code>getch()</code> class of functions</a></li>
<li><a href="#sec-8-2">7.2. <code>scanw()</code> class of functions</a>
<ul>
<li><a href="#sec-8-2-1">7.2.1. <code>scanw()</code> and <code>mvscanw</code></a></li>
<li><a href="#sec-8-2-2">7.2.2. <code>wscanw()</code> and <code>mvwscanw()</code></a></li>
<li><a href="#sec-8-2-3">7.2.3. <code>vwscanw()</code></a></li>
</ul>
</li>
<li><a href="#sec-8-3">7.3. <code>getstr()</code> class of functions</a></li>
<li><a href="#sec-8-4">7.4. Some examples</a></li>
</ul>
</li>
<li><a href="#sec-9">8. Attributes                                                       </a>
<ul>
<li><a href="#sec-9-1">8.1. The details</a></li>
<li><a href="#sec-9-2">8.2. <code>attron()</code> vs <code>attrset()</code></a></li>
<li><a href="#sec-9-3">8.3. <code>attr_get()</code></a></li>
<li><a href="#sec-9-4">8.4. <code>attr_</code> functions</a></li>
<li><a href="#sec-9-5">8.5. <code>wattr</code> functions</a></li>
<li><a href="#sec-9-6">8.6. <code>chgat()</code> functions</a></li>
</ul>
</li>
<li><a href="#sec-10">9. Windows                                                          </a>
<ul>
<li><a href="#sec-10-1">9.1. The basics</a></li>
<li><a href="#sec-10-2">9.2. Let there be a Window !!!</a></li>
<li><a href="#sec-10-3">9.3. Explanation</a></li>
<li><a href="#sec-10-4">9.4. The other stuff in the example</a></li>
<li><a href="#sec-10-5">9.5. Other Border functions</a></li>
</ul>
</li>
<li><a href="#sec-11">10. Colors                                                          </a>
<ul>
<li><a href="#sec-11-1">10.1. The basics</a></li>
<li><a href="#sec-11-2">10.2. Changing Color Definitions</a></li>
<li><a href="#sec-11-3">10.3. Color Content</a></li>
</ul>
</li>
<li><a href="#sec-12">11. Interfacing with the key board                                  </a>
<ul>
<li><a href="#sec-12-1">11.1. The Basics</a></li>
<li><a href="#sec-12-2">11.2. A Simple Key Usage example</a></li>
</ul>
</li>
<li><a href="#sec-13">12. Interfacing with the mouse</a>
<ul>
<li><a href="#sec-13-1">12.1. The Basics</a></li>
<li><a href="#sec-13-2">12.2. Getting the events</a></li>
<li><a href="#sec-13-3">12.3. Putting it all Together</a></li>
<li><a href="#sec-13-4">12.4. Miscellaneous Functions</a></li>
</ul>
</li>
<li><a href="#sec-14">13. Screen Manipulation</a>
<ul>
<li><a href="#sec-14-1">13.1. <code>getyx()</code> functions</a></li>
<li><a href="#sec-14-2">13.2. Screen Dumping</a></li>
<li><a href="#sec-14-3">13.3. Window Dumping</a></li>
</ul>
</li>
<li><a href="#sec-15">14. Miscellaneous features</a>
<ul>
<li><a href="#sec-15-1">14.1. <code>curs_set()</code></a></li>
<li><a href="#sec-15-2">14.2. Temporarily Leaving Curses mode</a></li>
<li><a href="#sec-15-3">14.3. <code>ACS_</code> variables</a></li>
</ul>
</li>
<li><a href="#sec-16">15. Other libraries</a></li>
<li><a href="#sec-17">16. Panel Library</a>
<ul>
<li><a href="#sec-17-1">16.1. The Basics</a></li>
<li><a href="#sec-17-2">16.2. Compiling With the Panels Library</a></li>
<li><a href="#sec-17-3">16.3. Panel Window Browsing</a></li>
<li><a href="#sec-17-4">16.4. Using User Pointers</a></li>
<li><a href="#sec-17-5">16.5. Moving and Resizing Panels</a></li>
<li><a href="#sec-17-6">16.6. Hiding and Showing Panels</a></li>
<li><a href="#sec-17-7">16.7. <code>panel_above()</code> and <code>panel_below()</code> Functions</a></li>
</ul>
</li>
<li><a href="#sec-18">17. Menus Library</a>
<ul>
<li><a href="#sec-18-1">17.1. The Basics</a></li>
<li><a href="#sec-18-2">17.2. Compiling With the Menu Library</a></li>
<li><a href="#sec-18-3">17.3. Menu Driver: The work horse of the menu system</a></li>
<li><a href="#sec-18-4">17.4. Menu Windows</a></li>
<li><a href="#sec-18-5">17.5. Scrolling Menus</a></li>
<li><a href="#sec-18-6">17.6. Multi Columnar Menus</a></li>
<li><a href="#sec-18-7">17.7. Multi Valued Menus</a></li>
<li><a href="#sec-18-8">17.8. Menu Options</a></li>
<li><a href="#sec-18-9">17.9. The useful User Pointer</a></li>
</ul>
</li>
<li><a href="#sec-19">18. Forms Library</a>
<ul>
<li><a href="#sec-19-1">18.1. The Basics</a></li>
<li><a href="#sec-19-2">18.2. Compiling With the Forms Library</a></li>
<li><a href="#sec-19-3">18.3. Playing with Fields</a>
<ul>
<li><a href="#sec-19-3-1">18.3.1. Fetching Size and Location of Field</a></li>
<li><a href="#sec-19-3-2">18.3.2. Moving the field</a></li>
<li><a href="#sec-19-3-3">18.3.3. Field Justification</a></li>
<li><a href="#sec-19-3-4">18.3.4. Field Display Attributes</a></li>
<li><a href="#sec-19-3-5">18.3.5. Field Option Bits</a></li>
<li><a href="#sec-19-3-6">18.3.6. Field Status</a></li>
<li><a href="#sec-19-3-7">18.3.7. Field User Pointer</a></li>
<li><a href="#sec-19-3-8">18.3.8. Variable-Sized Fields</a></li>
</ul>
</li>
<li><a href="#sec-19-4">18.4. Form Windows</a></li>
<li><a href="#sec-19-5">18.5. Field Validation</a></li>
</ul>
</li>
<li><a href="#sec-20"><code>TYPE_ALPHA</code></a></li>
<li><a href="#sec-21"><code>TYPE_ALNUM</code></a></li>
<li><a href="#sec-22"><code>TYPE_ENUM</code></a></li>
<li><a href="#sec-23"><code>TYPE_INTEGER</code></a></li>
<li><a href="#sec-24"><code>TYPE_NUMERIC</code></a></li>
<li><a href="#sec-25"><code>TYPE_REGEXP</code></a>
<ul>
<li><a href="#sec-25-1">18.6. Form Driver: The work horse of the forms system</a>
<ul>
<li><a href="#sec-25-1-1">18.6.1. Page Navigation Requests</a></li>
<li><a href="#sec-25-1-2">18.6.2. Inter-Field Navigation Requests</a></li>
<li><a href="#sec-25-1-3">18.6.3. Intra-Field Navigation Requests</a></li>
<li><a href="#sec-25-1-4">18.6.4. Scrolling Requests</a></li>
<li><a href="#sec-25-1-5">18.6.5. Editing Requests</a></li>
<li><a href="#sec-25-1-6">18.6.6. Order Requests</a></li>
<li><a href="#sec-25-1-7">18.6.7. Application Commands</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-26">19. Tools and Widget Libraries</a>
<ul>
<li><a href="#sec-26-1">19.1. CDK (Curses Development Kit)</a>
<ul>
<li><a href="#sec-26-1-1">19.1.1. Widget List</a></li>
<li><a href="#sec-26-1-2">19.1.2. Some Attractive Features</a></li>
<li><a href="#sec-26-1-3">19.1.3. Conclusion</a></li>
</ul>
</li>
<li><a href="#sec-26-2">19.2. The dialog</a></li>
<li><a href="#sec-26-3">19.3. Perl Curses Modules CURSES::FORM and CURSES::WIDGETS</a></li>
</ul>
</li>
<li><a href="#sec-27">20. Just For Fun !!!</a>
<ul>
<li><a href="#sec-27-1">20.1. The Game of Life</a></li>
<li><a href="#sec-27-2">20.2. Magic Square</a></li>
<li><a href="#sec-27-3">20.3. Towers of Hanoi</a></li>
<li><a href="#sec-27-4">20.4. Queens Puzzle</a></li>
<li><a href="#sec-27-5">20.5. Shuffle</a></li>
<li><a href="#sec-27-6">20.6. Typing Tutor</a></li>
</ul>
</li>
<li><a href="#sec-28">21. References</a></li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Revision History</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Revision 1.9     2005-06-20   Revised by: ppadala

<p>
The license has been changed to the MIT-style license used by
NCURSES. Note that the programs are also re-licensed under this.
</p>
</li>

<li>Revision 1.8     2005-06-17   Revised by: ppadala

<p>
Lots of updates. Added references and perl examples. Changes to
examples. Many grammatical and stylistic changes to the
content. Changes to NCURSES history.
</p>
</li>

<li>Revision 1.7.1   2002-06-25   Revised by: ppadala

<p>
Added a README file for building and instructions for building
from source.
</p>
</li>

<li>Revision 1.7     2002-06-25   Revised by: ppadala

<p>
Added "Other formats" section and made a lot of fancy changes to
the programs. Inlining of programs is gone.
</p>
</li>

<li>Revision 1.6.1   2002-02-24   Revised by: ppadala

<p>
Removed the old Changelog section, cleaned the makefiles
</p>
</li>

<li>Revision 1.6     2002-02-16   Revised by: ppadala

<p>
Corrected a lot of spelling mistakes, added ACS variables section
</p>
</li>

<li>Revision 1.5     2002-01-05   Revised by: ppadala

<p>
Changed structure to present proper TOC
</p>
</li>

<li>Revision 1.3.1   2001-07-26   Revised by: ppadala

<p>
Corrected maintainers paragraph, Corrected stable release number
</p>
</li>

<li>Revision 1.3     2001-07-24   Revised by: ppadala

<p>
Added copyright notices to main document (LDP license) and
programs (GPL), Corrected <code>printw_example</code>.
</p>
</li>

<li>Revision 1.2     2001-06-05   Revised by: ppadala

<p>
Incorporated ravi's changes. Mainly to introduction, menu, form,
justforfun sections
</p>
</li>

<li>Revision 1.1     2001-05-22   Revised by: ppadala

<p>
Added "a word about window" section, Added <code>scanw_example</code>.
</p>
</li>
</ul>


<div class="italic">
<p>
This document is intended to be an "All in One" guide for
programming with ncurses and its sister libraries. We graduate
from a simple "Hello World" program to more complex form
manipulation. No prior experience in ncurses is assumed. Send
comments to <a href="mailto:ppadala@gmail.com">this address</a>
</p>

</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">1. Introduction</h2>
<div class="outline-text-2" id="text-2">
<p>
In the olden days of teletype terminals, terminals were away from
computers and were connected to them through serial cables. The
terminals could be configured by sending a series of bytes. All the
capabilities (such as moving the cursor to a new location, erasing
part of the screen, scrolling the screen, changing modes etc.) of
terminals could be accessed through these series of bytes. These
control sequences are usually called escape sequences, because they
start with an escape(0x1B) character. Even today, with proper
emulation, we can send escape sequences to the emulator and achieve
the same effect on a terminal window.
</p>

<p>
Suppose you wanted to print a line in color. Try typing this on your
console.
</p>

<div class="org-src-container">

<pre class="src src-sh">echo "^[[0;31;40mIn Color"
</pre>
</div>

<p>
The first character is an escape character, which looks like two
characters <code>^</code> and <code>[</code>. To be able to print it, you have to press
CTRL+V and then the ESC key. All the others are normal printable
characters.  You should be able to see the string "In Color" in
red. It stays that way and to revert back to the original mode type
this.
</p>

<div class="org-src-container">

<pre class="src src-sh">echo "^[[0;37;40m"
</pre>
</div>

<p>
Now, what do these magic characters mean? Difficult to comprehend?
They might even be different for different terminals. So the
designers of UNIX invented a mechanism named <code>termcap</code>. It is a file
that lists all the capabilities of a particular terminal, along with
the escape sequences needed to achieve a particular effect. In the
later years, this was replaced by <code>terminfo</code>. Without delving too
much into details, this mechanism allows application programs to
query the terminfo database and obtain the control characters to be
sent to a terminal or terminal emulator.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1.1. What is NCURSES?</h3>
<div class="outline-text-3" id="text-2-1">
<p>
You might be wondering, what the import of all this technical
gibberish is. In the above scenario, every application program is
supposed to query the terminfo and perform the necessary stuff
(sending control characters etc.). It soon became difficult to
manage this complexity and this gave birth to 'CURSES'. Curses is a
pun on the name "cursor optimization". The Curses library forms a
wrapper over working with raw terminal codes, and provides highly
flexible and efficient API (Application Programming Interface). It
provides functions to move the cursor, create windows, produce
colors, play with mouse etc. The application programs need not
worry about the underlying terminal capabilities.
</p>

<p>
So what is NCURSES? NCURSES is a clone of the original System V
Release 4.0 (SVr4) curses. It is a freely distributable library,
fully compatible with older version of curses. In short, it is a
library of functions that manages an application's display on
character-cell terminals. In the remainder of the document, the
terms curses and ncurses are used interchangeably.
</p>

<p>
A detailed history of NCURSES can be found in the NEWS file from
the source distribution. The current package is maintained by
<a href="mailto:dickey@his.com">Thomas Dickey</a>. You can contact the maintainers at
<a href="mailto:bug-ncurses@gnu.org">bug-ncurses@gnu.org</a>.
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">1.2. What we can do with NCURSES</h3>
<div class="outline-text-3" id="text-2-2">
<p>
NCURSES not only creates a wrapper over terminal capabilities, but
also gives a robust framework to create nice looking UI (User
Interface)s in text mode. It provides functions to create windows
etc. Its sister libraries panel, menu and form provide an extension
to the basic curses library. These libraries usually come along
with curses. One can create applications that contain multiple
windows, menus, panels and forms.  Windows can be managed
independently, can provide 'scrollability' and even can be hidden.
</p>

<p>
Menus provide the user with an easy command selection option. Forms
allow the creation of easy-to-use data entry and display
windows. Panels extend the capabilities of ncurses to deal with
overlapping and stacked windows.
</p>

<p>
These are just some of the basic things we can do with ncurses. As
we move along, We will see all the capabilities of these libraries.
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">1.3. Where to get it</h3>
<div class="outline-text-3" id="text-2-3">
<p>
All right, now that you know what you can do with ncurses, you must
be rearing to get started. NCURSES is usually shipped with your
installation. In case you don't have the library or want to compile
it on your own, read on.
</p>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><i>Compiling the package</i></h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
NCURSES can be obtained from
<a href="ftp://ftp.gnu.org/pub/gnu/ncurses/ncurses.tar.gz">ftp://ftp.gnu.org/pub/gnu/ncurses/ncurses.tar.gz</a> or any of the ftp
sites mentioned in <a href="http://www.gnu.org/order/ftp.html">http://www.gnu.org/order/ftp.html</a>.
</p>

<p>
Read the README and INSTALL files for details on to how to install
it.  It usually involves the following operations.
</p>

<div class="org-src-container">

<pre class="src src-sh">tar zxvf ncurses&lt;version&gt;.tar.gz  # unzip and untar the archive
cd ncurses&lt;version&gt;               # cd to the directory
./configure                             # configure the build according to your
                                        # environment
make                                    # make it
su root                                 # become root
make install                            # install it
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><i>Using the RPM</i></h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
NCURSES RPM can be found and downloaded from <a href="http://rpmfind.net">http://rpmfind.net</a>.
The RPM can be installed with the following command after becoming
root.
</p>

<div class="org-src-container">

<pre class="src src-sh">rpm -i &lt;downloaded rpm&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">1.4. Purpose/Scope of the document</h3>
<div class="outline-text-3" id="text-2-4">
<p>
This document is intended to be a "All in One" guide for
programming with ncurses and its sister libraries. We graduate from
a simple "Hello World" program to more complex form
manipulation. No prior experience in ncurses is assumed. The
writing is informal, but a lot of detail is provided for each of
the examples.
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">1.5. About the Programs</h3>
<div class="outline-text-3" id="text-2-5">
<p>
All the programs in the document are available in zipped form <a href="http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs.tar.gz">here</a>.
Unzip and untar it. The directory structure looks like this.
</p>

<div class="block">
<p>
<a href="ncurses_programs/">ncurses</a>
   ┬
   ├────&gt; <a href="ncurses_programs/JustForFun">JustForFun</a>     – just for fun programs
   ├────&gt; <a href="ncurses_programs/basics">basics</a>         – basic programs
   ├────&gt; <a href="ncurses_programs/demo">demo</a>           – output files go into this directory after make
   │        ┬
   │        └──────&gt; <a href="ncurses_programs/demo/exe">exe</a> – exe files of all example programs
   ├────&gt; <a href="ncurses_programs/forms">forms</a>          – programs related to form library
   ├────&gt; <a href="ncurses_programs/menus">menus</a>          – programs related to menus library
   ├────&gt; <a href="ncurses_programs/panels">panels</a>         – programs related to panels library
   ├────&gt; <a href="ncurses_programs/perl">perl</a>           – perl equivalents of the examples (contributed
   │                            by Anuradha Ratnaweera)
   ├────&gt; <a href="ncurses_programs/Makefile">Makefile</a>       – the top level Makefile
   ├────&gt; <a href="ncurses_programs/README">README</a>         – the top level README file. contains instructions
   └────&gt; <a href="ncurses_programs/COPYING">COPYING</a>        – copyright notice
</p>

</div>

<p>
The individual directories contain the following files.
</p>

<div class="block">
<p>
Description of files in each directory
––––––––––––––––––––––––––––––––––––––
<a href="ncurses_programs/JustForFun">JustForFun</a>
    ┬
    ├────&gt; <a href="ncurses_programs/JustForFun/hanoi.c"><code>hanoi.c</code></a>   – The Towers of Hanoi Solver
    ├────&gt; <a href="ncurses_programs/JustForFun/life.c"><code>life.c</code></a>    – The Game of Life demo
    ├────&gt; <a href="ncurses_programs/JustForFun/magic.c"><code>magic.c</code></a>   – An Odd Order Magic Square builder
    ├────&gt; <a href="ncurses_programs/JustForFun/queens.c"><code>queens.c</code></a>  – The famous N-Queens Solver
    ├────&gt; <a href="ncurses_programs/JustForFun/shuffle.c"><code>shuffle.c</code></a> – A fun game, if you have time to kill
    └────&gt; <a href="ncurses_programs/JustForFun/tt.c"><code>tt.c</code></a>      – A very trivial typing tutor
</p>

<p>
<a href="ncurses_programs/basics">basics</a>
  ┬
  ├────&gt; <a href="ncurses_programs/basics/acs_vars.c"><code>acs_vars.c</code></a>            – ACS_ variables example
  ├────&gt; <a href="ncurses_programs/basics/hello_world.c"><code>hello_world.c</code></a>         – Simple "Hello World" Program
  ├────&gt; <a href="ncurses_programs/basics/init_func_example.c"><code>init_func_example.c</code></a>   – Initialization functions example
  ├────&gt; <a href="ncurses_programs/basics/key_code.c"><code>key_code.c</code></a>            – Shows the scan code of the key pressed
  ├────&gt; <a href="ncurses_programs/basics/mouse_menu.c"><code>mouse_menu.c</code></a>          – A menu accessible by mouse
  ├────&gt; <a href="ncurses_programs/basics/other_border.c"><code>other_border.c</code></a>        – Shows usage of other border functions apa
  │                                 – rt from box()
  ├────&gt; <a href="ncurses_programs/basics/printw_example.c"><code>printw_example.c</code></a>      – A very simple printw() example
  ├────&gt; <a href="ncurses_programs/basics/scanw_example.c"><code>scanw_example.c</code></a>       – A very simple getstr() example
  ├────&gt; <a href="ncurses_programs/basics/simple_attr.c"><code>simple_attr.c</code></a>         – A program that can print a c file with
  │                                 – comments in attribute
  ├────&gt; <a href="ncurses_programs/basics/simple_color.c"><code>simple_color.c</code></a>        – A simple example demonstrating colors
  ├────&gt; <a href="ncurses_programs/basics/simple_key.c"><code>simple_key.c</code></a>          – A menu accessible with keyboard UP, DOWN
  │                                 – arrows
  ├────&gt; <a href="ncurses_programs/basics/temp_leave.c"><code>temp_leave.c</code></a>          – Demonstrates temporarily leaving curses mode
  ├────&gt; <a href="ncurses_programs/basics/win_border.c"><code>win_border.c</code></a>          – Shows Creation of windows and borders
  └────&gt; <a href="ncurses_programs/basics/with_chgat.c"><code>with_chgat.c</code></a>          – chgat() usage example
</p>

<p>
<a href="ncurses_programs/forms">forms</a>
  ┬
  ├────&gt; <a href="ncurses_programs/forms/form_attrib.c"><code>form_attrib.c</code></a>     – Usage of field attributes
  ├────&gt; <a href="ncurses_programs/forms/form_options.c"><code>form_options.c</code></a>    – Usage of field options
  ├────&gt; <a href="ncurses_programs/forms/form_simple.c"><code>form_simple.c</code></a>     – A simple form example
  └────&gt; <a href="ncurses_programs/forms/form_win.c"><code>form_win.c</code></a>        – Demo of windows associated with forms
</p>

<p>
<a href="ncurses_programs/menus">menus</a>
  ┬
  ├────&gt; <a href="ncurses_programs/menus/menu_attrib.c"><code>menu_attrib.c</code></a>     – Usage of menu attributes
  ├────&gt; <a href="ncurses_programs/menus/menu_item_data.c"><code>menu_item_data.c</code></a>  – Usage of <code>item_name()</code> etc.. functions
  ├────&gt; <a href="ncurses_programs/menus/menu_multi_column.c"><code>menu_multi_column.c</code></a>    – Creates multi columnar menus
  ├────&gt; <a href="ncurses_programs/menus/menu_scroll.c"><code>menu_scroll.c</code></a>     – Demonstrates scrolling capability of menus
  ├────&gt; <a href="ncurses_programs/menus/menu_simple.c"><code>menu_simple.c</code></a>     – A simple menu accessed by arrow keys
  ├────&gt; <a href="ncurses_programs/menus/menu_toggle.c"><code>menu_toggle.c</code></a>     – Creates multi valued menus and explains
  │                               – <code>REQ_TOGGLE_ITEM</code>
  ├────&gt; <a href="ncurses_programs/menus/menu_userptr.c"><code>menu_userptr.c</code></a>    – Usage of user pointer
  └────&gt; <a href="ncurses_programs/menus/menu_win.c"><code>menu_win.c</code></a>        – Demo of windows associated with menus
</p>

<p>
<a href="ncurses_programs/panels">panels</a>
  ┬
  ├────&gt; <a href="ncurses_programs/panels/panel_browse.c"><code>panel_browse.c</code></a>    – Panel browsing through tab. Usage of user
  │                             – pointer
  ├────&gt; <a href="ncurses_programs/panels/panel_hide.c"><code>panel_hide.c</code></a>      – Hiding and Un hiding of panels
  ├────&gt; <a href="ncurses_programs/panels/panel_resize.c"><code>panel_resize.c</code></a>    – Moving and resizing of panels
  └────&gt; <a href="ncurses_programs/panels/panel_simple.c"><code>panel_simple.c</code></a>    – A simple panel example
</p>

<p>
<a href="ncurses_programs/perl">perl</a>
  ┬
  └────&gt; <a href="ncurses_programs/perl/"><code>01-10.pl</code></a>          – Perl equivalents of first ten example programs
</p>

</div>

<p>
There is a top level Makefile included in the main directory. It
builds all the files and puts the ready-to-use exes in <a href="ncurses_programs/demo/exe">demo/exe</a>
directory. You can also do selective make by going into the
corresponding directory.  Each directory contains a README file
explaining the purpose of each c file in the directory.
</p>

<p>
For every example, I have included path name for the file relative
to the examples directory.
</p>

<p>
If you prefer browsing individual programs, point your browser to
<a href="http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs/">http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs/</a>
</p>

<p>
All the programs are released under the same license that is used
by ncurses (MIT-style). This gives you the ability to do pretty
much anything other than claiming them as yours. Feel free to use
them in your programs as appropriate.
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">1.6. Other Formats of the document</h3>
<div class="outline-text-3" id="text-2-6">
<p>
This howto is also availabe in various other formats on the
tldp.org site. Here are the links to other formats of this
document.
</p>
</div>

<div id="outline-container-sec-2-6-1" class="outline-4">
<h4 id="sec-2-6-1">1.6.1. Readily available formats from tldp.org</h4>
<div class="outline-text-4" id="text-2-6-1">
<ul class="org-ul">
<li><a href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/pdf/NCURSES-Programming-HOWTO.pdf">Acrobat PDF Format</a>
</li>

<li><a href="http:/www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/ps/NCURSES-Programming-HOWTO.ps.gz">PostScript Format</a>
</li>

<li><a href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html/NCURSES-Programming-HOWTO-html.tar.gz">In Multiple HTML pages</a>
</li>

<li><a href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html_single/NCURSES-Programming-HOWTO.html">In One big HTML format</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-6-2" class="outline-4">
<h4 id="sec-2-6-2">1.6.2. Building from source</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
If above links are broken or if you want to experiment with sgml
read on.
</p>

<ul class="org-ul">
<li>Get both the source and the tar,gzipped programs, available at

<p>
<a href="http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/NCURSES-HOWTO/NCURSES-Programming-HOWTO.sgml">http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/NCURSES-HOWTO/NCURSES-Programming-HOWTO.sgml</a>
</p>

<p>
<a href="http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/NCURSES-HOWTO/ncurses_programs.tar.gz">http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/NCURSES-HOWTO/ncurses_programs.tar.gz</a>
</p>
</li>

<li>Unzip <code>ncurses_programs.tar.gz</code> with

<div class="org-src-container">

<pre class="src src-sh">tar zxvf ncurses_programs.tar.gz
</pre>
</div>
</li>

<li>Use jade to create various formats. For example if you just want
to create the multiple html files, you would use

<div class="org-src-container">

<pre class="src src-sh">jade -t sgml -i html -d &lt;path to docbook html stylesheet&gt; NCURSES-Programming-HOWTO.sgml
</pre>
</div>
</li>

<li>to get pdf, first create a single html file of the HOWTO with

<div class="org-src-container">

<pre class="src src-sh">jade -t sgml -i html -d &lt;path to docbook html stylesheet&gt; -V nochunks NCURSES-Programming-HOWTO.sgml &gt; NCURSES-ONE-BIG-FILE.html
</pre>
</div>
</li>

<li>then use htmldoc to get pdf file with

<div class="org-src-container">

<pre class="src src-sh">htmldoc --size universal -t pdf --firstpage p1 -f &lt;output file name.pdf&gt; NCURSES-ONE-BIG-FILE.html
</pre>
</div>
</li>

<li>for ps, you would use

<div class="org-src-container">

<pre class="src src-sh">htmldoc --size universal -t ps --firstpage p1 -f &lt;output file name.ps&gt; NCURSES-ONE-BIG-FILE.html
</pre>
</div>
</li>
</ul>


<p>
See <a href="http://www.tldp.org/LDP/LDP-Author-Guide/">LDP Author guide</a> for more details. If all else failes, mail me
at <a href="mailto:ppadala@gmail.com">ppadala@gmail.com</a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">1.7. Credits</h3>
<div class="outline-text-3" id="text-2-7">
<p>
I thank <a href="mailto:sharath_1@usa.net">Sharath</a> and Emre Akbas for helping me with few sections.
The introduction was initially written by sharath.  I rewrote it
with few excerpts taken from his initial work. Emre helped in
writing printw and scanw sections.
</p>

<p>
Perl equivalents of the example programs are contributed by
<a href="mailto:Aratnaweera@virtusa.com">Anuradha Ratnaweera</a>.
</p>

<p>
Then comes <a href="mailto:parimi@ece.arizona.edu">Ravi Parimi</a>, my dearest friend, who has been on this
project before even one line was written.  He constantly bombarded
me with suggestions and patiently reviewed the whole text. He also
checked each program on Linux and Solaris.
</p>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">1.8. Wish List</h3>
<div class="outline-text-3" id="text-2-8">
<p>
This is the wish list, in the order of priority. If you have a wish
or you want to work on completing the wish, mail <a href="mailto:ppadala@gmail.com">me</a>.
</p>

<ul class="org-ul">
<li>Add examples to last parts of forms section.
</li>

<li>Prepare a Demo showing all the programs and allow the user to
browse through description of each program. Let the user compile
and see the program in action. A dialog based interface is
preferred.
</li>

<li>Add debug info. <code>_tracef</code>, <code>_tracemouse</code> stuff.
</li>

<li>Working on two terminals simultaneously.
</li>

<li>Add more stuff to miscellaneous section.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">1.9. Copyright</h3>
<div class="outline-text-3" id="text-2-9">
<p>
Copyright © 2001 by Pradeep Padala.
</p>

<p>
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, distribute with modifications,
sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the
following conditions:
</p>

<p>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</p>

<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</p>

<p>
Except as contained in this notice, the name(s) of the above
copyright holders shall not be used in advertising or otherwise to
promote the sale, use or other dealings in this Software without
prior written authorization.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">2. Hello World !!!</h2>
<div class="outline-text-2" id="text-3">
<p>
Welcome to the world of curses. Before we plunge into the library
and look into its various features, let's write a simple program and
say hello to the world.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">2.1. Compiling With the NCURSES Library</h3>
<div class="outline-text-3" id="text-3-1">
<p>
To use ncurses library functions, you have to include ncurses.h in
your programs. To link the program with ncurses the flag -lncurses
should be added.
</p>

<pre class="example">
#include &lt;ncurses.h&gt;
.
.
.

compile and link: gcc &lt;program file&gt; -lncurses
</pre>

<p>
<a href="ncurses_programs/basics/hello_world.c"><b>Example 1. The Hello World !!! Program</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

int main()
{
  initscr();                      /* Start curses mode              */
  printw("Hello World !!!");      /* Print Hello World              */
  refresh();                      /* Print it on to the real screen */
  getch();                        /* Wait for user input            */
  endwin();                       /* End curses mode                */

  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">2.2. Dissection</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The above program prints "Hello World !!!" to the screen and
exits. This program shows how to initialize curses and do screen
manipulation and end curses mode. Let's dissect it line by line.
</p>
</div>

<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">2.2.1. About initscr()</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
The function initscr() initializes the terminal in curses mode. In
some implementations, it clears the screen and presents a blank
screen. To do any screen manipulation using curses package this
has to be called first. This function initializes the curses
system and allocates memory for our present window (called
<code>stdscr</code>) and some other data-structures.  Under extreme cases
this function might fail due to insufficient memory to allocate
memory for curses library's data structures.
</p>

<p>
After this is done, we can do a variety of initializations to
customize our curses settings. These details will be explained
<a href="#INIT">later</a>.
</p>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">2.2.2. The mysterious refresh()</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
The next line <code>printw</code> prints the string "Hello World !!!" on to
the screen. This function is analogous to normal <code>printf</code> in all
respects except that it prints the data on a window called
<code>stdscr</code> at the current (y,x) co-ordinates. Since our present
co-ordinates are at 0,0 the string is printed at the left hand
corner of the window.
</p>

<p>
This brings us to that mysterious <code>refresh()</code>. Well, when we
called <code>printw</code> the data is actually written to an imaginary
window, which is not updated on the screen yet. The job of
<code>printw</code> is to update a few flags and data structures and write
the data to a buffer corresponding to <code>stdscr</code>. In order to show
it on the screen, we need to call <code>refresh()</code> and tell the curses
system to dump the contents on the screen.
</p>

<p>
The philosophy behind all this is to allow the programmer to do
multiple updates on the imaginary screen or windows and do a
refresh once all his screen update is done. <code>refresh()</code> checks the
window and updates only the portion which has been changed. This
improves performance and offers greater flexibility too. But, it
is sometimes frustrating to beginners.  A common mistake committed
by beginners is to forget to call <code>refresh()</code> after they did some
update through <code>printw()</code> class of functions. I still forget to
add it sometimes :-)
</p>
</div>
</div>

<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3">2.2.3. About endwin()</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
And finally don't forget to end the curses mode. Otherwise your
terminal might behave strangely after the program quits.
<code>endwin()</code> frees the memory taken by curses sub-system and its
data structures and puts the terminal in normal mode. This
function must be called after you are done with the curses mode.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">3. The Gory Details</h2>
<div class="outline-text-2" id="text-4">
<p>
Now that we have seen how to write a simple curses program let's get
into the details. There are many functions that help customize what
you see on screen and many features which can be put to full use.
</p>

<p>
Here we go&#x2026;
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">4. Initialization                                                   <a id="INIT" name="INIT"></a></h2>
<div class="outline-text-2" id="text-5">
<p>
We now know that to initialize curses system the function
<code>initscr()</code> has to be called. There are functions which can be
called after this initialization to customize our curses session. We
may ask the curses system to set the terminal in raw mode or
initialize color or initialize the mouse etc.. Let's discuss some of
the functions that are normally called immediately after
<code>initscr()</code>;
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">4.1. Initialization functions</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">4.1.1. <code>raw()</code> and <code>cbreak()</code></h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
Normally the terminal driver buffers the characters a user types
until a new line or carriage return is encountered. But most
programs require that the characters be available as soon as the
user types them. The above two functions are used to disable line
buffering. The difference between these two functions is in the
way control characters like suspend (CTRL-Z), interrupt and quit
(CTRL-C) are passed to the program.  In the <code>raw()</code> mode these
characters are directly passed to the program without generating a
signal. In the <code>cbreak()</code> mode these control characters are
interpreted as any other character by the terminal driver. I
personally prefer to use <code>raw()</code> as I can exercise greater control
over what the user does.
</p>
</div>
</div>

<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2">4.1.2. <code>echo()</code> and <code>noecho()</code></h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
These functions control the echoing of characters typed by the
user to the terminal. <code>noecho()</code> switches off echoing. The reason
you might want to do this is to gain more control over echoing or
to suppress unnecessary echoing while taking input from the user
through the <code>getch()</code> etc. functions. Most of the interactive
programs call <code>noecho()</code> at initialization and do the echoing of
characters in a controlled manner.  It gives the programmer the
flexibility of echoing characters at any place in the window
without updating current (y,x) co-ordinates.
</p>
</div>
</div>

<div id="outline-container-sec-5-1-3" class="outline-4">
<h4 id="sec-5-1-3">4.1.3. <code>keypad()</code></h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
This is my favorite initialization function. It enables the
reading of function keys like F1, F2, arrow keys etc. Almost every
interactive program enables this, as arrow keys are a major part
of any User Interface. Do <code>keypad(stdscr, TRUE)</code> to enable this
feature for the regular screen (stdscr). You will learn more about
key management in later sections of this document.
</p>
</div>
</div>

<div id="outline-container-sec-5-1-4" class="outline-4">
<h4 id="sec-5-1-4">4.1.4. <code>halfdelay()</code></h4>
<div class="outline-text-4" id="text-5-1-4">
<p>
This function, though not used very often, is a useful one at
times.  <code>halfdelay()</code> is called to enable the half-delay mode,
which is similar to the <code>cbreak()</code> mode in that characters typed
are immediately available to program. However, it waits for 'X'
tenths of a second for input and then returns <code>ERR</code>, if no input
is available. 'X' is the timeout value passed to the function
<code>halfdelay()</code>. This function is useful when you want to ask the
user for input, and if he doesn't respond with in certain time, we
can do some thing else. One possible example is a timeout at the
password prompt.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">4.2. Miscellaneous Initialization functions</h3>
<div class="outline-text-3" id="text-5-2">
<p>
There are few more functions which are called at initialization to
customize curses behavior. They are not used as extensively as
those mentioned above. Some of them are explained where
appropriate.
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">4.3. An Example</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Let's write a program which will clarify the usage of these
functions.
</p>

<p>
<a href="ncurses_programs/basics/init_func_example.c"><b>Example 2. Initialization Function Usage example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

int main()
{   int ch;

  initscr();                      /* Start curses mode                */
  raw();                          /* Line buffering disabled          */
  keypad(stdscr, TRUE);           /* We get F1, F2 etc..              */
  noecho();                       /* Don't echo() while we do getch   */

  printw("Type any character to see it in bold\n");
  ch = getch();                   /* If raw() hadn't been called
                                   * we have to press enter before it
                                   * gets to the program              */
  if(ch == KEY_F(1))              /* Without keypad enabled this will */
    printw("F1 Key pressed");     /*  not get to us either            */
                                  /* Without noecho() some ugly escape
                                   * charachters might have been printed
                                   * on screen                        */
  else
    {   printw("The pressed key is ");
        attron(A_BOLD);
        printw("%c", ch);
        attroff(A_BOLD);
    }
  refresh();                      /* Print it on to the real screen   */
  getch();                        /* Wait for user input              */
  endwin();                       /* End curses mode                  */

  return 0;
}
</pre>
</div>

<p>
This program is self-explanatory. But I used functions which aren't
explained yet. The function <code>getch()</code> is used to get a character
from user. It is equivalent to normal <code>getchar()</code> except that we
can disable the line buffering to avoid &lt;enter&gt; after input. Look
for more about <code>getch()</code> and reading keys in the <a href="#KEYS">key management
section</a>. The functions <code>attron</code> and <code>attroff</code> are used to switch
some attributes on and off respectively. In the example I used them
to print the character in bold. These functions are explained in
detail later.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">5. A Word about Windows</h2>
<div class="outline-text-2" id="text-6">
<p>
Before we plunge into the myriad ncurses functions, let me clear few
things about windows. Windows are explained in detail in following
<a href="#WINDOWS">sections</a>
</p>

<p>
A Window is an imaginary screen defined by curses system. A window
does not mean a bordered window which you usually see on Win9X
platforms.  When curses is initialized, it creates a default window
named <code>stdscr</code> which represents your 80x25 (or the size of window in
which you are running) screen. If you are doing simple tasks like
printing few strings, reading input etc., you can safely use this
single window for all of your purposes. You can also create windows
and call functions which explicitly work on the specified window.
</p>

<p>
For example, if you call
</p>

<div class="org-src-container">

<pre class="src src-c">printw("Hi There !!!");
refresh();
</pre>
</div>

<p>
It prints the string on <code>stdscr</code> at the present cursor position.
Similarly the call to <code>refresh()</code>, works on <code>stdscr</code> only.
</p>

<p>
Say you have created <a href="#WINDOWS">windows</a> then you have to call a function with a
'w' added to the usual function.
</p>

<div class="org-src-container">

<pre class="src src-c">wprintw(win, "Hi There !!!");
wrefresh(win);
</pre>
</div>

<p>
As you will see in the rest of the document, naming of functions
follow the same convention. For each function there usually are
three more functions.
</p>

<div class="org-src-container">

<pre class="src src-c">printw(string);           /* Print on stdscr at present cursor position     */
mvprintw(y, x, string);   /* Move to (y, x) then print string               */
wprintw(win, string);     /* Print on window win at present cursor position */
                          /* in the window                                  */
mvwprintw(win, y, x, string);  /* Move to (y, x) relative to window         */
                               /* co-ordinates and then print               */
</pre>
</div>

<p>
Usually the w-less functions are macros which expand to
corresponding w-function with <code>stdscr</code> as the window parameter.
</p>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">6. Output functions</h2>
<div class="outline-text-2" id="text-7">
<p>
I guess you can't wait any more to see some action. Back to our
odyssey of curses functions. Now that curses is initialized, let's
interact with world.
</p>

<p>
There are three classes of functions which you can use to do output
on screen.
</p>

<ol class="org-ol">
<li><code>addch()</code> class: Print single character with attributes
</li>

<li><code>printw()</code> class: Print formatted output similar to <code>printf()</code>
</li>

<li><code>addstr()</code> class: Print strings
</li>
</ol>


<p>
These functions can be used interchangeably and it's a matter of
style as to which class is used. Let's see each one in detail.
</p>
</div>

<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">6.1. <code>addch()</code> class of functions</h3>
<div class="outline-text-3" id="text-7-1">
<p>
These functions put a single character into the current cursor
location and advance the position of the cursor. You can give the
character to be printed but they usually are used to print a
character with some attributes. Attributes are explained in detail
in later <a href="#ATTRIB">sections</a> of the document. If a character is associated
with an attribute(bold, reverse video etc.), when curses prints the
character, it is printed in that attribute.
</p>

<p>
In order to combine a character with some attributes, you have two
options:
</p>

<ul class="org-ul">
<li>By OR'ing a single character with the desired attribute
macros. These attribute macros could be found in the header file
<code>ncurses.h</code>. For example, you want to print a character ch(of
type char) bold and underlined, you would call <code>addch()</code> as
below.

<div class="org-src-container">

<pre class="src src-c">addch(ch | A_BOLD | A_UNDERLINE);
</pre>
</div>
</li>

<li>By using functions like <code>attrset()</code>, <code>attron()</code>, <code>attroff()</code>.
These functions are explained in the <a href="#ATTRIB">Attributes</a> section.
Briefly, they manipulate the current attributes of the given
window.  Once set, the character printed in the window are
associated with the attributes until it is turned off.
</li>
</ul>


<p>
Additionally, <code>curses</code> provides some special characters for
character-based graphics. You can draw tables, horizontal or
vertical lines, etc. You can find all avaliable characters in the
header file <code>ncurses.h</code>. Try looking for macros beginning with
<code>ACS_</code> in this file.
</p>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">6.2. <code>mvaddch()</code>, <code>waddch()</code> and <code>mvwaddch()</code></h3>
<div class="outline-text-3" id="text-7-2">
<p>
<code>mvaddch()</code> is used to move the cursor to a given point, and then
print.  Thus, the calls:
</p>

<div class="org-src-container">

<pre class="src src-c">move(row,col);    /* moves the cursor to rowth row and colth column */
addch(ch);
</pre>
</div>

<p>
can be replaced by
</p>

<div class="org-src-container">

<pre class="src src-c">mvaddch(row,col,ch);
</pre>
</div>

<p>
<code>waddch()</code> is similar to <code>addch()</code>, except that it adds a character
into the given window. (Note that <code>addch()</code> adds a character into
the window <code>stdscr</code>.)
</p>

<p>
In a similar fashion <code>mvwaddch()</code> function is used to add a
character into the given window at the given coordinates.
</p>

<p>
Now, we are familiar with the basic output function <code>addch()</code>. But,
if we want to print a string, it would be very annoying to print it
character by character. Fortunately, <code>ncurses</code> provides
<code>printf</code>-like or <code>puts</code>-like functions.
</p>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">6.3. <code>printw()</code> class of functions</h3>
<div class="outline-text-3" id="text-7-3">
<p>
These functions are similar to <code>printf()</code> with the added capability
of printing at any position on the screen.
</p>
</div>

<div id="outline-container-sec-7-3-1" class="outline-4">
<h4 id="sec-7-3-1">6.3.1. <code>printw()</code> and <code>mvprintw</code></h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
These two functions work much like <code>printf()</code>. <code>mvprintw()</code> can be
used to move the cursor to a position and then print. If you want
to move the cursor first and then print using <code>printw()</code> function,
use <code>move()</code> first and then use <code>printw()</code> though I see no point
why one should avoid using <code>mvprintw()</code>, you have the flexibility
to manipulate.
</p>
</div>
</div>

<div id="outline-container-sec-7-3-2" class="outline-4">
<h4 id="sec-7-3-2">6.3.2. <code>wprintw()</code> and <code>mvwprintw</code></h4>
<div class="outline-text-4" id="text-7-3-2">
<p>
These two functions are similar to above two except that they
print in the corresponding window given as argument.
</p>
</div>
</div>

<div id="outline-container-sec-7-3-3" class="outline-4">
<h4 id="sec-7-3-3">6.3.3. <code>vwprintw()</code></h4>
<div class="outline-text-4" id="text-7-3-3">
<p>
This function is similar to <code>vprintf()</code>. This can be used when
variable number of arguments are to be printed.
</p>
</div>
</div>

<div id="outline-container-sec-7-3-4" class="outline-4">
<h4 id="sec-7-3-4">6.3.4. A Simple printw example</h4>
<div class="outline-text-4" id="text-7-3-4">
<p>
<a href="ncurses_programs/basics/printw_example.c"><b>Example 3. A Simple printw example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;              /* ncurses.h includes stdio.h            */
#include &lt;string.h&gt;

int main()
{
  char mesg[]="Just a string";    /* message to be appeared on the screen  */
  int row,col;                    /* to store the number of rows and       *
                                   * the number of colums of the screen    */
  initscr();                      /* start the curses mode                 */
  getmaxyx(stdscr,row,col);       /* get the number of rows and columns    */
  mvprintw(row/2,(col-strlen(mesg))/2,"%s",mesg);
                                  /* print the message at the center of the screen */
  mvprintw(row-2,0,"This screen has %d rows and %d columns\n",row,col);
  printw("Try resizing your window(if possible) and then run this program again");
  refresh();
  getch();
  endwin();

  return 0;
}
</pre>
</div>

<p>
Above program demonstrates how easy it is to use <code>printw</code>. You
just feed the coordinates and the message to be appeared on the
screen, then it does what you want.
</p>

<p>
The above program introduces us to a new function <code>getmaxyx()</code>, a
macro defined in <code>ncurses.h</code>. It gives the number of columns and
the number of rows in a given window. <code>getmaxyx()</code> does this by
updating the variables given to it. Since <code>getmaxyx()</code> is not a
function we don't pass pointers to it, we just give two integer
variables.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4">6.4. <code>addstr()</code> class of functions</h3>
<div class="outline-text-3" id="text-7-4">
<p>
<code>addstr()</code> is used to put a character string into a given
window. This function is similar to calling <code>addch()</code> once for each
character in a given string. This is true for all output
functions. There are other functions from this family such as
<code>mvaddstr(),mvwaddstr()</code> and <code>waddstr()</code>, which obey the naming
convention of curses.(e.g. <code>mvaddstr()</code> is similar to the
respective calls <code>move()</code> and then <code>addstr()</code>.) Another function of
this family is <code>addnstr()</code>, which takes an integer parameter(say
<code>n</code>) additionally. This function puts at most <code>n</code> characters into
the screen. If <code>n</code> is negative, then the entire string will be
added.
</p>
</div>
</div>

<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5">6.5. A word of caution</h3>
<div class="outline-text-3" id="text-7-5">
<p>
All these functions take <code>y</code> co-ordinate first and then <code>x</code> in
their arguments. A common mistake by beginners is to pass <code>x</code>, <code>y</code>
in that order.  If you are doing too many manipulations of (y,x)
co-ordinates, think of dividing the screen into windows and
manipulate each one separately.  Windows are explained in the
<a href="#WINDOWS">windows</a> section.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">7. Input functions</h2>
<div class="outline-text-2" id="text-8">
<p>
Well, printing without taking input, is boring. Let's see functions
which allow us to get input from user. These functions also can be
divided into three categories.
</p>

<ol class="org-ol">
<li><code>getch()</code> class: Get a character
</li>

<li><code>scanw()</code> class: Get formatted input
</li>

<li><code>getstr()</code> class: Get strings
</li>
</ol>
</div>

<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">7.1. <code>getch()</code> class of functions</h3>
<div class="outline-text-3" id="text-8-1">
<p>
These functions read a single character from the terminal. But
there are several subtle facts to consider. For example if you
don't use the function <code>cbreak()</code>, curses will not read your input
characters contiguously but will begin read them only after a new
line or an EOF is encountered. In order to avoid this, the
<code>cbreak()</code> function must used so that characters are immediately
available to your program. Another widely used function is
<code>noecho()</code>. As the name suggests, when this function is set (used),
the characters that are keyed in by the user will not show up on
the screen. The two functions <code>cbreak()</code> and <code>noecho()</code> are typical
examples of key management. Functions of this genre are explained
in the <a href="#KEYS">key management section</a>.
</p>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">7.2. <code>scanw()</code> class of functions</h3>
<div class="outline-text-3" id="text-8-2">
<p>
These functions are similar to <code>scanf()</code> with the added capability
of getting the input from any location on the screen.
</p>
</div>

<div id="outline-container-sec-8-2-1" class="outline-4">
<h4 id="sec-8-2-1">7.2.1. <code>scanw()</code> and <code>mvscanw</code></h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
The usage of these functions is similar to that of <code>sscanf()</code>,
where the line to be scanned is provided by <code>wgetstr()</code>
function. That is, these functions call to <code>wgetstr()</code>
function(explained below) and uses the resulting line for a scan.
</p>
</div>
</div>

<div id="outline-container-sec-8-2-2" class="outline-4">
<h4 id="sec-8-2-2">7.2.2. <code>wscanw()</code> and <code>mvwscanw()</code></h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
These are similar to above two functions except that they read
from a window, which is supplied as one of the arguments to these
functions.
</p>
</div>
</div>

<div id="outline-container-sec-8-2-3" class="outline-4">
<h4 id="sec-8-2-3">7.2.3. <code>vwscanw()</code></h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
This function is similar to <code>vscanf()</code>. This can be used when a
variable number of arguments are to be scanned.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">7.3. <code>getstr()</code> class of functions</h3>
<div class="outline-text-3" id="text-8-3">
<p>
These functions are used to get strings from the terminal. In
essence, this function performs the same task as would be achieved
by a series of calls to <code>getch()</code> until a newline, carriage return,
or end-of-file is received. The resulting string of characters are
pointed to by <code>str</code>, which is a character pointer provided by the
user.
</p>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4">7.4. Some examples</h3>
<div class="outline-text-3" id="text-8-4">
<p>
<a href="ncurses_programs/basics/scanw_example.c"><b>Example 4. A Simple scanw example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;                     /* ncurses.h includes stdio.h           */
#include &lt;string.h&gt;

int main()
{
  char mesg[]="Enter a string: ";        /* message to be appeared on the screen */
  char str[80];
  int row,col;                           /* to store the number of rows and      *
                                          * the number of colums of the screen   */
  initscr();                             /* start the curses mode                */
  getmaxyx(stdscr,row,col);              /* get the number of rows and columns   */
  mvprintw(row/2,(col-strlen(mesg))/2,"%s",mesg);
                                /* print the message at the center of the screen */
  getstr(str);
  mvprintw(LINES - 2, 0, "You Entered: %s", str);
  getch();
  endwin();

  return 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">8. Attributes                                                       <a id="ATTRIB" name="ATTRIB"></a></h2>
<div class="outline-text-2" id="text-9">
<p>
We have seen an example of how attributes can be used to print
characters with some special effects. Attributes, when set
prudently, can present information in an easy, understandable
manner. The following program takes a C file as input and prints the
file with comments in bold. Scan through the code.
</p>

<p>
<a href="ncurses_programs/basics/simple_attr.c"><b>Example 5. A Simple Attributes example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">/* pager functionality by Joseph Spainhour" &lt;spainhou@bellsouth.net&gt; */
#include &lt;ncurses.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{
  int ch, prev, row, col;
  prev = EOF;
  FILE *fp;
  int y, x;

  if(argc != 2)
    {
      printf("Usage: %s &lt;a c file name&gt;\n", argv[0]);
      exit(1);
    }
  fp = fopen(argv[1], "r");
  if(fp == NULL)
    {
      perror("Cannot open input file");
      exit(1);
    }
  initscr();                               /* Start curses mode                    */
  getmaxyx(stdscr, row, col);              /* find the boundaries of the screeen   */
  while((ch = fgetc(fp)) != EOF)           /* read the file till we reach the end  */
    {
      getyx(stdscr, y, x);                 /* get the current curser position      */
      if(y == (row - 1))                   /* are we are at the end of the screen  */
        {
          printw("&lt;-Press Any Key-&gt;");     /* tell the user to press a key         */
          getch();
          clear();                         /* clear the screen                     */
          move(0, 0);                      /* start at the beginning of the screen */
        }
      if(prev == '/' &amp;&amp; ch == '*')         /* If it is / and * then only
                                            * switch bold on                       */
        {
          attron(A_BOLD);                  /* cut bold on                          */
          getyx(stdscr, y, x);             /* get the current curser position      */
          move(y, x - 1);                  /* back up one space */
          printw("%c%c", '/', ch);         /* The actual printing is done here     */
        }
      else
        printw("%c", ch);
      refresh();
      if(prev == '*' &amp;&amp; ch == '/')
        attroff(A_BOLD);                   /* Switch it off once we got *
                                            * and then /                           */
      prev = ch;
    }

  printw("&lt;-Press Any Key-&gt;");
  getch();

  endwin();                                /* End curses mode                      */
  fclose(fp);
  return 0;
}
</pre>
</div>

<p>
Don't worry about all those initialization and other crap.
Concentrate on the while loop. It reads each character in the file
and searches for the pattern <code>/*</code>. Once it spots the pattern, it
switches the BOLD attribute on with <code>attron()</code> . When we get the
pattern <code>*/</code> it is switched off by <code>attroff()</code> .
</p>

<p>
The above program also introduces us to two useful functions
<code>getyx()</code> and <code>move()</code>. The first function gets the co-ordinates of
the present cursor into the variables <code>y</code>, <code>x</code>. Since <code>getyx()</code> is a
macro we don't have to pass pointers to variables. The function
<code>move()</code> moves the cursor to the co-ordinates given to it.
</p>

<p>
The above program is really a simple one which doesn't do much. On
these lines one could write a more useful program which reads a C
file, parses it and prints it in different colors. One could even
extend it to other languages as well.
</p>
</div>

<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">8.1. The details</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Let's get into more details of attributes. The functions
<code>attron()</code>, <code>attroff()</code>, <code>attrset()</code>, and their sister functions
<code>attr_get()</code> etc.. can be used to switch attributes on/off , get
attributes and produce a colorful display.
</p>

<p>
The functions <code>attron</code> and <code>attroff</code> take a bit-mask of attributes
and switch them on or off, respectively. The following video
attributes, which are defined in <code>&lt;curses.h&gt;</code> can be passed to
these functions.
</p>

<pre class="example">
A_NORMAL        Normal display (no highlight)
A_STANDOUT      Best highlighting mode of the terminal.
A_UNDERLINE     Underlining
A_REVERSE       Reverse video
A_BLINK         Blinking
A_DIM           Half bright
A_BOLD          Extra bright or bold
A_PROTECT       Protected mode
A_INVIS         Invisible or blank mode
A_ALTCHARSET    Alternate character set
A_CHARTEXT      Bit-mask to extract a character
COLOR_PAIR(n)   Color-pair number n
</pre>

<p>
The last one is the most colorful one :-) Colors are explained in
the <a href="#color">next sections</a>.
</p>

<p>
We can OR(|) any number of above attributes to get a combined
effect. If you wanted reverse video with blinking characters you
can use
</p>

<div class="org-src-container">

<pre class="src src-c">attron(A_REVERSE | A_BLINK);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">8.2. <code>attron()</code> vs <code>attrset()</code></h3>
<div class="outline-text-3" id="text-9-2">
<p>
Then what is the difference between <code>attron()</code> and <code>attrset()</code>?
attrset sets the attributes of window whereas attron just switches
on the attribute given to it. So <code>attrset()</code> fully overrides
whatever attributes the window previously had and sets it to the
new <code>attribute(s)</code>. Similarly <code>attroff()</code> just switches off the
<code>attribute(s)</code> given to it as an argument. This gives us the
flexibility of managing attributes easily.But if you use them
carelessly you may loose track of what attributes the window has
and garble the display. This is especially true while managing
menus with colors and highlighting. So decide on a consistent
policy and stick to it. You can always use <code>standend()</code> which is
equivalent to <code>attrset(A_NORMAL)</code> which turns off all attributes
and brings you to normal mode.
</p>
</div>
</div>

<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">8.3. <code>attr_get()</code></h3>
<div class="outline-text-3" id="text-9-3">
<p>
The function <code>attr_get()</code> gets the current attributes and color
pair of the window. Though we might not use this as often as the
above functions, this is useful in scanning areas of screen. Say we
wanted to do some complex update on screen and we are not sure what
attribute each character is associated with. Then this function can
be used with either <code>attrset</code> or <code>attron</code> to produce the desired
effect.
</p>
</div>
</div>

<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4">8.4. <code>attr_</code> functions</h3>
<div class="outline-text-3" id="text-9-4">
<p>
There are series of functions like <code>attr_set()</code>, <code>attr_on</code>
etc.. These are similar to above functions except that they take
parameters of type <code>attr_t</code>.
</p>
</div>
</div>

<div id="outline-container-sec-9-5" class="outline-3">
<h3 id="sec-9-5">8.5. <code>wattr</code> functions</h3>
<div class="outline-text-3" id="text-9-5">
<p>
For each of the above functions we have a corresponding function
with 'w' which operates on a particular window. The above functions
operate on <code>stdscr</code>.
</p>
</div>
</div>

<div id="outline-container-sec-9-6" class="outline-3">
<h3 id="sec-9-6">8.6. <code>chgat()</code> functions</h3>
<div class="outline-text-3" id="text-9-6">
<p>
The function <code>chgat()</code> is listed in the end of the man page
<code>curs_attr</code>. It actually is a useful one. This function can be used
to set attributes for a group of characters without moving. I mean
it !!! without moving the cursor :-) It changes the attributes of a
given number of characters starting at the current cursor location.
</p>

<p>
We can give <code>-1</code> as the character count to update till end of
line. If you want to change attributes of characters from current
position to end of line, just use this.
</p>

<div class="org-src-container">

<pre class="src src-c">chgat(-1, A_REVERSE, 0, NULL);
</pre>
</div>

<p>
This function is useful when changing attributes for characters
that are already on the screen. Move to the character from which
you want to change and change the attribute.
</p>

<p>
Other functions <code>wchgat()</code>, <code>mvchgat()</code>, <code>mvwchgat()</code> behave
similarly except that the w functions operate on the particular
window. The mv functions first move the cursor then perform the
work given to them. Actually chgat is a macro which is replaced by
a <code>wchgat()</code> with <code>stdscr</code> as the window. Most of the "w-less"
functions are macros.
</p>

<p>
<a href="ncurses_programs/basics/with_chgat.c"><b>Example 6. Chgat() Usage example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

int main(int argc, char *argv[])
{   initscr();                      /* Start curses mode            */
  start_color();                    /* Start color functionality    */

  init_pair(1, COLOR_CYAN, COLOR_BLACK);
  printw("A Big string which i didn't care to type fully ");
  mvchgat(0, 0, -1, A_BLINK, 1, NULL);
  /*
   * First two parameters specify the position at which to start
   * Third parameter number of characters to update. -1 means till
   * end of line
   * Forth parameter is the normal attribute you wanted to give
   * to the charcter
   * Fifth is the color index. It is the index given during init_pair()
   * use 0 if you didn't want color
   * Sixth one is always NULL
   */
  refresh();
  getch();
  endwin();                         /* End curses mode              */
  return 0;
}
</pre>
</div>

<p>
This example also introduces us to the color world of curses.
Colors will be explained in detail later. Use 0 for no color.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">9. Windows                                                          <a id="WINDOWS" name="WINDOWS"></a></h2>
<div class="outline-text-2" id="text-10">
<p>
Windows form the most important concept in curses. You have seen the
standard window <code>stdscr</code> above where all the functions implicitly
operated on this window. Now to make design even a simplest GUI, you
need to resort to windows. The main reason you may want to use
windows is to manipulate parts of the screen separately, for better
efficiency, by updating only the windows that need to be changed and
for a better design. I would say the last reason is the most
important in going for windows. You should always strive for a
better and easy-to-manage design in your programs. If you are
writing big, complex GUIs this is of pivotal importance before you
start doing anything.
</p>
</div>

<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">9.1. The basics</h3>
<div class="outline-text-3" id="text-10-1">
<p>
A Window can be created by calling the function <code>newwin()</code>. It
doesn't create any thing on the screen actually. It allocates
memory for a structure to manipulate the window and updates the
structure with data regarding the window like it's size, beginy,
beginx etc.. Hence in curses, a window is just an abstraction of an
imaginary window, which can be manipulated independent of other
parts of screen. The function <code>newwin()</code> returns a pointer to
structure <code>WINDOW</code>, which can be passed to window related functions
like <code>wprintw()</code> etc.. Finally the window can be destroyed with
<code>delwin()</code>. It will deallocate the memory associated with the
<code>WINDOW</code> structure.
</p>
</div>
</div>

<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2">9.2. Let there be a Window !!!</h3>
<div class="outline-text-3" id="text-10-2">
<p>
What fun is it, if a window is created and we can't see it. So the
fun part begins by displaying the window. The function <code>box()</code> can
be used to draw a border around the window. Let's explore these
functions in more detail in this example.
</p>

<p>
<a href="ncurses_programs/basics/win_border.c"><b>Example 7. Window Border example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

WINDOW *create_newwin(int height, int width, int starty, int startx);
void destroy_win(WINDOW *local_win);

int main(int argc, char *argv[])
{ WINDOW *my_win;
  int startx, starty, width, height;
  int ch;

  initscr();                      /* Start curses mode                  */
  cbreak();                       /* Line buffering disabled, Pass on
                                   * everty thing to me                 */
  keypad(stdscr, TRUE);           /* I need that nifty F1               */

  height = 3;
  width = 10;
  starty = (LINES - height) / 2;  /* Calculating for a center placement */
  startx = (COLS - width) / 2;    /* of the window                      */
  printw("Press F1 to exit");
  refresh();
  my_win = create_newwin(height, width, starty, startx);

  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case KEY_LEFT:
            destroy_win(my_win);
            my_win = create_newwin(height, width, starty,--startx);
            break;
        case KEY_RIGHT:
          destroy_win(my_win);
          my_win = create_newwin(height, width, starty,++startx);
          break;
        case KEY_UP:
          destroy_win(my_win);
          my_win = create_newwin(height, width, --starty,startx);
          break;
        case KEY_DOWN:
          destroy_win(my_win);
          my_win = create_newwin(height, width, ++starty,startx);
          break;
        }
    }

  endwin();                       /* End curses mode                    */
  return 0;
}

WINDOW *create_newwin(int height, int width, int starty, int startx)
{ WINDOW *local_win;

  local_win = newwin(height, width, starty, startx);
  box(local_win, 0 , 0);          /* 0, 0 gives default characters
                                   * for the vertical and horizontal
                                   * lines                              */
  wrefresh(local_win);            /* Show that box                      */

  return local_win;
}

void destroy_win(WINDOW *local_win)
{
  /* box(local_win, ' ', ' '); : This won't produce the desired
   * result of erasing the window. It will leave it's four corners
   * and so an ugly remnant of window.
   */
  wborder(local_win, ' ', ' ', ' ',' ',' ',' ',' ',' ');
  /* The parameters taken are
   * 1. win: the window on which to operate
   * 2. ls: character to be used for the left side of the window
   * 3. rs: character to be used for the right side of the window
   * 4. ts: character to be used for the top side of the window
   * 5. bs: character to be used for the bottom side of the window
   * 6. tl: character to be used for the top left corner of the window
   * 7. tr: character to be used for the top right corner of the window
   * 8. bl: character to be used for the bottom left corner of the window
   * 9. br: character to be used for the bottom right corner of the window
   */
  wrefresh(local_win);
  delwin(local_win);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3">9.3. Explanation</h3>
<div class="outline-text-3" id="text-10-3">
<p>
Don't scream. I know it's a big example. But I have to explain some
important things here :-). This program creates a rectangular
window that can be moved with left, right, up, down arrow keys. It
repeatedly creates and destroys windows as user press a key. Don't
go beyond the screen limits. Checking for those limits is left as
an exercise for the reader. Let's dissect it by line by line.
</p>

<p>
The <code>create_newwin()</code> function creates a window with <code>newwin()</code> and
displays a border around it with <code>box()</code>. The function
<code>destroy_win()</code> first erases the window from screen by painting a
border with ' ' character and then calling <code>delwin()</code> to deallocate
memory related to it. Depending on the key the user presses,
<code>starty</code> or <code>startx</code> is changed and a new window is created.
</p>

<p>
In the <code>destroy_win</code>, as you can see, I used <code>wborder</code> instead of
box. The reason is written in the comments (You missed it. I
know. Read the code :-)). <code>wborder</code> draws a border around the
window with the characters given to it as the 4 corner points and
the 4 lines. To put it clearly, if you have called <code>wborder</code> as
below:
</p>

<div class="org-src-container">

<pre class="src src-c">wborder(win, '|', '|', '-', '-', '+', '+', '+', '+');
</pre>
</div>

<p>
it produces some thing like
</p>

<pre class="example">
+------------+
|            |
|            |
|            |
|            |
|            |
|            |
+------------+
</pre>
</div>
</div>

<div id="outline-container-sec-10-4" class="outline-3">
<h3 id="sec-10-4">9.4. The other stuff in the example</h3>
<div class="outline-text-3" id="text-10-4">
<p>
You can also see in the above examples, that I have used the
variables <code>COLS</code>, <code>LINES</code> which are initialized to the screen sizes
after <code>initscr()</code>.  They can be useful in finding screen dimensions
and finding the center co-ordinate of the screen as above. The
function <code>getch()</code> as usual gets the key from keyboard and
according to the key it does the corresponding work. This type of
switch-case is very common in any GUI based programs.
</p>
</div>
</div>

<div id="outline-container-sec-10-5" class="outline-3">
<h3 id="sec-10-5">9.5. Other Border functions</h3>
<div class="outline-text-3" id="text-10-5">
<p>
Above program is grossly inefficient in that with each press of a
key, a window is destroyed and another is created. So let's write a
more efficient program which uses other border related functions.
</p>

<p>
The following program uses <code>mvhline()</code> and <code>mvvline()</code> to achieve
similar effect. These two functions are simple. They create a
horizontal or vertical line of the specified length at the
specified position.
</p>

<p>
<a href="ncurses_programs/basics/other_border.c"><b>Example 8. More border functions</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

typedef struct _win_border_struct {
  chtype  ls, rs, ts, bs,
    tl, tr, bl, br;
} WIN_BORDER;

typedef struct _WIN_struct {
  int startx, starty;
  int height, width;
  WIN_BORDER border;
} WIN;

void init_win_params(WIN *p_win);
void print_win_params(WIN *p_win);
void create_box(WIN *win, bool flag);

int main(int argc, char *argv[])
{ WIN win;
  int ch;

  initscr();                      /* Start curses mode             */
  start_color();                  /* Start the color functionality */
  cbreak();                       /* Line buffering disabled, Pass on
                                   * everty thing to me            */
  keypad(stdscr, TRUE);           /* I need that nifty F1          */
  noecho();
  init_pair(1, COLOR_CYAN, COLOR_BLACK);

  /* Initialize the window parameters */
  init_win_params(&amp;win);
  print_win_params(&amp;win);

  attron(COLOR_PAIR(1));
  printw("Press F1 to exit");
  refresh();
  attroff(COLOR_PAIR(1));

  create_box(&amp;win, TRUE);
  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case KEY_LEFT:
            create_box(&amp;win, FALSE);
            --win.startx;
            create_box(&amp;win, TRUE);
            break;
        case KEY_RIGHT:
          create_box(&amp;win, FALSE);
          ++win.startx;
          create_box(&amp;win, TRUE);
          break;
        case KEY_UP:
          create_box(&amp;win, FALSE);
          --win.starty;
          create_box(&amp;win, TRUE);
          break;
        case KEY_DOWN:
          create_box(&amp;win, FALSE);
          ++win.starty;
          create_box(&amp;win, TRUE);
          break;
        }
    }
  endwin();                       /* End curses mode               */
  return 0;
}
void init_win_params(WIN *p_win)
{
  p_win-&gt;height = 3;
  p_win-&gt;width = 10;
  p_win-&gt;starty = (LINES - p_win-&gt;height)/2;
  p_win-&gt;startx = (COLS - p_win-&gt;width)/2;

  p_win-&gt;border.ls = '|';
  p_win-&gt;border.rs = '|';
  p_win-&gt;border.ts = '-';
  p_win-&gt;border.bs = '-';
  p_win-&gt;border.tl = '+';
  p_win-&gt;border.tr = '+';
  p_win-&gt;border.bl = '+';
  p_win-&gt;border.br = '+';

}
void print_win_params(WIN *p_win)
{
#ifdef _DEBUG
  mvprintw(25, 0, "%d %d %d %d", p_win-&gt;startx, p_win-&gt;starty,
           p_win-&gt;width, p_win-&gt;height);
  refresh();
#endif
}
void create_box(WIN *p_win, bool flag)
{ int i, j;
  int x, y, w, h;

  x = p_win-&gt;startx;
  y = p_win-&gt;starty;
  w = p_win-&gt;width;
  h = p_win-&gt;height;

  if(flag == TRUE)
    { mvaddch(y, x, p_win-&gt;border.tl);
      mvaddch(y, x + w, p_win-&gt;border.tr);
      mvaddch(y + h, x, p_win-&gt;border.bl);
      mvaddch(y + h, x + w, p_win-&gt;border.br);
      mvhline(y, x + 1, p_win-&gt;border.ts, w - 1);
      mvhline(y + h, x + 1, p_win-&gt;border.bs, w - 1);
      mvvline(y + 1, x, p_win-&gt;border.ls, h - 1);
      mvvline(y + 1, x + w, p_win-&gt;border.rs, h - 1);

    }
  else
    for(j = y; j &lt;= y + h; ++j)
      for(i = x; i &lt;= x + w; ++i)
        mvaddch(j, i, ' ');

  refresh();

}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">10. Colors                                                          <a id="color" name="color"></a></h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">10.1. The basics</h3>
<div class="outline-text-3" id="text-11-1">
<p>
Life seems dull with no colors. Curses has a nice mechanism to
handle colors. Let's get into the thick of the things with a small
program.
</p>

<p>
<a href="ncurses_programs/basics/simple_color.c"><b>Example 9. A Simple Color example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string);
int main(int argc, char *argv[])
{ initscr();                /* Start curses mode        */
  if(has_colors() == FALSE)
    { endwin();
      printf("Your terminal does not support color\n");
      exit(1);
    }
  start_color();            /* Start color              */
  init_pair(1, COLOR_RED, COLOR_BLACK);

  attron(COLOR_PAIR(1));
  print_in_middle(stdscr, LINES / 2, 0, 0, "Viola !!! In color ...");
  attroff(COLOR_PAIR(1));
  getch();
  endwin();
}
void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  mvwprintw(win, y, x, "%s", string);
  refresh();
}
</pre>
</div>

<p>
As you can see, to start using color, you should first call the
function <code>start_color()</code>. After that, you can use color
capabilities of your terminals using various functions. To find out
whether a terminal has color capabilities or not, you can use
<code>has_colors()</code> function, which returns <code>FALSE</code> if the terminal does
not support color.
</p>

<p>
Curses initializes all the colors supported by terminal when
<code>start_color()</code> is called. These can be accessed by the define
constants like <code>COLOR_BLACK</code> etc. Now to actually start using
colors, you have to define pairs. Colors are always used in
pairs. That means you have to use the function <code>init_pair()</code> to
define the foreground and background for the pair number you
give. After that that pair number can be used as a normal attribute
with <code>COLOR_PAIR()</code> function. This may seem to be cumbersome at
first. But this elegant solution allows us to manage color pairs
very easily. To appreciate it, you have to look into the the source
code of "dialog", a utility for displaying dialog boxes from shell
scripts. The developers have defined foreground and background
combinations for all the colors they might need and initialized at
the beginning. This makes it very easy to set attributes just by
accessing a pair which we already have defined as a constant.
</p>

<p>
The following colors are defined in <code>curses.h</code>. You can use these
as parameters for various color functions.
</p>

<pre class="example">
COLOR_BLACK   0
COLOR_RED     1
COLOR_GREEN   2
COLOR_YELLOW  3
COLOR_BLUE    4
COLOR_MAGENTA 5
COLOR_CYAN    6
COLOR_WHITE   7
</pre>
</div>
</div>

<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2">10.2. Changing Color Definitions</h3>
<div class="outline-text-3" id="text-11-2">
<p>
The function <code>init_color()</code> can be used to change the rgb values
for the colors defined by curses initially. Say you wanted to
lighten the intensity of red color by a minuscule. Then you can use
this function as
</p>

<div class="org-src-container">

<pre class="src src-c">init_color(COLOR_RED, 700, 0, 0);
/* param 1     : color name
 * param 2, 3, 4 : rgb content min = 0, max = 1000 */
</pre>
</div>

<p>
If your terminal cannot change the color definitions, the function
returns <code>ERR</code>. The function <code>can_change_color()</code> can be used to
find out whether the terminal has the capability of changing color
content or not. The rgb content is scaled from 0 to 1000. Initially
RED color is defined with content 1000(r), 0(g), 0(b).
</p>
</div>
</div>

<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3">10.3. Color Content</h3>
<div class="outline-text-3" id="text-11-3">
<p>
The functions <code>color_content()</code> and <code>pair_content()</code> can be used to
find the color content and foreground, background combination for
the pair.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">11. Interfacing with the key board                                  <a id="KEYS" name="KEYS"></a></h2>
<div class="outline-text-2" id="text-12">
</div><div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1">11.1. The Basics</h3>
<div class="outline-text-3" id="text-12-1">
<p>
No GUI is complete without a strong user interface and to interact
with the user, a curses program should be sensitive to key presses
or the mouse actions done by the user. Let's deal with the keys
first.
</p>

<p>
As you have seen in almost all of the above examples, it's very
easy to get key input from the user. A simple way of getting key
presses is to use <code>getch()</code> function. The <code>cbreak</code> mode should be
enabled to read keys when you are interested in reading individual
key hits rather than complete lines of text (which usually end with
a carriage return).  <code>keypad</code> should be enabled to get the
Functions keys, arrow keys etc. See the initialization section for
details.
</p>

<p>
<code>getch()</code> returns an integer corresponding to the key pressed. If
it is a normal character, the integer value will be equivalent to
the character. Otherwise it returns a number which can be matched
with the constants defined in <code>curses.h</code>. For example if the user
presses F1, the integer returned is 265. This can be checked using
the macro <code>KEY_F()</code> defined in curses.h. This makes reading keys
portable and easy to manage.
</p>

<p>
For example, if you call <code>getch()</code> like this
</p>

<div class="org-src-container">

<pre class="src src-c">int ch;

ch = getch();
</pre>
</div>

<p>
<code>getch()</code> will wait for the user to press a key, (unless you
specified a timeout) and when user presses a key, the corresponding
integer is returned. Then you can check the value returned with the
constants defined in curses.h to match against the keys you want.
</p>

<p>
The following code piece will do that job.
</p>

<div class="org-src-container">

<pre class="src src-c">if(ch == KEY_LEFT)
  printw("Left arrow is pressed\n");
</pre>
</div>

<p>
Let's write a small program which creates a menu which can be
navigated by up and down arrows.
</p>
</div>
</div>

<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2">11.2. A Simple Key Usage example</h3>
<div class="outline-text-3" id="text-12-2">
<p>
<a href="ncurses_programs/basics/simple_key.c"><b>Example 10. A Simple Key Usage example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;stdio.h&gt;
#include &lt;ncurses.h&gt;

#define WIDTH 30
#define HEIGHT 10

int startx = 0;
int starty = 0;

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Exit",
};
int n_choices = sizeof(choices) / sizeof(char *);
void print_menu(WINDOW *menu_win, int highlight);

int main()
{ WINDOW *menu_win;
  int highlight = 1;
  int choice = 0;
  int c;

  initscr();
  clear();
  noecho();
  cbreak();   /* Line buffering disabled. pass on everything */
  startx = (80 - WIDTH) / 2;
  starty = (24 - HEIGHT) / 2;

  menu_win = newwin(HEIGHT, WIDTH, starty, startx);
  keypad(menu_win, TRUE);
  mvprintw(0, 0, "Use arrow keys to go up and down, Press enter to select a choice");
  refresh();
  print_menu(menu_win, highlight);
  while(1)
    { c = wgetch(menu_win);
      switch(c) {
        case KEY_UP:
          if(highlight == 1)
            highlight = n_choices;
          else
            --highlight;
          break;
        case KEY_DOWN:
          if(highlight == n_choices)
            highlight = 1;
          else
            ++highlight;
          break;
        case 10:
          choice = highlight;
          break;
        default:
          mvprintw(24, 0, "Charcter pressed is = %3d Hopefully it can be printed as '%c'", c, c);
          refresh();
          break;
        }
      print_menu(menu_win, highlight);
      if(choice != 0) /* User did a choice come out of the infinite loop */
        break;
    }
  mvprintw(23, 0, "You chose choice %d with choice string %s\n", choice, choices[choice - 1]);
  clrtoeol();
  refresh();
  getch();
  endwin();
  return 0;
}

void print_menu(WINDOW *menu_win, int highlight)
{
  int x, y, i;

  x = 2;
  y = 2;
  box(menu_win, 0, 0);
  for(i = 0; i &lt; n_choices; ++i)
    {   if(highlight == i + 1) /* High light the present choice */
        { wattron(menu_win, A_REVERSE);
          mvwprintw(menu_win, y, x, "%s", choices[i]);
          wattroff(menu_win, A_REVERSE);
        }
      else
        mvwprintw(menu_win, y, x, "%s", choices[i]);
      ++y;
    }
  wrefresh(menu_win);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">12. Interfacing with the mouse</h2>
<div class="outline-text-2" id="text-13">
<p>
Now that you have seen how to get keys, let's do the same thing from
mouse. Usually each UI allows the user to interact with both
keyboard and mouse.
</p>
</div>

<div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1">12.1. The Basics</h3>
<div class="outline-text-3" id="text-13-1">
<p>
Before you do any thing else, the events you want to receive have
to be enabled with <code>mousemask()</code>.
</p>

<div class="org-src-container">

<pre class="src src-c">mousemask( mmask_t newmask,    /* The events you want to listen to */
           mmask_t *oldmask ); /* The old events mask              */
</pre>
</div>

<p>
The first parameter to above function is a bit mask of events you
would like to listen. By default, all the events are turned
off. The bit mask <code>ALL_MOUSE_EVENTS</code> can be used to get all the
events.
</p>

<p>
The following are all the event masks:
</p>

<pre class="example">
Name            Description
   ---------------------------------------------------------------------
   BUTTON1_PRESSED          mouse button 1 down
   BUTTON1_RELEASED         mouse button 1 up
   BUTTON1_CLICKED          mouse button 1 clicked
   BUTTON1_DOUBLE_CLICKED   mouse button 1 double clicked
   BUTTON1_TRIPLE_CLICKED   mouse button 1 triple clicked
   BUTTON2_PRESSED          mouse button 2 down
   BUTTON2_RELEASED         mouse button 2 up
   BUTTON2_CLICKED          mouse button 2 clicked
   BUTTON2_DOUBLE_CLICKED   mouse button 2 double clicked
   BUTTON2_TRIPLE_CLICKED   mouse button 2 triple clicked
   BUTTON3_PRESSED          mouse button 3 down
   BUTTON3_RELEASED         mouse button 3 up
   BUTTON3_CLICKED          mouse button 3 clicked
   BUTTON3_DOUBLE_CLICKED   mouse button 3 double clicked
   BUTTON3_TRIPLE_CLICKED   mouse button 3 triple clicked
   BUTTON4_PRESSED          mouse button 4 down
   BUTTON4_RELEASED         mouse button 4 up
   BUTTON4_CLICKED          mouse button 4 clicked
   BUTTON4_DOUBLE_CLICKED   mouse button 4 double clicked
   BUTTON4_TRIPLE_CLICKED   mouse button 4 triple clicked
   BUTTON_SHIFT             shift was down during button state change
   BUTTON_CTRL              control was down during button state change
   BUTTON_ALT               alt was down during button state change
   ALL_MOUSE_EVENTS         report all button state changes
   REPORT_MOUSE_POSITION    report mouse movement
</pre>
</div>
</div>

<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2">12.2. Getting the events</h3>
<div class="outline-text-3" id="text-13-2">
<p>
Once a class of mouse events have been enabled, getch() class of
functions return <code>KEY_MOUSE</code> every time some mouse event
happens. Then the mouse event can be retrieved with <code>getmouse()</code>.
</p>

<p>
The code approximately looks like this:
</p>

<div class="org-src-container">

<pre class="src src-c">MEVENT event;

ch = getch();
if(ch == KEY_MOUSE)
  if(getmouse(&amp;event) == OK)
    .    /* Do some thing with the event */
    .
    .
</pre>
</div>

<p>
<code>getmouse()</code> returns the event into the pointer given to it. It's a
structure which contains
</p>

<div class="org-src-container">

<pre class="src src-c">typedef struct
{
  short id;         /* ID to distinguish multiple devices */
  int x, y, z;      /* event coordinates */
  mmask_t bstate;   /* button state bits */
}
</pre>
</div>

<p>
The <code>bstate</code> is the main variable we are interested in. It tells
the button state of the mouse.
</p>

<p>
Then with a code snippet like the following, we can find out what
happened.
</p>

<div class="org-src-container">

<pre class="src src-c">if(event.bstate &amp; BUTTON1_PRESSED)
  printw("Left Button Pressed");
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-13-3" class="outline-3">
<h3 id="sec-13-3">12.3. Putting it all Together</h3>
<div class="outline-text-3" id="text-13-3">
<p>
That's pretty much interfacing with mouse. Let's create the same
menu and enable mouse interaction. To make things simpler, key
handling is removed.
</p>

<p>
<a href="ncurses_programs/basics/mouse_menu.c"><b>Example 11. Access the menu with mouse !!!</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;
#include &lt;string.h&gt;

#define WIDTH  30
#define HEIGHT 10

int startx = 0;
int starty = 0;

char *choices[] = {     "Choice 1",
                        "Choice 2",
                        "Choice 3",
                        "Choice 4",
                        "Exit",
};

int n_choices = sizeof(choices) / sizeof(char *);

void print_menu(WINDOW *menu_win, int highlight);
void report_choice(int mouse_x, int mouse_y, int *p_choice);

int main()
{ int c, choice = 0;
  WINDOW *menu_win;
  MEVENT event;

  /* Initialize curses */
  initscr();
  clear();
  noecho();
  cbreak();   // Line buffering disabled. pass on everything

  /* Try to put the window in the middle of screen */
  startx = (80 -  WIDTH) / 2;
  starty = (24 - HEIGHT) / 2;

  attron(A_REVERSE);
  mvprintw(23, 1, "Click on Exit to quit (Works best in a virtual console)");
  refresh();
  attroff(A_REVERSE);

  /* Print the menu for the first time */
  menu_win = newwin(HEIGHT, WIDTH, starty, startx);
  print_menu(menu_win, 1);
  keypad( menu_win, TRUE );
  /* Get all the mouse events */
  mousemask(ALL_MOUSE_EVENTS, NULL);

  while(1)
    { c = wgetch(menu_win);
      switch(c)
        {   case KEY_MOUSE:
            if(getmouse(&amp;event) == OK)
              { /* When the user clicks left mouse button */
                if(event.bstate &amp; BUTTON1_PRESSED)
                  { report_choice(event.x, event.y, &amp;choice);
                    if(choice == -1) //Exit chosen
                      goto end;
                    mvprintw(22, 1, "Choice made is : %d String Chosen is \"%10s\"", choice, choices[choice - 1]);
                    refresh();
                  }
              }
            print_menu(menu_win, choice);
            break;
        }
    }
 end:
  endwin();
  return 0;
}


void print_menu(WINDOW *menu_win, int highlight)
{
  int x, y, i;

  x = 2;
  y = 2;
  box(menu_win, 0, 0);
  for(i = 0; i &lt; n_choices; ++i)
    { if(highlight == i + 1)
      { wattron(menu_win, A_REVERSE);
        mvwprintw(menu_win, y, x, "%s", choices[i]);
        wattroff(menu_win, A_REVERSE);
      }
      else
        mvwprintw(menu_win, y, x, "%s", choices[i]);
      ++y;
    }
  wrefresh(menu_win);
}

/* Report the choice according to mouse position */
void report_choice(int mouse_x, int mouse_y, int *p_choice)
{ int i,j, choice;

  i = startx + 2;
  j = starty + 2;

  for(choice = 0; choice &lt; n_choices; ++choice)
    if(mouse_y == j + choice &amp;&amp; mouse_x &gt;= i &amp;&amp; mouse_x &lt;= i + strlen(choices[choice]))
      { if(choice == n_choices - 1)
        *p_choice = -1;
        else
          *p_choice = choice + 1;
        break;
      }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-13-4" class="outline-3">
<h3 id="sec-13-4">12.4. Miscellaneous Functions</h3>
<div class="outline-text-3" id="text-13-4">
<p>
The functions <code>mouse_trafo()</code> and <code>wmouse_trafo()</code> can be used to
convert to mouse co-ordinates to screen relative co-ordinates. See
<a href="man/curs_mouse.3x.html"><code>curs_mouse(3X)</code></a> man page for details.
</p>

<p>
The mouseinterval function sets the maximum time (in thousands of a
second) that can elapse between press and release events in order
for them to be recognized as a click. This function returns the
previous interval value. The default is one fifth of a second.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">13. Screen Manipulation</h2>
<div class="outline-text-2" id="text-14">
<p>
In this section, we will look into some functions, which allow us to
manage the screen efficiently and to write some fancy programs. This
is especially important in writing games.
</p>
</div>

<div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1">13.1. <code>getyx()</code> functions</h3>
<div class="outline-text-3" id="text-14-1">
<p>
The function <code>getyx()</code> can be used to find out the present cursor
co-ordinates. It will fill the values of x and y co-ordinates in
the arguments given to it. Since <code>getyx()</code> is a macro you don't
have to pass the address of the variables. It can be called as
</p>

<div class="org-src-container">

<pre class="src src-c">getyx(win, y, x);
/*   win : window pointer
 *   y, x: y, x co-ordinates will be put into this variables
 */
</pre>
</div>

<p>
The function <code>getparyx()</code> gets the beginning co-ordinates of the
sub window relative to the main window. This is some times useful
to update a sub window. When designing fancy stuff like writing
multiple menus, it becomes difficult to store the menu positions,
their first option co-ordinates etc. A simple solution to this
problem, is to create menus in sub windows and later find the
starting co-ordinates of the menus by using <code>getparyx()</code>.
</p>

<p>
The functions <code>getbegyx()</code> and <code>getmaxyx()</code> store current window's
beginning and maximum co-ordinates. These functions are useful in
the same way as above in managing the windows and sub windows
effectively.
</p>
</div>
</div>

<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2">13.2. Screen Dumping</h3>
<div class="outline-text-3" id="text-14-2">
<p>
While writing games, some times it becomes necessary to store the
state of the screen and restore it back to the same state. The
function <code>scr_dump()</code> can be used to dump the screen contents to a
file given as an argument. Later it can be restored by
<code>scr_restore</code> function. These two simple functions can be used
effectively to maintain a fast moving game with changing scenarios.
</p>
</div>
</div>

<div id="outline-container-sec-14-3" class="outline-3">
<h3 id="sec-14-3">13.3. Window Dumping</h3>
<div class="outline-text-3" id="text-14-3">
<p>
To store and restore windows, the functions <code>putwin()</code> and
<code>getwin()</code> can be used. <code>putwin()</code> puts the present window state
into a file, which can be later restored by <code>getwin()</code>.
</p>

<p>
The function <code>copywin()</code> can be used to copy a window completely
onto another window. It takes the source and destination windows as
parameters and according to the rectangle specified, it copies the
rectangular region from source to destination window. It's last
parameter specifies whether to overwrite or just overlay the
contents on to the destination window. If this argument is true,
then the copying is non-destructive.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">14. Miscellaneous features</h2>
<div class="outline-text-2" id="text-15">
<p>
Now you know enough features to write a good curses program, with
all bells and whistles. There are some miscellaneous functions which
are useful in various cases. Let's go headlong into some of those.
</p>
</div>

<div id="outline-container-sec-15-1" class="outline-3">
<h3 id="sec-15-1">14.1. <code>curs_set()</code></h3>
<div class="outline-text-3" id="text-15-1">
<p>
This function can be used to make the cursor invisible. The
parameter to this function should be
</p>

<pre class="example">
0 : invisible  or
1 : normal     or
2 : very visible.
</pre>
</div>
</div>

<div id="outline-container-sec-15-2" class="outline-3">
<h3 id="sec-15-2">14.2. Temporarily Leaving Curses mode</h3>
<div class="outline-text-3" id="text-15-2">
<p>
Some times you may want to get back to cooked mode (normal line
buffering mode) temporarily. In such a case you will first need to
save the tty modes with a call to <code>def_prog_mode()</code> and then call
<code>endwin()</code> to end the curses mode. This will leave you in the
original tty mode. To get back to curses once you are done, call
<code>reset_prog_mode()</code>. This function returns the tty to the state
stored by <code>def_prog_mode()</code>. Then do refresh(), and you are back to
the curses mode. Here is an example showing the sequence of things
to be done.
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 12. Temporarily Leaving Curses Mode</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

int main()
{
  initscr();                      /* Start curses mode                   */
  printw("Hello World !!!\n");    /* Print Hello World                   */
  refresh();                      /* Print it on to the real screen      */
  def_prog_mode();                /* Save the tty modes                  */
  endwin();                       /* End curses mode temporarily         */
  system("/bin/sh");              /* Do whatever you like in cooked mode */
  reset_prog_mode();              /* Return to the previous tty mode     */
                                  /* stored by def_prog_mode()           */
  refresh();                      /* Do refresh() to restore the         */
                                  /* Screen contents                     */
  printw("Another String\n");     /* Back to curses use the full         */
  refresh();                      /* capabilities of curses              */
  endwin();                       /* End curses mode                     */

  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-15-3" class="outline-3">
<h3 id="sec-15-3">14.3. <code>ACS_</code> variables</h3>
<div class="outline-text-3" id="text-15-3">
<p>
If you have ever programmed in DOS, you know about those nifty
characters in extended character set. They are printable only on
some terminals. NCURSES functions like <code>box()</code> use these
characters. All these variables start with ACS meaning alternative
character set. You might have noticed me using these characters in
some of the programs above. Here's an example showing all the
characters.
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 13. ACS Variables Example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;ncurses.h&gt;

int main()
{
  initscr();

  printw("Upper left corner           "); addch(ACS_ULCORNER); printw("\n");
  printw("Lower left corner           "); addch(ACS_LLCORNER); printw("\n");
  printw("Lower right corner          "); addch(ACS_LRCORNER); printw("\n");
  printw("Tee pointing right          "); addch(ACS_LTEE); printw("\n");
  printw("Tee pointing left           "); addch(ACS_RTEE); printw("\n");
  printw("Tee pointing up             "); addch(ACS_BTEE); printw("\n");
  printw("Tee pointing down           "); addch(ACS_TTEE); printw("\n");
  printw("Horizontal line             "); addch(ACS_HLINE); printw("\n");
  printw("Vertical line               "); addch(ACS_VLINE); printw("\n");
  printw("Large Plus or cross over    "); addch(ACS_PLUS); printw("\n");
  printw("Scan Line 1                 "); addch(ACS_S1); printw("\n");
  printw("Scan Line 3                 "); addch(ACS_S3); printw("\n");
  printw("Scan Line 7                 "); addch(ACS_S7); printw("\n");
  printw("Scan Line 9                 "); addch(ACS_S9); printw("\n");
  printw("Diamond                     "); addch(ACS_DIAMOND); printw("\n");
  printw("Checker board (stipple)     "); addch(ACS_CKBOARD); printw("\n");
  printw("Degree Symbol               "); addch(ACS_DEGREE); printw("\n");
  printw("Plus/Minus Symbol           "); addch(ACS_PLMINUS); printw("\n");
  printw("Bullet                      "); addch(ACS_BULLET); printw("\n");
  printw("Arrow Pointing Left         "); addch(ACS_LARROW); printw("\n");
  printw("Arrow Pointing Right        "); addch(ACS_RARROW); printw("\n");
  printw("Arrow Pointing Down         "); addch(ACS_DARROW); printw("\n");
  printw("Arrow Pointing Up           "); addch(ACS_UARROW); printw("\n");
  printw("Board of squares            "); addch(ACS_BOARD); printw("\n");
  printw("Lantern Symbol              "); addch(ACS_LANTERN); printw("\n");
  printw("Solid Square Block          "); addch(ACS_BLOCK); printw("\n");
  printw("Less/Equal sign             "); addch(ACS_LEQUAL); printw("\n");
  printw("Greater/Equal sign          "); addch(ACS_GEQUAL); printw("\n");
  printw("Pi                          "); addch(ACS_PI); printw("\n");
  printw("Not equal                   "); addch(ACS_NEQUAL); printw("\n");
  printw("UK pound sign               "); addch(ACS_STERLING); printw("\n");

  refresh();
  getch();
  endwin();

  return 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16">15. Other libraries</h2>
<div class="outline-text-2" id="text-16">
<p>
Apart from the curses library, there are few text mode libraries,
which provide more functionality and a lot of features. The
following sections explain three standard libraries which are
usually distributed along with curses.
</p>
</div>
</div>

<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17">16. Panel Library</h2>
<div class="outline-text-2" id="text-17">
<p>
Now that you are proficient in curses, you wanted to do some thing
big.  You created a lot of overlapping windows to give a
professional windows-type look. Unfortunately, it soon becomes
difficult to manage these. The multiple refreshes, updates plunge
you into a nightmare. The overlapping windows create blotches,
whenever you forget to refresh the windows in the proper order.
</p>

<p>
Don't despair. There's an elegant solution provided in panels
library.  In the words of developers of ncurses
</p>

<div class="italic">
<p>
When your interface design is such that windows may dive deeper
into the visibility stack or pop to the top at runtime, the
resulting book-keeping can be tedious and difficult to get
right. Hence the panels library.
</p>

</div>

<p>
If you have lot of overlapping windows, then panels library is the
way to go. It obviates the need of doing series of wnoutrefresh(),
doupdate() and relieves the burden of doing it correctly(bottom
up). The library maintains information about the order of windows,
their overlapping and update the screen properly. So why wait? Let's
take a close peek into panels.
</p>
</div>

<div id="outline-container-sec-17-1" class="outline-3">
<h3 id="sec-17-1">16.1. The Basics</h3>
<div class="outline-text-3" id="text-17-1">
<p>
Panel object is a window that is implicitly treated as part of a
deck including all other panel objects. The deck is treated as a
stack with the top panel being completely visible and the other
panels may or may not be obscured according to their positions. So
the basic idea is to create a stack of overlapping panels and use
panels library to display them correctly. There is a function
similar to refresh() which, when called , displays panels in the
correct order. Functions are provided to hide or show panels, move
panels, change its size etc.. The overlapping problem is managed by
the panels library during all the calls to these functions.
</p>

<p>
The general flow of a panel program goes like this:
</p>

<ol class="org-ol">
<li>Create the windows (with newwin()) to be attached to the panels.
</li>

<li>Create panels with the chosen visibility order. Stack them up
according to the desired visibility. The function <code>new_panel()</code>
is used to created panels.
</li>

<li>Call <code>update_panels()</code> to write the panels to the virtual screen
in correct visibility order. Do a doupdate() to show it on the
screen.
</li>

<li>Mainpulate the panels with <code>show_panel()</code>, <code>hide_panel()</code>,
<code>move_panel()</code> etc. Make use of helper functions like
<code>panel_hidden()</code> and <code>panel_window()</code>. Make use of user pointer
to store custom data for a panel. Use the functions
<code>set_panel_userptr()</code> and <code>panel_userptr()</code> to set and get the
user pointer for a panel.
</li>

<li>When you are done with the panel use <code>del_panel()</code> to delete the
panel.
</li>
</ol>


<p>
Let's make the concepts clear, with some programs. The following is
a simple program which creates 3 overlapping panels and shows them
on the screen.
</p>
</div>
</div>

<div id="outline-container-sec-17-2" class="outline-3">
<h3 id="sec-17-2">16.2. Compiling With the Panels Library</h3>
<div class="outline-text-3" id="text-17-2">
<p>
To use panels library functions, you have to include panel.h and to
link the program with panels library the flag <code>-lpanel</code> should be
added along with <code>-lncurses</code> in that order.
</p>

<pre class="example">
#include &lt;panel.h&gt;
.
.
.

compile and link: gcc &lt;program file&gt; -lpanel -lncurses
</pre>

<p>
<a href="ncurses_programs/basics/"><b>Example 14. Panel basics</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;panel.h&gt;

int main()
{   WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  int lines = 10, cols = 40, y = 2, x = 4, i;

  initscr();
  cbreak();
  noecho();

  /* Create windows for the panels */
  my_wins[0] = newwin(lines, cols, y, x);
  my_wins[1] = newwin(lines, cols, y + 1, x + 5);
  my_wins[2] = newwin(lines, cols, y + 2, x + 10);

  /*
   * Create borders around the windows so that you can see the effect
   * of panels
   */
  for(i = 0; i &lt; 3; ++i)
    box(my_wins[i], 0, 0);

  /* Attach a panel to each window */     /* Order is bottom up */
  my_panels[0] = new_panel(my_wins[0]);   /* Push 0, order: stdscr-0 */
  my_panels[1] = new_panel(my_wins[1]);   /* Push 1, order: stdscr-0-1 */
  my_panels[2] = new_panel(my_wins[2]);   /* Push 2, order: stdscr-0-1-2 */

  /* Update the stacking order. 2nd panel will be on top */
  update_panels();

  /* Show it on the screen */
  doupdate();

  getch();
  endwin();
}
</pre>
</div>

<p>
As you can see, above program follows a simple flow as
explained. The windows are created with newwin() and then they are
attached to panels with <code>new_panel()</code>. As we attach one panel after
another, the stack of panels gets updated. To put them on screen
<code>update_panels()</code> and doupdate() are called.
</p>
</div>
</div>

<div id="outline-container-sec-17-3" class="outline-3">
<h3 id="sec-17-3">16.3. Panel Window Browsing</h3>
<div class="outline-text-3" id="text-17-3">
<p>
A slightly complicated example is given below. This program creates
3 windows which can be cycled through using tab. Have a look at the
code.
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 15. Panel Window Browsing Example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;panel.h&gt;

#define NLINES 10
#define NCOLS 40

void init_wins(WINDOW **wins, int n);
void win_show(WINDOW *win, char *label, int label_color);
void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

int main()
{   WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  PANEL  *top;
  int ch;

  /* Initialize curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Initialize all the colors */
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_BLUE, COLOR_BLACK);
  init_pair(4, COLOR_CYAN, COLOR_BLACK);

  init_wins(my_wins, 3);

  /* Attach a panel to each window */     /* Order is bottom up */
  my_panels[0] = new_panel(my_wins[0]);   /* Push 0, order: stdscr-0 */
  my_panels[1] = new_panel(my_wins[1]);   /* Push 1, order: stdscr-0-1 */
  my_panels[2] = new_panel(my_wins[2]);   /* Push 2, order: stdscr-0-1-2 */

  /* Set up the user pointers to the next panel */
  set_panel_userptr(my_panels[0], my_panels[1]);
  set_panel_userptr(my_panels[1], my_panels[2]);
  set_panel_userptr(my_panels[2], my_panels[0]);

  /* Update the stacking order. 2nd panel will be on top */
  update_panels();

  /* Show it on the screen */
  attron(COLOR_PAIR(4));
  mvprintw(LINES - 2, 0, "Use tab to browse through the windows (F1 to Exit)");
  attroff(COLOR_PAIR(4));
  doupdate();

  top = my_panels[2];
  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case 9:
            top = (PANEL *)panel_userptr(top);
            top_panel(top);
            break;
        }
      update_panels();
      doupdate();
    }
  endwin();
  return 0;
}

/* Put all the windows */
void init_wins(WINDOW **wins, int n)
{   int x, y, i;
  char label[80];

  y = 2;
  x = 10;
  for(i = 0; i &lt; n; ++i)
    {   wins[i] = newwin(NLINES, NCOLS, y, x);
      sprintf(label, "Window Number %d", i + 1);
      win_show(wins[i], label, i + 1);
      y += 3;
      x += 7;
    }
}

/* Show the window with a border and a label */
void win_show(WINDOW *win, char *label, int label_color)
{   int startx, starty, height, width;

  getbegyx(win, starty, startx);
  getmaxyx(win, height, width);

  box(win, 0, 0);
  mvwaddch(win, 2, 0, ACS_LTEE);
  mvwhline(win, 2, 1, ACS_HLINE, width - 2);
  mvwaddch(win, 2, width - 1, ACS_RTEE);

  print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
}

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
{   int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-17-4" class="outline-3">
<h3 id="sec-17-4">16.4. Using User Pointers</h3>
<div class="outline-text-3" id="text-17-4">
<p>
In the above example I used user pointers to find out the next
window in the cycle. We can attach custom information to the panel
by specifying a user pointer, which can point to any information
you want to store. In this case I stored the pointer to the next
panel in the cycle. User pointer for a panel can be set with the
function <code>set_panel_userptr()</code>.  It can be accessed using the
function <code>panel_userptr()</code> which will return the user pointer for
the panel given as argument. After finding the next panel in the
cycle It's brought to the top by the function <code>top_panel()</code>. This
function brings the panel given as argument to the top of the panel
stack.
</p>
</div>
</div>

<div id="outline-container-sec-17-5" class="outline-3">
<h3 id="sec-17-5">16.5. Moving and Resizing Panels</h3>
<div class="outline-text-3" id="text-17-5">
<p>
The function <code>move_panel()</code> can be used to move a panel to the
desired location. It does not change the position of the panel in
the stack.  Make sure that you use <code>move_panel()</code> instead mvwin()
on the window associated with the panel.
</p>

<p>
Resizing a panel is slightly complex. There is no straight forward
function just to resize the window associated with a panel. A
solution to resize a panel is to create a new window with the
desired sizes, change the window associated with the panel using
<code>replace_panel()</code>.  Don't forget to delete the old window. The
window associated with a panel can be found by using the function
<code>panel_window()</code>.
</p>

<p>
The following program shows these concepts, in supposedly simple
program. You can cycle through the window with &lt;TAB&gt; as usual. To
resize or move the active panel press 'r' for resize 'm' for
moving. Then use arrow keys to resize or move it to the desired way
and press enter to end your resizing or moving. This example makes
use of user data to get the required data to do the operations.
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 16. Panel Moving and Resizing example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;panel.h&gt;

typedef struct _PANEL_DATA {
  int x, y, w, h;
  char label[80];
  int label_color;
  PANEL *next;
}PANEL_DATA;

#define NLINES 10
#define NCOLS 40

void init_wins(WINDOW **wins, int n);
void win_show(WINDOW *win, char *label, int label_color);
void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);
void set_user_ptrs(PANEL **panels, int n);

int main()
{   WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  PANEL_DATA  *top;
  PANEL *stack_top;
  WINDOW *temp_win, *old_win;
  int ch;
  int newx, newy, neww, newh;
  int size = FALSE, move = FALSE;

  /* Initialize curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Initialize all the colors */
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_BLUE, COLOR_BLACK);
  init_pair(4, COLOR_CYAN, COLOR_BLACK);

  init_wins(my_wins, 3);

  /* Attach a panel to each window */     /* Order is bottom up */
  my_panels[0] = new_panel(my_wins[0]);   /* Push 0, order: stdscr-0 */
  my_panels[1] = new_panel(my_wins[1]);   /* Push 1, order: stdscr-0-1 */
  my_panels[2] = new_panel(my_wins[2]);   /* Push 2, order: stdscr-0-1-2 */

  set_user_ptrs(my_panels, 3);
  /* Update the stacking order. 2nd panel will be on top */
  update_panels();

  /* Show it on the screen */
  attron(COLOR_PAIR(4));
  mvprintw(LINES - 3, 0, "Use 'm' for moving, 'r' for resizing");
  mvprintw(LINES - 2, 0, "Use tab to browse through the windows (F1 to Exit)");
  attroff(COLOR_PAIR(4));
  doupdate();

  stack_top = my_panels[2];
  top = (PANEL_DATA *)panel_userptr(stack_top);
  newx = top-&gt;x;
  newy = top-&gt;y;
  neww = top-&gt;w;
  newh = top-&gt;h;
  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case 9:     /* Tab */
            top = (PANEL_DATA *)panel_userptr(stack_top);
            top_panel(top-&gt;next);
            stack_top = top-&gt;next;
            top = (PANEL_DATA *)panel_userptr(stack_top);
            newx = top-&gt;x;
            newy = top-&gt;y;
            neww = top-&gt;w;
            newh = top-&gt;h;
            break;
        case 'r':   /* Re-Size*/
          size = TRUE;
          attron(COLOR_PAIR(4));
          mvprintw(LINES - 4, 0, "Entered Resizing :Use Arrow Keys to resize and press &lt;ENTER&gt; to end resizing");
          refresh();
          attroff(COLOR_PAIR(4));
          break;
        case 'm':   /* Move */
          attron(COLOR_PAIR(4));
          mvprintw(LINES - 4, 0, "Entered Moving: Use Arrow Keys to Move and press &lt;ENTER&gt; to end moving");
          refresh();
          attroff(COLOR_PAIR(4));
          move = TRUE;
          break;
        case KEY_LEFT:
          if(size == TRUE)
            {   --newx;
              ++neww;
            }
          if(move == TRUE)
            --newx;
          break;
        case KEY_RIGHT:
          if(size == TRUE)
            {   ++newx;
              --neww;
            }
          if(move == TRUE)
            ++newx;
          break;
        case KEY_UP:
          if(size == TRUE)
            {   --newy;
              ++newh;
            }
          if(move == TRUE)
            --newy;
          break;
        case KEY_DOWN:
          if(size == TRUE)
            {   ++newy;
              --newh;
            }
          if(move == TRUE)
            ++newy;
          break;
        case 10:    /* Enter */
          move(LINES - 4, 0);
          clrtoeol();
          refresh();
          if(size == TRUE)
            {   old_win = panel_window(stack_top);
              temp_win = newwin(newh, neww, newy, newx);
              replace_panel(stack_top, temp_win);
              win_show(temp_win, top-&gt;label, top-&gt;label_color);
              delwin(old_win);
              size = FALSE;
            }
          if(move == TRUE)
            {   move_panel(stack_top, newy, newx);
              move = FALSE;
            }
          break;

        }
      attron(COLOR_PAIR(4));
      mvprintw(LINES - 3, 0, "Use 'm' for moving, 'r' for resizing");
      mvprintw(LINES - 2, 0, "Use tab to browse through the windows (F1 to Exit)");
      attroff(COLOR_PAIR(4));
      refresh();
      update_panels();
      doupdate();
    }
  endwin();
  return 0;
}

/* Put all the windows */
void init_wins(WINDOW **wins, int n)
{   int x, y, i;
  char label[80];

  y = 2;
  x = 10;
  for(i = 0; i &lt; n; ++i)
    {   wins[i] = newwin(NLINES, NCOLS, y, x);
      sprintf(label, "Window Number %d", i + 1);
      win_show(wins[i], label, i + 1);
      y += 3;
      x += 7;
    }
}

/* Set the PANEL_DATA structures for individual panels */
void set_user_ptrs(PANEL **panels, int n)
{   PANEL_DATA *ptrs;
  WINDOW *win;
  int x, y, w, h, i;
  char temp[80];

  ptrs = (PANEL_DATA *)calloc(n, sizeof(PANEL_DATA));

  for(i = 0;i &lt; n; ++i)
    {   win = panel_window(panels[i]);
      getbegyx(win, y, x);
      getmaxyx(win, h, w);
      ptrs[i].x = x;
      ptrs[i].y = y;
      ptrs[i].w = w;
      ptrs[i].h = h;
      sprintf(temp, "Window Number %d", i + 1);
      strcpy(ptrs[i].label, temp);
      ptrs[i].label_color = i + 1;
      if(i + 1 == n)
        ptrs[i].next = panels[0];
      else
        ptrs[i].next = panels[i + 1];
      set_panel_userptr(panels[i], &amp;ptrs[i]);
    }
}

/* Show the window with a border and a label */
void win_show(WINDOW *win, char *label, int label_color)
{   int startx, starty, height, width;

  getbegyx(win, starty, startx);
  getmaxyx(win, height, width);

  box(win, 0, 0);
  mvwaddch(win, 2, 0, ACS_LTEE);
  mvwhline(win, 2, 1, ACS_HLINE, width - 2);
  mvwaddch(win, 2, width - 1, ACS_RTEE);

  print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
}

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
{   int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</pre>
</div>

<p>
Concentrate on the main while loop. Once it finds out the type of
key pressed, it takes appropriate action. If 'r' is pressed
resizing mode is started. After this the new sizes are updated as
the user presses the arrow keys. When the user presses &lt;ENTER&gt;
present selection ends and panel is resized by using the concept
explained. While in resizing mode the program doesn't show how the
window is getting resized. It's left as an exercise to the reader
to print a dotted border while it gets resized to a new position.
</p>

<p>
When the user presses 'm' the move mode starts. This is a bit
simpler than resizing. As the arrow keys are pressed the new
position is updated and pressing of &lt;ENTER&gt; causes the panel to be
moved by calling the function <code>move_panel()</code>.
</p>

<p>
In this program the user data which is represented as <code>PANEL_DATA</code>,
plays very important role in finding the associated information
with a panel.  As written in the comments, the <code>PANEL_DATA</code> stores
the panel sizes, label, label color and a pointer to the next panel
in the cycle.
</p>
</div>
</div>

<div id="outline-container-sec-17-6" class="outline-3">
<h3 id="sec-17-6">16.6. Hiding and Showing Panels</h3>
<div class="outline-text-3" id="text-17-6">
<p>
A Panel can be hidden by using the function <code>hide_panel()</code>. This
function merely removes it form the stack of panels, thus hiding it
on the screen once you do <code>update_panels()</code> and doupdate(). It
doesn't destroy the PANEL structure associated with the hidden
panel. It can be shown again by using the <code>show_panel()</code> function.
</p>

<p>
The following program shows the hiding of panels. Press 'a' or 'b'
or 'c' to show or hide first, second and third windows
respectively. It uses a user data with a small variable hide, which
keeps track of whether the window is hidden or not. For some reason
the function <code>panel_hidden()</code> which tells whether a panel is hidden
or not is not working. A bug report was also presented by Michael
Andres <a href="http://www.geocrawler.com/archives/3/344/1999/9/0/2643549/">here</a>
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 17. Panel Hiding and Showing example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;panel.h&gt;

typedef struct _PANEL_DATA {
  int hide;   /* TRUE if panel is hidden */
}PANEL_DATA;

#define NLINES 10
#define NCOLS 40

void init_wins(WINDOW **wins, int n);
void win_show(WINDOW *win, char *label, int label_color);
void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

int main()
{   WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  PANEL_DATA panel_datas[3];
  PANEL_DATA *temp;
  int ch;

  /* Initialize curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Initialize all the colors */
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_BLUE, COLOR_BLACK);
  init_pair(4, COLOR_CYAN, COLOR_BLACK);

  init_wins(my_wins, 3);

  /* Attach a panel to each window */     /* Order is bottom up */
  my_panels[0] = new_panel(my_wins[0]);   /* Push 0, order: stdscr-0 */
  my_panels[1] = new_panel(my_wins[1]);   /* Push 1, order: stdscr-0-1 */
  my_panels[2] = new_panel(my_wins[2]);   /* Push 2, order: stdscr-0-1-2 */

  /* Initialize panel datas saying that nothing is hidden */
  panel_datas[0].hide = FALSE;
  panel_datas[1].hide = FALSE;
  panel_datas[2].hide = FALSE;

  set_panel_userptr(my_panels[0], &amp;panel_datas[0]);
  set_panel_userptr(my_panels[1], &amp;panel_datas[1]);
  set_panel_userptr(my_panels[2], &amp;panel_datas[2]);

  /* Update the stacking order. 2nd panel will be on top */
  update_panels();

  /* Show it on the screen */
  attron(COLOR_PAIR(4));
  mvprintw(LINES - 3, 0, "Show or Hide a window with 'a'(first window)  'b'(Second Window)  'c'(Third Window)");
  mvprintw(LINES - 2, 0, "F1 to Exit");

  attroff(COLOR_PAIR(4));
  doupdate();

  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case 'a':
            temp = (PANEL_DATA *)panel_userptr(my_panels[0]);
            if(temp-&gt;hide == FALSE)
              {   hide_panel(my_panels[0]);
                temp-&gt;hide = TRUE;
              }
            else
              {   show_panel(my_panels[0]);
                temp-&gt;hide = FALSE;
              }
            break;
        case 'b':
          temp = (PANEL_DATA *)panel_userptr(my_panels[1]);
          if(temp-&gt;hide == FALSE)
            {   hide_panel(my_panels[1]);
              temp-&gt;hide = TRUE;
            }
          else
            {   show_panel(my_panels[1]);
              temp-&gt;hide = FALSE;
            }
          break;
        case 'c':
          temp = (PANEL_DATA *)panel_userptr(my_panels[2]);
          if(temp-&gt;hide == FALSE)
            {   hide_panel(my_panels[2]);
              temp-&gt;hide = TRUE;
            }
          else
            {   show_panel(my_panels[2]);
              temp-&gt;hide = FALSE;
            }
          break;
        }
      update_panels();
      doupdate();
    }
  endwin();
  return 0;
}

/* Put all the windows */
void init_wins(WINDOW **wins, int n)
{   int x, y, i;
  char label[80];

  y = 2;
  x = 10;
  for(i = 0; i &lt; n; ++i)
    {   wins[i] = newwin(NLINES, NCOLS, y, x);
      sprintf(label, "Window Number %d", i + 1);
      win_show(wins[i], label, i + 1);
      y += 3;
      x += 7;
    }
}

/* Show the window with a border and a label */
void win_show(WINDOW *win, char *label, int label_color)
{   int startx, starty, height, width;

  getbegyx(win, starty, startx);
  getmaxyx(win, height, width);

  box(win, 0, 0);
  mvwaddch(win, 2, 0, ACS_LTEE);
  mvwhline(win, 2, 1, ACS_HLINE, width - 2);
  mvwaddch(win, 2, width - 1, ACS_RTEE);

  print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
}

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
{   int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-17-7" class="outline-3">
<h3 id="sec-17-7">16.7. <code>panel_above()</code> and <code>panel_below()</code> Functions</h3>
<div class="outline-text-3" id="text-17-7">
<p>
The functions <code>panel_above()</code> and <code>panel_below()</code> can be used to
find out the panel above and below a panel. If the argument to
these functions is NULL, then they return a pointer to bottom panel
and top panel respectively.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18">17. Menus Library</h2>
<div class="outline-text-2" id="text-18">
<p>
The menus library provides a nice extension to basic curses, through
which you can create menus. It provides a set of functions to create
menus. But they have to be customized to give a nicer look, with
colors etc. Let's get into the details.
</p>

<p>
A menu is a screen display that assists the user to choose some
subset of a given set of items. To put it simple, a menu is a
collection of items from which one or more items can be chosen. Some
readers might not be aware of multiple item selection
capability. Menu library provides functionality to write menus from
which the user can chose more than one item as the preferred
choice. This is dealt with in a later section. Now it is time for
some rudiments.
</p>
</div>

<div id="outline-container-sec-18-1" class="outline-3">
<h3 id="sec-18-1">17.1. The Basics</h3>
<div class="outline-text-3" id="text-18-1">
<p>
To create menus, you first create items, and then post the menu to
the display. After that, all the processing of user responses is
done in an elegant function <code>menu_driver()</code> which is the work horse
of any menu program.
</p>

<p>
The general flow of control of a menu program looks like this.
</p>

<ol class="org-ol">
<li>Initialize curses
</li>

<li>Create items using <code>new_item()</code>. You can specify a name and
description for the items.
</li>

<li>Create the menu with <code>new_menu()</code> by specifying the items to be
attached with.
</li>

<li>Post the menu with <code>menu_post()</code> and refresh the screen.
</li>

<li>Process the user requests with a loop and do necessary updates
to menu with <code>menu_driver</code>.
</li>

<li>Unpost the menu with <code>menu_unpost()</code>
</li>

<li>Free the memory allocated to menu by <code>free_menu()</code>
</li>

<li>Free the memory allocated to the items with <code>free_item()</code>
</li>

<li>End curses
</li>
</ol>


<p>
Let's see a program which prints a simple menu and updates the
current selection with up, down arrows.
</p>
</div>
</div>

<div id="outline-container-sec-18-2" class="outline-3">
<h3 id="sec-18-2">17.2. Compiling With the Menu Library</h3>
<div class="outline-text-3" id="text-18-2">
<p>
To use menu library functions, you have to include menu.h and to
link the program with menu library the flag <code>-lmenu</code> should be
added along with <code>-lncurses</code> in that order.
</p>

<pre class="example">
#include &lt;menu.h&gt;
.
.
.

compile and link: gcc &lt;program file&gt; -lmenu -lncurses
</pre>

<p>
<a href="ncurses_programs/basics/"><b>Example 18. Menu Basics</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;curses.h&gt;
#include &lt;menu.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Exit",
};

int main()
{   ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;


  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));

  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);
  my_items[n_choices] = (ITEM *)NULL;

  my_menu = new_menu((ITEM **)my_items);
  mvprintw(LINES - 2, 0, "F1 to Exit");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1))
    {   switch(c)
        {   case KEY_DOWN:
            menu_driver(my_menu, REQ_DOWN_ITEM);
            break;
        case KEY_UP:
          menu_driver(my_menu, REQ_UP_ITEM);
          break;
        }
    }

  free_item(my_items[0]);
  free_item(my_items[1]);
  free_menu(my_menu);
  endwin();
}
</pre>
</div>

<p>
This program demonstrates the basic concepts involved in creating a
menu using menus library. First we create the items using
<code>new_item()</code> and then attach them to the menu with <code>new_menu()</code>
function. After posting the menu and refreshing the screen, the
main processing loop starts. It reads user input and takes
corresponding action. The function <code>menu_driver()</code> is the main work
horse of the menu system. The second parameter to this function
tells what's to be done with the menu.  According to the parameter,
<code>menu_driver()</code> does the corresponding task.  The value can be
either a menu navigational request, an ascii character, or a
<code>KEY_MOUSE</code> special key associated with a mouse event.
</p>

<p>
The <code>menu_driver</code> accepts following navigational requests.
</p>

<pre class="example">
REQ_LEFT_ITEM       Move left to an item.
REQ_RIGHT_ITEM      Move right to an item.
REQ_UP_ITEM         Move up to an item.
REQ_DOWN_ITEM       Move down to an item.
REQ_SCR_ULINE       Scroll up a line.
REQ_SCR_DLINE       Scroll down a line.
REQ_SCR_DPAGE       Scroll down a page.
REQ_SCR_UPAGE       Scroll up a page.
REQ_FIRST_ITEM      Move to the first item.
REQ_LAST_ITEM       Move to the last item.
REQ_NEXT_ITEM       Move to the next item.
REQ_PREV_ITEM       Move to the previous item.
REQ_TOGGLE_ITEM     Select/deselect an item.
REQ_CLEAR_PATTERN   Clear the menu pattern buffer.
REQ_BACK_PATTERN    Delete the previous character from the pattern buffer.
REQ_NEXT_MATCH      Move to the next item matching the pattern match.
REQ_PREV_MATCH      Move to the previous item matching the pattern match.
</pre>

<p>
Don't get overwhelmed by the number of options. We will see them
slowly one after another. The options of interest in this example
are <code>REQ_UP_ITEM</code> and <code>REQ_DOWN_ITEM</code>. These two options when
passed to <code>menu_driver</code>, menu driver updates the current item to
one item up or down respectively.
</p>
</div>
</div>

<div id="outline-container-sec-18-3" class="outline-3">
<h3 id="sec-18-3">17.3. Menu Driver: The work horse of the menu system</h3>
<div class="outline-text-3" id="text-18-3">
<p>
As you have seen in the above example, <code>menu_driver</code> plays an
important role in updating the menu. It is very important to
understand various options it takes and what they do. As explained
above, the second parameter to <code>menu_driver()</code> can be either a
navigational request, a printable character or a <code>KEY_MOUSE</code>
key. Let's dissect the different navigational requests.
</p>

<ul class="org-ul">
<li><code>REQ_LEFT_ITEM</code> and <code>REQ_RIGHT_ITEM</code>

<p>
A Menu can be displayed with multiple columns for more than one
item.  This can be done by using the
=menu<sub>format</sub>()=function. When a multi columnar menu is displayed
these requests cause the menu driver to move the current
selection to left or right.
</p>
</li>

<li><code>REQ_UP_ITEM</code> and <code>REQ_DOWN_ITEM</code>

<p>
These two options you have seen in the above example. These
options when given, makes the <code>menu_driver</code> to move the current
selection to an item up or down.
</p>
</li>

<li><code>REQ_SCR_*</code> options

<p>
The four options <code>REQ_SCR_ULINE</code>, <code>REQ_SCR_DLINE</code>,
<code>REQ_SCR_DPAGE</code>, <code>REQ_SCR_UPAGE</code> are related to scrolling. If all
the items in the menu cannot be displayed in the menu sub window,
then the menu is scrollable. These requests can be given to the
<code>menu_driver</code> to do the scrolling either one line up, down or one
page down or up respectively.
</p>
</li>

<li><code>REQ_FIRST_ITEM</code>, <code>REQ_LAST_ITEM</code>, <code>REQ_NEXT_ITEM</code> and
<code>REQ_PREV_ITEM</code>

<p>
These requests are self explanatory.
</p>
</li>

<li><code>REQ_TOGGLE_ITEM</code>

<p>
This request when given, toggles the present selection. This
option is to be used only in a multi valued menu. So to use this
request the option <code>O_ONEVALUE</code> must be off. This option can be
made off or on with <code>set_menu_opts()</code>.
</p>
</li>

<li><i>Pattern Requests</i>

<p>
Every menu has an associated pattern buffer, which is used to
find the nearest match to the ascii characters entered by the
user.  Whenever ascii characters are given to <code>menu_driver</code>, it
puts in to the pattern buffer. It also tries to find the nearest
match to the pattern in the items list and moves current
selection to that item.  The request <code>REQ_CLEAR_PATTERN</code> clears
the pattern buffer. The request <code>REQ_BACK_PATTERN</code> deletes the
previous character in the pattern buffer. In case the pattern
matches more than one item then the matched items can be cycled
through <code>REQ_NEXT_MATCH</code> and <code>REQ_PREV_MATCH</code> which move the
current selection to the next and previous matches respectively.
</p>
</li>

<li><i>Mouse Requests</i>

<p>
In case of <code>KEY_MOUSE</code> requests, according to the mouse position
an action is taken accordingly. The action to be taken is
explained in the man page as,
</p>

<blockquote>
<p>
If  the  second argument is the KEY<sub>MOUSE</sub> special key, the
associated mouse event is translated into one of the above
pre-defined  requests.   Currently only clicks in the user
window (e.g. inside the menu display area or  the  decora­
tion  window)  are handled. If you click above the display
region of the menu, a REQ<sub>SCR</sub><sub>ULINE</sub> is generated,  if  you
doubleclick  a  REQ<sub>SCR</sub><sub>UPAGE</sub>  is  generated  and  if  you
tripleclick a REQ<sub>FIRST</sub><sub>ITEM</sub> is generated.  If  you  click
below  the  display region of the menu, a REQ<sub>SCR</sub><sub>DLINE</sub> is
generated, if you doubleclick a REQ<sub>SCR</sub><sub>DPAGE</sub> is generated
and  if  you  tripleclick a REQ<sub>LAST</sub><sub>ITEM</sub> is generated. If
you click at an item inside the display area of the  menu,
the menu cursor is positioned to that item.
</p>
</blockquote>
</li>
</ul>


<p>
Each of the above requests will be explained in the following lines
with several examples whenever appropriate.
</p>
</div>
</div>

<div id="outline-container-sec-18-4" class="outline-3">
<h3 id="sec-18-4">17.4. Menu Windows</h3>
<div class="outline-text-3" id="text-18-4">
<p>
Every menu created is associated with a window and a sub
window. The menu window displays any title or border associated
with the menu. The menu sub window displays the menu items
currently available for selection. But we didn't specify any window
or sub window in the simple example. When a window is not
specified, <code>stdscr</code> is taken as the main window, and then menu system
calculates the sub window size required for the display of
items. Then items are displayed in the calculated sub window. So
let's play with these windows and display a menu with a border and
a title.
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 19. Menu Windows Usage example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;menu.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Exit",
  (char *)NULL,
};
void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

int main()
{   ITEM **my_items;
  int c;
  MENU *my_menu;
  WINDOW *my_menu_win;
  int n_choices, i;

  /* Initialize curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);

  /* Create items */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);

  /* Crate menu */
  my_menu = new_menu((ITEM **)my_items);

  /* Create the window to be associated with the menu */
  my_menu_win = newwin(10, 40, 4, 4);
  keypad(my_menu_win, TRUE);

  /* Set main window and sub window */
  set_menu_win(my_menu, my_menu_win);
  set_menu_sub(my_menu, derwin(my_menu_win, 6, 38, 3, 1));

  /* Set menu mark to the string " * " */
  set_menu_mark(my_menu, " * ");

  /* Print a border around the main window and print a title */
  box(my_menu_win, 0, 0);
  print_in_middle(my_menu_win, 1, 0, 40, "My Menu", COLOR_PAIR(1));
  mvwaddch(my_menu_win, 2, 0, ACS_LTEE);
  mvwhline(my_menu_win, 2, 1, ACS_HLINE, 38);
  mvwaddch(my_menu_win, 2, 39, ACS_RTEE);
  mvprintw(LINES - 2, 0, "F1 to exit");
  refresh();

  /* Post the menu */
  post_menu(my_menu);
  wrefresh(my_menu_win);

  while((c = wgetch(my_menu_win)) != KEY_F(1))
    {       switch(c)
        {   case KEY_DOWN:
            menu_driver(my_menu, REQ_DOWN_ITEM);
            break;
        case KEY_UP:
          menu_driver(my_menu, REQ_UP_ITEM);
          break;
        }
      wrefresh(my_menu_win);
    }

  /* Unpost and free all the memory taken up */
  unpost_menu(my_menu);
  free_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  endwin();
}

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
{   int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</pre>
</div>

<p>
This example creates a menu with a title, border, a fancy line
separating title and the items. As you can see, in order to attach
a window to a menu the function <code>set_menu_win()</code> has to be
used. Then we attach the sub window also. This displays the items
in the sub window.  You can also set the mark string which gets
displayed to the left of the selected item with <code>set_menu_mark()</code>.
</p>
</div>
</div>

<div id="outline-container-sec-18-5" class="outline-3">
<h3 id="sec-18-5">17.5. Scrolling Menus</h3>
<div class="outline-text-3" id="text-18-5">
<p>
If the sub window given for a window is not big enough to show all
the items, then the menu will be scrollable. When you are on the
last item in the present list, if you send <code>REQ_DOWN_ITEM</code>, it gets
translated into <code>REQ_SCR_DLINE</code> and the menu scrolls by one
item. You can manually give <code>REQ_SCR_</code> operations to do
scrolling. Let's see how it can be done.
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 20. Scrolling Menus example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;curses.h&gt;
#include &lt;menu.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Choice 5",
  "Choice 6",
  "Choice 7",
  "Choice 8",
  "Choice 9",
  "Choice 10",
  "Exit",
  (char *)NULL,
};
void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

int main()
{   ITEM **my_items;
  int c;
  MENU *my_menu;
  WINDOW *my_menu_win;
  int n_choices, i;

  /* Initialize curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_CYAN, COLOR_BLACK);

  /* Create items */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);

  /* Crate menu */
  my_menu = new_menu((ITEM **)my_items);

  /* Create the window to be associated with the menu */
  my_menu_win = newwin(10, 40, 4, 4);
  keypad(my_menu_win, TRUE);

  /* Set main window and sub window */
  set_menu_win(my_menu, my_menu_win);
  set_menu_sub(my_menu, derwin(my_menu_win, 6, 38, 3, 1));
  set_menu_format(my_menu, 5, 1);

  /* Set menu mark to the string " * " */
  set_menu_mark(my_menu, " * ");

  /* Print a border around the main window and print a title */
  box(my_menu_win, 0, 0);
  print_in_middle(my_menu_win, 1, 0, 40, "My Menu", COLOR_PAIR(1));
  mvwaddch(my_menu_win, 2, 0, ACS_LTEE);
  mvwhline(my_menu_win, 2, 1, ACS_HLINE, 38);
  mvwaddch(my_menu_win, 2, 39, ACS_RTEE);

  /* Post the menu */
  post_menu(my_menu);
  wrefresh(my_menu_win);

  attron(COLOR_PAIR(2));
  mvprintw(LINES - 2, 0, "Use PageUp and PageDown to scoll down or up a page of items");
  mvprintw(LINES - 1, 0, "Arrow Keys to navigate (F1 to Exit)");
  attroff(COLOR_PAIR(2));
  refresh();

  while((c = wgetch(my_menu_win)) != KEY_F(1))
    {       switch(c)
        {   case KEY_DOWN:
            menu_driver(my_menu, REQ_DOWN_ITEM);
            break;
        case KEY_UP:
          menu_driver(my_menu, REQ_UP_ITEM);
          break;
        case KEY_NPAGE:
          menu_driver(my_menu, REQ_SCR_DPAGE);
          break;
        case KEY_PPAGE:
          menu_driver(my_menu, REQ_SCR_UPAGE);
          break;
        }
      wrefresh(my_menu_win);
    }

  /* Unpost and free all the memory taken up */
  unpost_menu(my_menu);
  free_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  endwin();
}

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
{   int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</pre>
</div>

<p>
This program is self-explanatory. In this example the number of
choices has been increased to ten, which is larger than our sub
window size which can hold 6 items. This message has to be
explicitly conveyed to the menu system with the function
<code>set_menu_format()</code>. In here we specify the number of rows and
columns we want to be displayed for a single page. We can specify
any number of items to be shown, in the rows variables, if it is
less than the height of the sub window. If the key pressed by the
user is a PAGE UP or PAGE DOWN, the menu is scrolled a page due to
the requests (<code>REQ_SCR_DPAGE</code> and <code>REQ_SCR_UPAGE</code>) given to
<code>menu_driver()</code>.
</p>
</div>
</div>

<div id="outline-container-sec-18-6" class="outline-3">
<h3 id="sec-18-6">17.6. Multi Columnar Menus</h3>
<div class="outline-text-3" id="text-18-6">
<p>
In the above example you have seen how to use the function
<code>set_menu_format()</code>. I didn't mention what the cols variable (third
parameter) does. Well, If your sub window is wide enough, you can
opt to display more than one item per row. This can be specified in
the cols variable. To make things simpler, the following example
doesn't show descriptions for the items.
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 21. Milt Columnar Menus Example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;curses.h&gt;
#include &lt;menu.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",  "Choice 2",  "Choice 3",  "Choice 4",  "Choice 5",
  "Choice 6",  "Choice 7",  "Choice 8",  "Choice 9",  "Choice 10",
  "Choice 11", "Choice 12", "Choice 13", "Choice 14", "Choice 15",
  "Choice 16", "Choice 17", "Choice 18", "Choice 19", "Choice 20",
  "Exit",
  (char *)NULL,
};

int main()
{   ITEM **my_items;
  int c;
  MENU *my_menu;
  WINDOW *my_menu_win;
  int n_choices, i;

  /* Initialize curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_CYAN, COLOR_BLACK);

  /* Create items */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);

  /* Crate menu */
  my_menu = new_menu((ITEM **)my_items);

  /* Set menu option not to show the description */
  menu_opts_off(my_menu, O_SHOWDESC);

  /* Create the window to be associated with the menu */
  my_menu_win = newwin(10, 70, 4, 4);
  keypad(my_menu_win, TRUE);

  /* Set main window and sub window */
  set_menu_win(my_menu, my_menu_win);
  set_menu_sub(my_menu, derwin(my_menu_win, 6, 68, 3, 1));
  set_menu_format(my_menu, 5, 3);
  set_menu_mark(my_menu, " * ");

  /* Print a border around the main window and print a title */
  box(my_menu_win, 0, 0);

  attron(COLOR_PAIR(2));
  mvprintw(LINES - 3, 0, "Use PageUp and PageDown to scroll");
  mvprintw(LINES - 2, 0, "Use Arrow Keys to navigate (F1 to Exit)");
  attroff(COLOR_PAIR(2));
  refresh();

  /* Post the menu */
  post_menu(my_menu);
  wrefresh(my_menu_win);

  while((c = wgetch(my_menu_win)) != KEY_F(1))
    {       switch(c)
        {   case KEY_DOWN:
            menu_driver(my_menu, REQ_DOWN_ITEM);
            break;
        case KEY_UP:
          menu_driver(my_menu, REQ_UP_ITEM);
          break;
        case KEY_LEFT:
          menu_driver(my_menu, REQ_LEFT_ITEM);
          break;
        case KEY_RIGHT:
          menu_driver(my_menu, REQ_RIGHT_ITEM);
          break;
        case KEY_NPAGE:
          menu_driver(my_menu, REQ_SCR_DPAGE);
          break;
        case KEY_PPAGE:
          menu_driver(my_menu, REQ_SCR_UPAGE);
          break;
        }
      wrefresh(my_menu_win);
    }

  /* Unpost and free all the memory taken up */
  unpost_menu(my_menu);
  free_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  endwin();
}
</pre>
</div>

<p>
Watch the function call to <code>set_menu_format()</code>. It specifies the
number of columns to be 3, thus displaying 3 items per row. We have
also switched off the showing descriptions with the function
<code>menu_opts_off()</code>. There are couple of functions <code>set_menu_opts()</code>,
<code>menu_opts_on()</code> and <code>menu_opts()</code> which can be used to manipulate
menu options. The following menu options can be specified.
</p>

<pre class="example">
O_ONEVALUE
     Only one item can be selected for this menu.

O_SHOWDESC
     Display  the  item  descriptions  when  the  menu  is
     posted.

O_ROWMAJOR
     Display the menu in row-major order.

O_IGNORECASE
     Ignore the case when pattern-matching.

O_SHOWMATCH
     Move the cursor to within the item  name  while  pat­
     tern-matching.

O_NONCYCLIC
     Don't   wrap   around  next-item  and  previous-item,
     requests to the other end of the menu.
</pre>

<p>
All options are on by default. You can switch specific attributes
on or off with <code>menu_opts_on()</code> and <code>menu_opts_off()</code>
functions. You can also use <code>set_menu_opts()</code> to directly specify
the options. The argument to this function should be a OR ed value
of some of those above constants.  The function <code>menu_opts()</code> can
be used to find out a menu's present options.
</p>
</div>
</div>

<div id="outline-container-sec-18-7" class="outline-3">
<h3 id="sec-18-7">17.7. Multi Valued Menus</h3>
<div class="outline-text-3" id="text-18-7">
<p>
You might be wondering what if you switch off the option
<code>O_ONEVALUE</code>.  Then the menu becomes multi-valued. That means you
can select more than one item. This brings us to the request
<code>REQ_TOGGLE_ITEM</code>. Let's see it in action.
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 22. Multi Valued Menus example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;curses.h&gt;
#include &lt;menu.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Choice 5",
  "Choice 6",
  "Choice 7",
  "Exit",
};

int main()
{   ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;

  /* Initialize curses */
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Initialize items */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);
  my_items[n_choices] = (ITEM *)NULL;

  my_menu = new_menu((ITEM **)my_items);

  /* Make the menu multi valued */
  menu_opts_off(my_menu, O_ONEVALUE);

  mvprintw(LINES - 3, 0, "Use &lt;SPACE&gt; to select or unselect an item.");
  mvprintw(LINES - 2, 0, "&lt;ENTER&gt; to see presently selected items(F1 to Exit)");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1))
    {       switch(c)
        {   case KEY_DOWN:
            menu_driver(my_menu, REQ_DOWN_ITEM);
            break;
        case KEY_UP:
          menu_driver(my_menu, REQ_UP_ITEM);
          break;
        case ' ':
          menu_driver(my_menu, REQ_TOGGLE_ITEM);
          break;
        case 10:    /* Enter */
          {   char temp[200];
            ITEM **items;

            items = menu_items(my_menu);
            temp[0] = '\0';
            for(i = 0; i &lt; item_count(my_menu); ++i)
              if(item_value(items[i]) == TRUE)
                {   strcat(temp, item_name(items[i]));
                  strcat(temp, " ");
                }
            move(20, 0);
            clrtoeol();
            mvprintw(20, 0, temp);
            refresh();
          }
          break;
        }
    }

  free_item(my_items[0]);
  free_item(my_items[1]);
  free_menu(my_menu);
  endwin();
}
</pre>
</div>

<p>
Whew, A lot of new functions. Let's take them one after another.
Firstly, the <code>REQ_TOGGLE_ITEM</code>. In a multi-valued menu, the user
should be allowed to select or un select more than one item. The
request <code>REQ_TOGGLE_ITEM</code> toggles the present selection. In this
case when space is pressed <code>REQ_TOGGLE_ITEM</code> request is sent to
<code>menu_driver</code> to achieve the result.
</p>

<p>
Now when the user presses &lt;ENTER&gt; we show the items he presently
selected. First we find out the items associated with the menu
using the function <code>menu_items()</code>. Then we loop through the items
to find out if the item is selected or not. The function
<code>item_value()</code> returns TRUE if an item is selected. The function
<code>item_count()</code> returns the number of items in the menu. The item
name can be found with <code>item_name()</code>. You can also find the
description associated with an item using <code>item_description()</code>.
</p>
</div>
</div>

<div id="outline-container-sec-18-8" class="outline-3">
<h3 id="sec-18-8">17.8. Menu Options</h3>
<div class="outline-text-3" id="text-18-8">
<p>
Well, by this time you must be itching for some difference in your
menu, with lots of functionality. I know. You want Colors !!!. You
want to create nice menus similar to those text mode <a href="http://www.jersey.net/~debinjoe/games/">dos games</a>. The
functions <code>set_menu_fore()</code> and <code>set_menu_back()</code> can be used to
change the attribute of the selected item and unselected item. The
names are misleading. They don't change menu's foreground or
background which would have been useless.
</p>

<p>
The function <code>set_menu_grey()</code> can be used to set the display
attribute for the non-selectable items in the menu. This brings us
to the interesting option for an item the one and only
<code>O_SELECTABLE</code>. We can turn it off by the function
<code>item_opts_off()</code> and after that that item is not selectable. It's
like a grayed item in those fancy windows menus.  Let's put these
concepts in practice with this example
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 23. Menu Options example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;menu.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Choice 5",
  "Choice 6",
  "Choice 7",
  "Exit",
};

int main()
{   ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;

  /* Initialize curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_MAGENTA, COLOR_BLACK);

  /* Initialize items */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);
  my_items[n_choices] = (ITEM *)NULL;
  item_opts_off(my_items[3], O_SELECTABLE);
  item_opts_off(my_items[6], O_SELECTABLE);

  /* Create menu */
  my_menu = new_menu((ITEM **)my_items);

  /* Set fore ground and back ground of the menu */
  set_menu_fore(my_menu, COLOR_PAIR(1) | A_REVERSE);
  set_menu_back(my_menu, COLOR_PAIR(2));
  set_menu_grey(my_menu, COLOR_PAIR(3));

  /* Post the menu */
  mvprintw(LINES - 3, 0, "Press &lt;ENTER&gt; to see the option selected");
  mvprintw(LINES - 2, 0, "Up and Down arrow keys to naviage (F1 to Exit)");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1))
    {       switch(c)
        {   case KEY_DOWN:
            menu_driver(my_menu, REQ_DOWN_ITEM);
            break;
        case KEY_UP:
          menu_driver(my_menu, REQ_UP_ITEM);
          break;
        case 10: /* Enter */
          move(20, 0);
          clrtoeol();
          mvprintw(20, 0, "Item selected is : %s",
                   item_name(current_item(my_menu)));
          pos_menu_cursor(my_menu);
          break;
        }
    }
  unpost_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  free_menu(my_menu);
  endwin();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-18-9" class="outline-3">
<h3 id="sec-18-9">17.9. The useful User Pointer</h3>
<div class="outline-text-3" id="text-18-9">
<p>
We can associate a user pointer with each item in the menu. It
works the same way as user pointer in panels. It's not touched by
menu system. You can store any thing you like in that. I usually
use it to store the function to be executed when the menu option is
chosen (It's selected and may be the user pressed &lt;ENTER&gt;);
</p>


<p>
<a href="ncurses_programs/basics/"><b>Example 24. Menu User Pointer Usage</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;curses.h&gt;
#include &lt;menu.h&gt;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Choice 5",
  "Choice 6",
  "Choice 7",
  "Exit",
};
void func(char *name);

int main()
{   ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;

  /* Initialize curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_MAGENTA, COLOR_BLACK);

  /* Initialize items */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    {       my_items[i] = new_item(choices[i], choices[i]);
      /* Set the user pointer */
      set_item_userptr(my_items[i], func);
    }
  my_items[n_choices] = (ITEM *)NULL;

  /* Create menu */
  my_menu = new_menu((ITEM **)my_items);

  /* Post the menu */
  mvprintw(LINES - 3, 0, "Press &lt;ENTER&gt; to see the option selected");
  mvprintw(LINES - 2, 0, "Up and Down arrow keys to naviage (F1 to Exit)");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1))
    {       switch(c)
        {   case KEY_DOWN:
            menu_driver(my_menu, REQ_DOWN_ITEM);
            break;
        case KEY_UP:
          menu_driver(my_menu, REQ_UP_ITEM);
          break;
        case 10: /* Enter */
          {   ITEM *cur;
            void (*p)(char *);

            cur = current_item(my_menu);
            p = item_userptr(cur);
            p((char *)item_name(cur));
            pos_menu_cursor(my_menu);
            break;
          }
          break;
        }
    }
  unpost_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  free_menu(my_menu);
  endwin();
}

void func(char *name)
{   move(20, 0);
  clrtoeol();
  mvprintw(20, 0, "Item selected is : %s", name);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19">18. Forms Library</h2>
<div class="outline-text-2" id="text-19">
<p>
Well. If you have seen those forms on web pages which take input
from users and do various kinds of things, you might be wondering
how would any one create such forms in text mode display. It's quite
difficult to write those nifty forms in plain ncurses. Forms library
tries to provide a basic frame work to build and maintain forms with
ease. It has lot of features(functions) which manage validation,
dynamic expansion of fields etc.. Let's see it in full flow.
</p>

<p>
A form is a collection of fields; each field can be either a
label(static text) or a data-entry location. The forms also library
provides functions to divide forms into multiple pages.
</p>
</div>

<div id="outline-container-sec-19-1" class="outline-3">
<h3 id="sec-19-1">18.1. The Basics</h3>
<div class="outline-text-3" id="text-19-1">
<p>
Forms are created in much the same way as menus. First the fields
related to the form are created with <code>new_field()</code>. You can set
options for the fields, so that they can be displayed with some
fancy attributes, validated before the field looses focus
etc.. Then the fields are attached to form. After this, the form
can be posted to display and is ready to receive inputs. On the
similar lines to <code>menu_driver()</code>, the form is manipulated with
<code>form_driver()</code>. We can send requests to <code>form_driver</code> to move
focus to a certain field, move cursor to end of the field
etc.. After the user enters values in the fields and validation
done, form can be unposted and memory allocated can be freed.
</p>

<p>
The general flow of control of a forms program looks like this.
</p>

<ol class="org-ol">
<li>Initialize curses
</li>

<li>Create fields using <code>new_field()</code>. You can specify the height and
width of the field, and its position on the form.
</li>

<li>Create the forms with <code>new_form()</code> by specifying the fields to
be attached with.
</li>

<li>Post the form with <code>form_post()</code> and refresh the screen.
</li>

<li>Process the user requests with a loop and do necessary updates
to form with <code>form_driver</code>.
</li>

<li>Unpost the menu with <code>form_unpost()</code>
</li>

<li>Free the memory allocated to menu by <code>free_form()</code>
</li>

<li>Free the memory allocated to the items with <code>free_field()</code>
</li>

<li>End curses
</li>
</ol>

<p>
As you can see, working with forms library is much similar to
handling menu library. The following examples will explore various
aspects of form processing. Let's start the journey with a simple
example. first.
</p>
</div>
</div>

<div id="outline-container-sec-19-2" class="outline-3">
<h3 id="sec-19-2">18.2. Compiling With the Forms Library</h3>
<div class="outline-text-3" id="text-19-2">
<p>
To use forms library functions, you have to include form.h and to
link the program with forms library the flag <code>-lform</code> should be
added along with <code>-lncurses</code> in that order.
</p>

<pre class="example">
#include &lt;form.h&gt;
.
.
.

compile and link: gcc &lt;program file&gt; -lform -lncurses
</pre>

<p>
<a href="ncurses_programs/basics/"><b>Example 25. Forms Basics</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;form.h&gt;

int main()
{   FIELD *field[3];
  FORM  *my_form;
  int ch;

  /* Initialize curses */
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Initialize the fields */
  field[0] = new_field(1, 10, 4, 18, 0, 0);
  field[1] = new_field(1, 10, 6, 18, 0, 0);
  field[2] = NULL;

  /* Set field options */
  set_field_back(field[0], A_UNDERLINE);  /* Print a line for the option      */
  field_opts_off(field[0], O_AUTOSKIP);   /* Don't go to next field when this */
                                          /* Field is filled up               */
  set_field_back(field[1], A_UNDERLINE);
  field_opts_off(field[1], O_AUTOSKIP);

  /* Create the form and post it */
  my_form = new_form(field);
  post_form(my_form);
  refresh();

  mvprintw(4, 10, "Value 1:");
  mvprintw(6, 10, "Value 2:");
  refresh();

  /* Loop through to get user requests */
  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case KEY_DOWN:
            /* Go to next field */
            form_driver(my_form, REQ_NEXT_FIELD);
            /* Go to the end of the present buffer */
            /* Leaves nicely at the last character */
            form_driver(my_form, REQ_END_LINE);
            break;
        case KEY_UP:
          /* Go to previous field */
          form_driver(my_form, REQ_PREV_FIELD);
          form_driver(my_form, REQ_END_LINE);
          break;
        default:
          /* If this is a normal character, it gets */
          /* Printed                */
          form_driver(my_form, ch);
          break;
        }
    }

  /* Un post form and free the memory */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}
</pre>
</div>

<p>
Above example is pretty straight forward. It creates two fields
with <code>new_field()</code>. <code>new_field()</code> takes height, width, starty,
startx, number of offscreen rows and number of additional working
buffers. The fifth argument number of offscreen rows specifies how
much of the field to be shown. If it is zero, the entire field is
always displayed otherwise the form will be scrollable when the
user accesses not displayed parts of the field. The forms library
allocates one buffer per field to store the data user enters. Using
the last parameter to <code>new_field()</code> we can specify it to allocate
some additional buffers. These can be used for any purpose you
like.
</p>

<p>
After creating the fields, back ground attribute of both of them is
set to an underscore with <code>set_field_back()</code>. The AUTOSKIP option
is turned off using <code>field_opts_off()</code>. If this option is turned
on, focus will move to the next field in the form once the active
field is filled up completely.
</p>

<p>
After attaching the fields to the form, it is posted. Here on, user
inputs are processed in the while loop, by making corresponding
requests to <code>form_driver</code>. The details of all the requests to the
<code>form_driver()</code> are explained later.
</p>
</div>
</div>

<div id="outline-container-sec-19-3" class="outline-3">
<h3 id="sec-19-3">18.3. Playing with Fields</h3>
<div class="outline-text-3" id="text-19-3">
<p>
Each form field is associated with a lot of attributes. They can be
manipulated to get the required effect and to have fun !!!. So why
wait?
</p>
</div>

<div id="outline-container-sec-19-3-1" class="outline-4">
<h4 id="sec-19-3-1">18.3.1. Fetching Size and Location of Field</h4>
<div class="outline-text-4" id="text-19-3-1">
<p>
The parameters we have given at the time of creation of a field
can be retrieved with <code>field_info()</code>. It returns height, width,
starty, startx, number of offscreen rows, and number of additional
buffers into the parameters given to it. It is a sort of inverse
of <code>new_field()</code>.
</p>

<div class="org-src-container">

<pre class="src src-c">int field_info(     FIELD *field,              /* field from which to fetch */
                    int *height, *int width,   /* field size                */
                    int *top, int *left,       /* upper left corner         */
                    int *offscreen,            /* number of offscreen rows  */
                    int *nbuf);                /* number of working buffers */
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-19-3-2" class="outline-4">
<h4 id="sec-19-3-2">18.3.2. Moving the field</h4>
<div class="outline-text-4" id="text-19-3-2">
<p>
The location of the field can be moved to a different position
with <code>move_field()</code>.
</p>

<div class="org-src-container">

<pre class="src src-c">int move_field(    FIELD *field,              /* field to alter */
                   int top, int left);        /* new upper-left corner */
</pre>
</div>

<p>
As usual, the changed position can be queried with
<code>field_infor()</code>.
</p>
</div>
</div>

<div id="outline-container-sec-19-3-3" class="outline-4">
<h4 id="sec-19-3-3">18.3.3. Field Justification</h4>
<div class="outline-text-4" id="text-19-3-3">
<p>
The justification to be done for the field can be fixed using the
function <code>set_field_just()</code>.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_just(FIELD *field,       /* field to alter              */
                   int justmode);      /* mode to set                 */
int field_just(FIELD *field);          /* fetch justify mode of field */
</pre>
</div>

<p>
The justification mode valued accepted and returned by these
functions are <code>NO_JUSTIFICATION</code>, <code>JUSTIFY_RIGHT</code>, <code>JUSTIFY_LEFT</code>,
or <code>JUSTIFY_CENTER</code>.
</p>
</div>
</div>

<div id="outline-container-sec-19-3-4" class="outline-4">
<h4 id="sec-19-3-4">18.3.4. Field Display Attributes</h4>
<div class="outline-text-4" id="text-19-3-4">
<p>
As you have seen, in the above example, display attribute for the
fields can be set with <code>set_field_fore()</code> and
<code>setfield_back()</code>. These functions set foreground and background
attribute of the fields. You can also specify a pad character
which will be filled in the unfilled portion of the field. The pad
character is set with a call to <code>set_field_pad()</code>.  Default pad
value is a space. The functions <code>field_fore()</code>, <code>field_back</code>,
<code>field_pad()</code> can be used to query the present foreground,
background attributes and pad character for the field. The
following list gives the usage of functions.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_fore(FIELD *field,        /* field to alter                */
                   chtype attr);        /* attribute to set              */

chtype field_fore(FIELD *field);        /* field to query                */
                                        /* returns foreground attribute  */

int set_field_back(FIELD *field,        /* field to alter                */
                   chtype attr);        /* attribute to set              */

chtype field_back(FIELD *field);        /* field to query                */
                                        /* returns background attribute  */

int set_field_pad(FIELD *field,         /* field to alter                */
                  int pad);             /* pad character to set          */

chtype field_pad(FIELD *field);         /* field to query                */
                                        /* returns present pad character */
</pre>
</div>

<p>
Though above functions seem quite simple, using colors with
<code>set_field_fore()</code> may be frustrating in the beginning. Let me
first explain about foreground and background attributes of a
field. The foreground attribute is associated with the
character. That means a character in the field is printed with the
attribute you have set with <code>set_field_fore()</code>. Background
attribute is the attribute used to fill background of field,
whether any character is there or not. So what about colors? Since
colors are always defined in pairs, what is the right way to
display colored fields? Here's an example clarifying color
attributes.
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 26. Form Attributes example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;form.h&gt;

int main()
{   FIELD *field[3];
  FORM  *my_form;
  int ch;

  /* Initialize curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Initialize few color pairs */
  init_pair(1, COLOR_WHITE, COLOR_BLUE);
  init_pair(2, COLOR_WHITE, COLOR_BLUE);

  /* Initialize the fields */
  field[0] = new_field(1, 10, 4, 18, 0, 0);
  field[1] = new_field(1, 10, 6, 18, 0, 0);
  field[2] = NULL;

  /* Set field options */
  set_field_fore(field[0], COLOR_PAIR(1));     /* Put the field with blue background */
  set_field_back(field[0], COLOR_PAIR(2));     /* and white foreground (characters   */
                                               /* are printed in white               */
  field_opts_off(field[0], O_AUTOSKIP);        /* Don't go to next field when this   */
                                               /* Field is filled up                 */
  set_field_back(field[1], A_UNDERLINE);
  field_opts_off(field[1], O_AUTOSKIP);

  /* Create the form and post it */
  my_form = new_form(field);
  post_form(my_form);
  refresh();

  set_current_field(my_form, field[0]);        /* Set focus to the colored field     */
  mvprintw(4, 10, "Value 1:");
  mvprintw(6, 10, "Value 2:");
  mvprintw(LINES - 2, 0, "Use UP, DOWN arrow keys to switch between fields");
  refresh();

  /* Loop through to get user requests */
  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case KEY_DOWN:
            /* Go to next field */
            form_driver(my_form, REQ_NEXT_FIELD);
            /* Go to the end of the present buffer */
            /* Leaves nicely at the last character */
            form_driver(my_form, REQ_END_LINE);
            break;
        case KEY_UP:
          /* Go to previous field */
          form_driver(my_form, REQ_PREV_FIELD);
          form_driver(my_form, REQ_END_LINE);
          break;
        default:
          /* If this is a normal character, it gets */
          /* Printed                */
          form_driver(my_form, ch);
          break;
        }
    }

  /* Un post form and free the memory */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}
</pre>
</div>

<p>
Play with the color pairs and try to understand the foreground and
background attributes. In my programs using color attributes, I
usually set only the background with <code>set_field_back()</code>. Curses
simply doesn't allow defining individual color attributes.
</p>
</div>
</div>

<div id="outline-container-sec-19-3-5" class="outline-4">
<h4 id="sec-19-3-5">18.3.5. Field Option Bits</h4>
<div class="outline-text-4" id="text-19-3-5">
<p>
There is also a large collection of field option bits you can set to
control various aspects of forms processing. You can manipulate them
with these functions:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_opts(FIELD *field,          /* field to alter          */
                   int attr);             /* attribute to set        */

int field_opts_on(FIELD *field,           /* field to alter          */
                  int attr);              /* attributes to turn on   */

int field_opts_off(FIELD *field,          /* field to alter          */
                   int attr);              /* attributes to turn off */

int field_opts(FIELD *field);             /* field to query          */
</pre>
</div>

<p>
The function <code>set_field_opts()</code> can be used to directly set
attributes of a field or you can choose to switch a few attributes
on and off with <code>field_opts_on()</code> and <code>field_opts_off()</code>
selectively. Anytime you can query the attributes of a field with
<code>field_opts()</code>. The following is the list of available options. By
default, all options are on.
</p>


<dl class="org-dl">
<dt> <code>O_VISIBLE</code>  </dt><dd>Controls whether the field is visible on the
screen.  Can be used during form processing to
hide or pop up fields depending on the value of
parent fields.
</dd>

<dt> <code>O_ACTIVE</code>   </dt><dd>Controls whether the field is active during
forms processing (i.e. visited by form
navigation keys). Can be used to make labels or
derived fields with buffer values alterable by
the forms application, not the user.
</dd>

<dt> <code>O_PUBLIC</code>   </dt><dd>Controls whether data is displayed during field
entry.  If this option is turned off on a field,
the library will accept and edit data in that
field, but it will not be displayed and the
visible field cursor will not move. You can turn
off the <code>O_PUBLIC</code> bit to define password
fields.
</dd>

<dt> <code>O_EDIT</code>     </dt><dd>Controls whether the field's data can be
modified. When this option is off, all editing
requests except <code>REQ_PREV_CHOICE</code> and
<code>REQ_NEXT_CHOICE</code> will fail. Such read-only
fields may be useful for help messages.
</dd>

<dt> <code>O_WRAP</code>     </dt><dd>Controls word-wrapping in multi-line
fields. Normally, when any character of a
(blank-separated) word reaches the end of the
current line, the entire word is wrapped to the
next line (assuming there is one). When this
option is off, the word will be split across the
line break.
</dd>

<dt> <code>O_BLANK</code>    </dt><dd>Controls field blanking. When this option is on,
entering a character at the first field position
erases the entire field (except for the
just-entered character).
</dd>

<dt> <code>O_AUTOSKIP</code> </dt><dd>Controls automatic skip to next field when this
one fills. Normally, when the forms user tries
to type more data into a field than will fit,
the editing location jumps to next field. When
this option is off, the user's cursor will hang
at the end of the field. This option is ignored
in dynamic fields that have not reached their
size limit.
</dd>

<dt> <code>O_NULLOK</code>   </dt><dd>Controls whether validation is applied to blank
fields.  Normally, it is not; the user can leave
a field blank without invoking the usual
validation check on exit. If this option is off
on a field, exit from it will invoke a
validation check.
</dd>

<dt> <code>O_PASSOK</code>   </dt><dd>Controls whether validation occurs on every
exit, or only after the field is
modified. Normally the latter is true.  Setting
<code>O_PASSOK</code> may be useful if your field's
validation function may change during forms
processing.
</dd>

<dt> <code>O_STATIC</code>   </dt><dd>Controls whether the field is fixed to its
initial dimensions. If you turn this off, the
field becomes dynamic and will stretch to fit
entered data.
</dd>
</dl>


<p>
A field's options cannot be changed while the field is currently
selected. However, options may be changed on posted fields that
are not current.
</p>

<p>
The option values are bit-masks and can be composed with
logical-or in the obvious way. You have seen the usage of
switching off <code>O_AUTOSKIP</code> option. The following example clarifies
usage of some more options.  Other options are explained where
appropriate.
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 27. Field Options Usage example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;form.h&gt;

#define STARTX 15
#define STARTY 4
#define WIDTH 25

#define N_FIELDS 3

int main()
{   FIELD *field[N_FIELDS];
  FORM  *my_form;
  int ch, i;

  /* Initialize curses */
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Initialize the fields */
  for(i = 0; i &lt; N_FIELDS - 1; ++i)
    field[i] = new_field(1, WIDTH, STARTY + i * 2, STARTX, 0, 0);
  field[N_FIELDS - 1] = NULL;

  /* Set field options */
  set_field_back(field[1], A_UNDERLINE);  /* Print a line for the option         */

  field_opts_off(field[0], O_ACTIVE);     /* This field is a static label        */
  field_opts_off(field[1], O_PUBLIC);     /* This filed is like a password field */
  field_opts_off(field[1], O_AUTOSKIP);   /* To avoid entering the same field    */
                                          /* after last character is entered     */

  /* Create the form and post it */
  my_form = new_form(field);
  post_form(my_form);
  refresh();

  set_field_just(field[0], JUSTIFY_CENTER); /* Center Justification */
  set_field_buffer(field[0], 0, "This is a static Field");
  /* Initialize the field  */
  mvprintw(STARTY, STARTX - 10, "Field 1:");
  mvprintw(STARTY + 2, STARTX - 10, "Field 2:");
  refresh();

  /* Loop through to get user requests */
  while((ch = getch()) != KEY_F(1))
    {   switch(ch)
        {   case KEY_DOWN:
            /* Go to next field */
            form_driver(my_form, REQ_NEXT_FIELD);
            /* Go to the end of the present buffer */
            /* Leaves nicely at the last character */
            form_driver(my_form, REQ_END_LINE);
            break;
        case KEY_UP:
          /* Go to previous field */
          form_driver(my_form, REQ_PREV_FIELD);
          form_driver(my_form, REQ_END_LINE);
          break;
        default:
          /* If this is a normal character, it gets */
          /* Printed                */
          form_driver(my_form, ch);
          break;
        }
    }

  /* Un post form and free the memory */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}
</pre>
</div>

<p>
This example, though useless, shows the usage of options. If used
properly, they can present information very effectively in a
form. The second field being not <code>O_PUBLIC</code>, does not show the
characters you are typing.
</p>
</div>
</div>

<div id="outline-container-sec-19-3-6" class="outline-4">
<h4 id="sec-19-3-6">18.3.6. Field Status</h4>
<div class="outline-text-4" id="text-19-3-6">
<p>
The field status specifies whether the field has got edited or
not. It is initially set to FALSE and when user enters something
and the data buffer gets modified it becomes TRUE. So a field's
status can be queried to find out whether it has been modified or
not. The following functions can assist in those operations.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_status(FIELD *field,      /* field to alter */
                     int status);       /* status to set  */

int field_status(FIELD *field);         /* fetch status of field */
</pre>
</div>

<p>
It's better to check the field's status only after after leaving
the field, as data buffer might not have been updated yet as the
validation is still due. To guarantee that right status is
returned, call <code>field_status()</code> either (1) in the field's exit
validation check routine, (2) from the field's or form's
initialization or termination hooks, or (3) just after a
<code>REQ_VALIDATION</code> request has been processed by the forms driver
</p>
</div>
</div>

<div id="outline-container-sec-19-3-7" class="outline-4">
<h4 id="sec-19-3-7">18.3.7. Field User Pointer</h4>
<div class="outline-text-4" id="text-19-3-7">
<p>
Every field structure contains one pointer that can be used by the
user for various purposes. It is not touched by forms library and
can be used for any purpose by the user. The following functions
set and fetch user pointer.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_userptr(FIELD *field,
                      char *userptr);   /* the user pointer you wish to associate */
                                        /* with the field                         */

char *field_userptr(FIELD *field);      /* fetch user pointer of the field        */
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-19-3-8" class="outline-4">
<h4 id="sec-19-3-8">18.3.8. Variable-Sized Fields</h4>
<div class="outline-text-4" id="text-19-3-8">
<p>
If you want a dynamically changing field with variable width, this
is the feature you want to put to full use. This will allow the
user to enter more data than the original size of the field and
let the field grow. According to the field orientation it will
scroll horizontally or vertically to incorporate the new data.
</p>

<p>
To make a field dynamically growable, the option <code>O_STATIC</code> should
be turned off. This can be done with a
</p>

<div class="org-src-container">

<pre class="src src-c">field_opts_off(field_pointer, O_STATIC);
</pre>
</div>

<p>
But it's usually not advisable to allow a field to grow
infinitely. You can set a maximum limit to the growth of the field
with
</p>

<div class="org-src-container">

<pre class="src src-c">int set_max_field(FIELD *field,    /* Field on which to operate            */
                  int max_growth); /* maximum growth allowed for the field */
</pre>
</div>

<p>
The field info for a dynamically growable field can be retrieved
by
</p>

<div class="org-src-container">

<pre class="src src-c">int dynamic_field_info( FIELD *field,     /* Field on which to operate                */
                        int   *prows,     /* number of rows will be filled in this    */
                        int   *pcols,     /* number of columns will be filled in this */
                        int   *pmax)      /* maximum allowable growth will be filled  */
                                          /* in this                                  */
</pre>
</div>

<p>
Though <code>field_info</code> work as usual, it is advisable to use this
function to get the proper attributes of a dynamically growable
field.  Recall the library routine <code>new_field</code>; a new field
created with height set to one will be defined to be a one line
field. A new field created with height greater than one will be
defined to be a multi line field.
</p>

<p>
A one line field with <code>O_STATIC</code> turned off (dynamically growable
field) will contain a single fixed row, but the number of columns
can increase if the user enters more data than the initial field
will hold. The number of columns displayed will remain fixed and
the additional data will scroll horizontally.
</p>

<p>
A multi line field with <code>O_STATIC</code> turned off (dynamically
growable field) will contain a fixed number of columns, but the
number of rows can increase if the user enters more data than the
initial field will hold. The number of rows displayed will remain
fixed and the additional data will scroll vertically.
</p>

<p>
The above two paragraphs pretty much describe a dynamically
growable field's behavior. The way other parts of forms library
behaves is described below:
</p>

<ol class="org-ol">
<li>The field option <code>O_AUTOSKIP</code> will be ignored if the option
<code>O_STATIC</code> is off and there is no maximum growth specified for
the field.  Currently, <code>O_AUTOSKIP</code> generates an automatic
<code>REQ_NEXT_FIELD</code> form driver request when the user types in the
last character position of a field. On a growable field with no
maximum growth specified, there is no last character
position. If a maximum growth is specified, the <code>O_AUTOSKIP</code>
option will work as normal if the field has grown to its maximum
size.
</li>

<li>The field justification will be ignored if the option <code>O_STATIC</code>
is off. Currently, <code>set_field_just</code> can be used to
<code>JUSTIFY_LEFT</code>, <code>JUSTIFY_RIGHT</code>, <code>JUSTIFY_CENTER</code> the contents
of a one line field. A growable one line field will, by
definition, grow and scroll horizontally and may contain more
data than can be justified. The return from <code>field_just</code> will be
unchanged.
</li>

<li>The overloaded form driver request <code>REQ_NEW_LINE</code> will operate
the same way regardless of the <code>O_NL_OVERLOAD</code> form option if
the field option <code>O_STATIC</code> is off and there is no maximum
growth specified for the field. Currently, if the form option
<code>O_NL_OVERLOAD</code> is on, <code>REQ_NEW_LINE</code> implicitly generates a
<code>REQ_NEXT_FIELD</code> if called from the last line of a field. If a
field can grow without bound, there is no last line, so
<code>REQ_NEW_LINE</code> will never implicitly generate a
<code>REQ_NEXT_FIELD</code>. If a maximum growth limit is specified and the
<code>O_NL_OVERLOAD</code> form option is on, <code>REQ_NEW_LINE</code> will only
implicitly generate <code>REQ_NEXT_FIELD</code> if the field has grown to
its maximum size and the user is on the last line.
</li>

<li>The library call <code>dup_field</code> will work as usual; it will
duplicate the field, including the current buffer size and
contents of the field being duplicated. Any specified maximum
growth will also be duplicated.
</li>

<li>The library call <code>link_field</code> will work as usual; it will
duplicate all field attributes and share buffers with the field
being linked.  If the <code>O_STATIC</code> field option is subsequently
changed by a field sharing buffers, how the system reacts to an
attempt to enter more data into the field than the buffer will
currently hold will depend on the setting of the option in the
current field.
</li>

<li>The library call <code>field_info</code> will work as usual; the variable
nrow will contain the value of the original call to
<code>new_field</code>. The user should use <code>dynamic_field_info</code>, described
above, to query the current size of the buffer.
</li>
</ol>


<p>
Some of the above points make sense only after explaining form
driver.  We will be looking into that in next few sections.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-19-4" class="outline-3">
<h3 id="sec-19-4">18.4. Form Windows</h3>
<div class="outline-text-3" id="text-19-4">
<p>
The form windows concept is pretty much similar to menu
windows. Every form is associated with a main window and a sub
window. The form main window displays any title or border
associated or whatever the user wishes. Then the sub window
contains all the fields and displays them according to their
position. This gives the flexibility of manipulating fancy form
displaying very easily.
</p>

<p>
Since this is pretty much similar to menu windows, I am providing
an example with out much explanation. The functions are similar and
they work the same way.
</p>

<p>
<a href="ncurses_programs/basics/"><b>Example 28. Form Windows Example</b></a>
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt;form.h&gt;

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color);

int main()
{
  FIELD *field[3];
  FORM  *my_form;
  WINDOW *my_form_win;
  int ch, rows, cols;

  /* Initialize curses */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Initialize few color pairs */
  init_pair(1, COLOR_RED, COLOR_BLACK);

  /* Initialize the fields */
  field[0] = new_field(1, 10, 6, 1, 0, 0);
  field[1] = new_field(1, 10, 8, 1, 0, 0);
  field[2] = NULL;

  /* Set field options */
  set_field_back(field[0], A_UNDERLINE);
  field_opts_off(field[0], O_AUTOSKIP); /* Don't go to next field when this */
  /* Field is filled up         */
  set_field_back(field[1], A_UNDERLINE);
  field_opts_off(field[1], O_AUTOSKIP);

  /* Create the form and post it */
  my_form = new_form(field);

  /* Calculate the area required for the form */
  scale_form(my_form, &amp;rows, &amp;cols);

  /* Create the window to be associated with the form */
  my_form_win = newwin(rows + 4, cols + 4, 4, 4);
  keypad(my_form_win, TRUE);

  /* Set main window and sub window */
  set_form_win(my_form, my_form_win);
  set_form_sub(my_form, derwin(my_form_win, rows, cols, 2, 2));

  /* Print a border around the main window and print a title */
  box(my_form_win, 0, 0);
  print_in_middle(my_form_win, 1, 0, cols + 4, "My Form", COLOR_PAIR(1));

  post_form(my_form);
  wrefresh(my_form_win);

  mvprintw(LINES - 2, 0, "Use UP, DOWN arrow keys to switch between fields");
  refresh();

  /* Loop through to get user requests */
  while((ch = wgetch(my_form_win)) != KEY_F(1))
    {   switch(ch)
        {   case KEY_DOWN:
            /* Go to next field */
            form_driver(my_form, REQ_NEXT_FIELD);
            /* Go to the end of the present buffer */
            /* Leaves nicely at the last character */
            form_driver(my_form, REQ_END_LINE);
            break;
        case KEY_UP:
          /* Go to previous field */
          form_driver(my_form, REQ_PREV_FIELD);
          form_driver(my_form, REQ_END_LINE);
          break;
        default:
          /* If this is a normal character, it gets */
          /* Printed                */
          form_driver(my_form, ch);
          break;
        }
    }

  /* Un post form and free the memory */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}

void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string, chtype color)
{   int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-19-5" class="outline-3">
<h3 id="sec-19-5">18.5. Field Validation</h3>
<div class="outline-text-3" id="text-19-5">
<p>
By default, a field will accept any data input by the user. It is
possible to attach validation to the field. Then any attempt by the
user to leave the field, while it contains data that doesn't match
the validation type will fail. Some validation types also have a
character-validity check for each time a character is entered in
the field.
</p>

<p>
Validation can be attached to a field with the following function.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* field to alter       */
                   FIELDTYPE *ftype,      /* type to associate    */
                   ...);                  /* additional arguments */
</pre>
</div>

<p>
Once set, the validation type for a field can be queried with
</p>

<div class="org-src-container">

<pre class="src src-c">FIELDTYPE *field_type(FIELD *field);      /* field to query       */
</pre>
</div>

<p>
The form driver validates the data in a field only when data is
entered by the end-user. Validation does not occur when
</p>

<ul class="org-ul">
<li>the application program changes the field value by calling
<code>set_field_buffer</code>.
</li>

<li>linked field values are changed indirectly &#x2013; by changing the
field to which they are linked
</li>
</ul>


<p>
The following are the pre-defined validation types. You can also
specify custom validation, though it's a bit tricky and cumbersome.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20"><code>TYPE_ALPHA</code></h2>
<div class="outline-text-2" id="text-20">
<p>
This field type accepts alphabetic data; no blanks, no digits, no
special characters (this is checked at character-entry time). It is
set up with:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* field to alter         */
                   TYPE_ALPHA,            /* type to associate      */
                   int width);            /* maximum width of field */
</pre>
</div>

<p>
The width argument sets a minimum width of data. The user has to
enter at-least width number of characters before he can leave the
field.  Typically you'll want to set this to the field width; if
it's greater than the field width, the validation check will always
fail. A minimum width of zero makes field completion optional.
</p>
</div>
</div>

<div id="outline-container-sec-21" class="outline-2">
<h2 id="sec-21"><code>TYPE_ALNUM</code></h2>
<div class="outline-text-2" id="text-21">
<p>
This field type accepts alphabetic data and digits; no blanks, no
special characters (this is checked at character-entry time). It is
set up with:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* field to alter         */
                   TYPE_ALNUM,            /* type to associate      */
                   int width);            /* maximum width of field */
</pre>
</div>

<p>
The width argument sets a minimum width of data. As with
<code>TYPE_ALPHA</code>, typically you'll want to set this to the field width;
if it's greater than the field width, the validation check will
always fail. A minimum width of zero makes field completion
optional.
</p>
</div>
</div>

<div id="outline-container-sec-22" class="outline-2">
<h2 id="sec-22"><code>TYPE_ENUM</code></h2>
<div class="outline-text-2" id="text-22">
<p>
This type allows you to restrict a field's values to be among a
specified set of string values (for example, the two-letter postal
codes for U.S. states). It is set up with:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* field to alter          */
                   TYPE_ENUM,             /* type to associate       */
                   char **valuelist;      /* list of possible values */
                   int checkcase;         /* case-sensitive?         */
                   int checkunique);      /* must specify uniquely?  */
</pre>
</div>

<p>
The valuelist parameter must point at a NULL-terminated list of
valid strings. The checkcase argument, if true, makes comparison
with the string case-sensitive.
</p>

<p>
When the user exits a <code>TYPE_ENUM</code> field, the validation procedure
tries to complete the data in the buffer to a valid entry. If a
complete choice string has been entered, it is of course valid. But
it is also possible to enter a prefix of a valid string and have it
completed for you.
</p>

<p>
By default, if you enter such a prefix and it matches more than one
value in the string list, the prefix will be completed to the first
matching value. But the checkunique argument, if true, requires
prefix matches to be unique in order to be valid.
</p>

<p>
The <code>REQ_NEXT_CHOICE</code> and <code>REQ_PREV_CHOICE</code> input requests can be
particularly useful with these fields.
</p>
</div>
</div>

<div id="outline-container-sec-23" class="outline-2">
<h2 id="sec-23"><code>TYPE_INTEGER</code></h2>
<div class="outline-text-2" id="text-23">
<p>
This field type accepts an integer. It is set up as follows:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* field to alter          */
                   TYPE_INTEGER,          /* type to associate       */
                   int padding,           /* # places to zero-pad to */
                   int vmin, int vmax);   /* valid range             */
</pre>
</div>

<p>
Valid characters consist of an optional leading minus and
digits. The range check is performed on exit. If the range maximum
is less than or equal to the minimum, the range is ignored.
</p>

<p>
If the value passes its range check, it is padded with as many
leading zero digits as necessary to meet the padding argument.
</p>

<p>
A <code>TYPE_INTEGER</code> value buffer can conveniently be interpreted with
the C library function atoi(3).
</p>
</div>
</div>

<div id="outline-container-sec-24" class="outline-2">
<h2 id="sec-24"><code>TYPE_NUMERIC</code></h2>
<div class="outline-text-2" id="text-24">
<p>
This field type accepts a decimal number. It is set up as follows:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* field to alter        */
                   TYPE_NUMERIC,          /* type to associate     */
                   int padding,           /* # places of precision */
                   int vmin, int vmax);   /* valid range           */
</pre>
</div>

<p>
Valid characters consist of an optional leading minus and digits.
possibly including a decimal point. The range check is performed on
exit. If the range maximum is less than or equal to the minimum, the
range is ignored.
</p>

<p>
If the value passes its range check, it is padded with as many
trailing zero digits as necessary to meet the padding argument.
</p>

<p>
A <code>TYPE_NUMERIC</code> value buffer can conveniently be interpreted with
the C library function atof(3).
</p>
</div>
</div>

<div id="outline-container-sec-25" class="outline-2">
<h2 id="sec-25"><code>TYPE_REGEXP</code></h2>
<div class="outline-text-2" id="text-25">
<p>
This field type accepts data matching a regular expression. It is
set up as follows:
</p>

<div class="org-src-container">

<pre class="src src-c">int set_field_type(FIELD *field,          /* field to alter      */
                   TYPE_REGEXP,           /* type to associate   */
                   char *regexp);         /* expression to match */
</pre>
</div>

<p>
The syntax for regular expressions is that of regcomp(3). The check
for regular-expression match is performed on exit.
</p>
</div>

<div id="outline-container-sec-25-1" class="outline-3">
<h3 id="sec-25-1">18.6. Form Driver: The work horse of the forms system</h3>
<div class="outline-text-3" id="text-25-1">
<p>
As in the menu system, <code>form_driver()</code> plays a very important role
in forms system. All types of requests to forms system should be
funneled through <code>form_driver()</code>.
</p>

<div class="org-src-container">

<pre class="src src-c">int form_driver(FORM *form,     /* form on which to operate     */
                int request)    /* form request code         */
</pre>
</div>

<p>
As you have seen some of the examples above, you have to be in a
loop looking for user input and then decide whether it's a field
data or a form request. The form requests are then passed to
<code>form_driver()</code> to do the work.
</p>

<p>
The requests roughly can be divided into following
categories. Different requests and their usage is explained below:
</p>
</div>


<div id="outline-container-sec-25-1-1" class="outline-4">
<h4 id="sec-25-1-1">18.6.1. Page Navigation Requests</h4>
<div class="outline-text-4" id="text-25-1-1">
<p>
These requests cause page-level moves through the form, triggering
display of a new form screen. A form can be made of multiple
pages. If you have a big form with lot of fields and logical
sections, then you can divide the form into pages. The function
<code>set_new_page()</code> to set a new page at the field specified.
</p>

<div class="org-src-container">

<pre class="src src-c">int set_new_page(FIELD *field,/* Field at which page break to be set or unset */
                 bool new_page_flag); /* should be TRUE to put a break */
</pre>
</div>

<p>
The following requests allow you to move to different pages
</p>

<ul class="org-ul">
<li><code>REQ_NEXT_PAGE</code> Move to the next form page.
</li>

<li><code>REQ_PREV_PAGE</code> Move to the previous form page.
</li>

<li><code>REQ_FIRST_PAGE</code> Move to the first form page.
</li>

<li><code>REQ_LAST_PAGE</code> Move to the last form page.
</li>
</ul>


<p>
These requests treat the list as cyclic; that is, <code>REQ_NEXT_PAGE</code>
from the last page goes to the first, and <code>REQ_PREV_PAGE</code> from the
first page goes to the last.
</p>
</div>
</div>

<div id="outline-container-sec-25-1-2" class="outline-4">
<h4 id="sec-25-1-2">18.6.2. Inter-Field Navigation Requests</h4>
<div class="outline-text-4" id="text-25-1-2">
<p>
These requests handle navigation between fields on the same page.
</p>

<ul class="org-ul">
<li><code>REQ_NEXT_FIELD</code> Move to next field.
</li>

<li><code>REQ_PREV_FIELD</code> Move to previous field.
</li>

<li><code>REQ_FIRST_FIELD</code> Move to the first field.
</li>

<li><code>REQ_LAST_FIELD</code> Move to the last field.
</li>

<li><code>REQ_SNEXT_FIELD</code> Move to sorted next field.
</li>

<li><code>REQ_SPREV_FIELD</code> Move to sorted previous field.
</li>

<li><code>REQ_SFIRST_FIELD</code> Move to the sorted first field.
</li>

<li><code>REQ_SLAST_FIELD</code> Move to the sorted last field.
</li>

<li><code>REQ_LEFT_FIELD</code> Move left to field.
</li>

<li><code>REQ_RIGHT_FIELD</code> Move right to field.
</li>

<li><code>REQ_UP_FIELD</code> Move up to field.
</li>

<li><code>REQ_DOWN_FIELD</code> Move down to field.
</li>
</ul>

<p>
These requests treat the list of fields on a page as cyclic; that
is, <code>REQ_NEXT_FIELD</code> from the last field goes to the first, and
<code>REQ_PREV_FIELD</code> from the first field goes to the last. The order
of the fields for these (and the <code>REQ_FIRST_FIELD</code> and
<code>REQ_LAST_FIELD</code> requests) is simply the order of the field
pointers in the form array (as set up by <code>new_form()</code> or
<code>set_form_fields()</code>
</p>

<p>
It is also possible to traverse the fields as if they had been
sorted in screen-position order, so the sequence goes
left-to-right and top-to-bottom. To do this, use the second group
of four sorted-movement requests.
</p>

<p>
Finally, it is possible to move between fields using visual
directions up, down, right, and left. To accomplish this, use the
third group of four requests. Note, however, that the position of
a form for purposes of these requests is its upper-left corner.
</p>

<p>
For example, suppose you have a multi-line field B, and two
single-line fields A and C on the same line with B, with A to the
left of B and C to the right of B. A <code>REQ_MOVE_RIGHT</code> from A will
go to B only if A, B, and C all share the same first line;
otherwise it will skip over B to C.
</p>
</div>
</div>

<div id="outline-container-sec-25-1-3" class="outline-4">
<h4 id="sec-25-1-3">18.6.3. Intra-Field Navigation Requests</h4>
<div class="outline-text-4" id="text-25-1-3">
<p>
These requests drive movement of the edit cursor within the
currently selected field.
</p>

<ul class="org-ul">
<li><code>REQ_NEXT_CHAR</code> Move to next character.
</li>

<li><code>REQ_PREV_CHAR</code> Move to previous character.
</li>

<li><code>REQ_NEXT_LINE</code> Move to next line.
</li>

<li><code>REQ_PREV_LINE</code> Move to previous line.
</li>

<li><code>REQ_NEXT_WORD</code> Move to next word.
</li>

<li><code>REQ_PREV_WORD</code> Move to previous word.
</li>

<li><code>REQ_BEG_FIELD</code> Move to beginning of field.
</li>

<li><code>REQ_END_FIELD</code> Move to end of field.
</li>

<li><code>REQ_BEG_LINE</code> Move to beginning of line.
</li>

<li><code>REQ_END_LINE</code> Move to end of line.
</li>

<li><code>REQ_LEFT_CHAR</code> Move left in field.
</li>

<li><code>REQ_RIGHT_CHAR</code> Move right in field.
</li>

<li><code>REQ_UP_CHAR</code> Move up in field.
</li>

<li><code>REQ_DOWN_CHAR</code> Move down in field.
</li>
</ul>


<p>
Each word is separated from the previous and next characters by
whitespace. The commands to move to beginning and end of line or
field look for the first or last non-pad character in their
ranges.
</p>
</div>
</div>

<div id="outline-container-sec-25-1-4" class="outline-4">
<h4 id="sec-25-1-4">18.6.4. Scrolling Requests</h4>
<div class="outline-text-4" id="text-25-1-4">
<p>
Fields that are dynamic and have grown and fields explicitly
created with offscreen rows are scrollable. One-line fields scroll
horizontally; multi-line fields scroll vertically. Most scrolling
is triggered by editing and intra-field movement (the library
scrolls the field to keep the cursor visible). It is possible to
explicitly request scrolling with the following requests:
</p>

<ul class="org-ul">
<li><code>REQ_SCR_FLINE</code> Scroll vertically forward a line.
</li>

<li><code>REQ_SCR_BLINE</code> Scroll vertically backward a line.
</li>

<li><code>REQ_SCR_FPAGE</code> Scroll vertically forward a page.
</li>

<li><code>REQ_SCR_BPAGE</code> Scroll vertically backward a page.
</li>

<li><code>REQ_SCR_FHPAGE</code> Scroll vertically forward half a page.
</li>

<li><code>REQ_SCR_BHPAGE</code> Scroll vertically backward half a page.
</li>

<li><code>REQ_SCR_FCHAR</code> Scroll horizontally forward a character.
</li>

<li><code>REQ_SCR_BCHAR</code> Scroll horizontally backward a character.
</li>

<li><code>REQ_SCR_HFLINE</code> Scroll horizontally one field width forward.
</li>

<li><code>REQ_SCR_HBLINE</code> Scroll horizontally one field width backward.
</li>

<li><code>REQ_SCR_HFHALF</code> Scroll horizontally one half field width
forward.
</li>

<li><code>REQ_SCR_HBHALF</code> Scroll horizontally one half field width
backward.
</li>
</ul>


<p>
For scrolling purposes, a page of a field is the height of its
visible part.
</p>
</div>
</div>

<div id="outline-container-sec-25-1-5" class="outline-4">
<h4 id="sec-25-1-5">18.6.5. Editing Requests</h4>
<div class="outline-text-4" id="text-25-1-5">
<p>
When you pass the forms driver an ASCII character, it is treated
as a request to add the character to the field's data
buffer. Whether this is an insertion or a replacement depends on
the field's edit mode (insertion is the default.
</p>

<p>
The following requests support editing the field and changing the
edit mode:
</p>

<ul class="org-ul">
<li><code>REQ_INS_MODE</code> Set insertion mode.
</li>

<li><code>REQ_OVL_MODE</code> Set overlay mode.
</li>

<li><code>REQ_NEW_LINE</code> New line request (see below for explanation).
</li>

<li><code>REQ_INS_CHAR</code> Insert space at character location.
</li>

<li><code>REQ_INS_LINE</code> Insert blank line at character location.
</li>

<li><code>REQ_DEL_CHAR</code> Delete character at cursor.
</li>

<li><code>REQ_DEL_PREV</code> Delete previous word at cursor.
</li>

<li><code>REQ_DEL_LINE</code> Delete line at cursor.
</li>

<li><code>REQ_DEL_WORD</code> Delete word at cursor.
</li>

<li><code>REQ_CLR_EOL</code> Clear to end of line.
</li>

<li><code>REQ_CLR_EOF</code> Clear to end of field.
</li>

<li><code>REQ_CLR_FIELD</code> Clear entire field.
</li>
</ul>

<p>
The behavior of the <code>REQ_NEW_LINE</code> and <code>REQ_DEL_PREV</code> requests is
complicated and partly controlled by a pair of forms options. The
special cases are triggered when the cursor is at the beginning of
a field, or on the last line of the field.
</p>

<p>
First, we consider <code>REQ_NEW_LINE</code>:
</p>

<p>
The normal behavior of <code>REQ_NEW_LINE</code> in insert mode is to break
the current line at the position of the edit cursor, inserting the
portion of the current line after the cursor as a new line
following the current and moving the cursor to the beginning of
that new line (you may think of this as inserting a newline in the
field buffer).
</p>

<p>
The normal behavior of <code>REQ_NEW_LINE</code> in overlay mode is to clear
the current line from the position of the edit cursor to end of
line. The cursor is then moved to the beginning of the next line.
</p>

<p>
However, <code>REQ_NEW_LINE</code> at the beginning of a field, or on the
last line of a field, instead does a
<code>REQ_NEXT_FIELD</code>. <code>O_NL_OVERLOAD</code> option is off, this special
action is disabled.
</p>

<p>
Now, let us consider <code>REQ_DEL_PREV</code>:
</p>

<p>
The normal behavior of <code>REQ_DEL_PREV</code> is to delete the previous
character. If insert mode is on, and the cursor is at the start of
a line, and the text on that line will fit on the previous one, it
instead appends the contents of the current line to the previous
one and deletes the current line (you may think of this as
deleting a newline from the field buffer).
</p>

<p>
However, <code>REQ_DEL_PREV</code> at the beginning of a field is instead
treated as a <code>REQ_PREV_FIELD</code>.
</p>

<p>
If the <code>O_BS_OVERLOAD</code> option is off, this special action is
disabled and the forms driver just returns <code>E_REQUEST_DENIED</code>.
</p>
</div>
</div>

<div id="outline-container-sec-25-1-6" class="outline-4">
<h4 id="sec-25-1-6">18.6.6. Order Requests</h4>
<div class="outline-text-4" id="text-25-1-6">
<p>
If the type of your field is ordered, and has associated functions
for getting the next and previous values of the type from a given
value, there are requests that can fetch that value into the field
buffer:
</p>

<ul class="org-ul">
<li><code>REQ_NEXT_CHOICE</code> Place the successor value of the current value
in the buffer.
</li>

<li><code>REQ_PREV_CHOICE</code> Place the predecessor value of the current
value in the buffer.
</li>
</ul>


<p>
Of the built-in field types, only <code>TYPE_ENUM</code> has built-in
successor and predecessor functions. When you define a field type
of your own (see Custom Validation Types), you can associate our
own ordering functions.
</p>
</div>
</div>

<div id="outline-container-sec-25-1-7" class="outline-4">
<h4 id="sec-25-1-7">18.6.7. Application Commands</h4>
<div class="outline-text-4" id="text-25-1-7">
<p>
Form requests are represented as integers above the curses value
greater than <code>KEY_MAX</code> and less than or equal to the constant
<code>MAX_COMMAND</code>. A value within this range gets ignored by
<code>form_driver()</code>. So this can be used for any purpose by the
application. It can be treated as an application specific action
and take corresponding action.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-26" class="outline-2">
<h2 id="sec-26">19. Tools and Widget Libraries</h2>
<div class="outline-text-2" id="text-26">
<p>
Now that you have seen the capabilities of ncurses and its sister
libraries, you are rolling your sleeves up and gearing for a project
that heavily manipulates screen. But wait.. It can be pretty
difficult to write and maintain complex GUI widgets in plain ncurses
or even with the additional libraries. There are some ready-to-use
tools and widget libraries that can be used instead of writing your
own widgets. You can use some of them, get ideas from the code, or
even extend them.
</p>
</div>

<div id="outline-container-sec-26-1" class="outline-3">
<h3 id="sec-26-1">19.1. CDK (Curses Development Kit)</h3>
<div class="outline-text-3" id="text-26-1">
<p>
In the author's words
</p>

<div class="italic">
<p>
CDK stands for 'Curses Development Kit' and it currently contains
21 ready to use widgets which facilitate the speedy development
of full screen curses programs.
</p>

</div>

<p>
The kit provides some useful widgets, which can be used in your
programs directly. It's pretty well written and the documentation
is very good.  The examples in the examples directory can be a good
place to start for beginners. The CDK can be downloaded from
<a href="http://invisible-island.net/cdk/">http://invisible-island.net/cdk/</a> . Follow the instructions in
README file to install it.
</p>
</div>


<div id="outline-container-sec-26-1-1" class="outline-4">
<h4 id="sec-26-1-1">19.1.1. Widget List</h4>
<div class="outline-text-4" id="text-26-1-1">
<p>
The following is the list of widgets provided with cdk and their
description.
</p>

<pre class="example">
Widget Type           Quick Description
===========================================================================
Alphalist             Allows a user to select from a list of words, with
                      the ability to narrow the search list by typing in a
                      few characters of the desired word.
Buttonbox             This creates a multiple button widget.
Calendar              Creates a little simple calendar widget.
Dialog                Prompts the user with a message, and the user
                      can pick an answer from the buttons provided.
Entry                 Allows the user to enter various types of information.
File Selector         A file selector built from Cdk base widgets. This
                      example shows how to create more complicated widgets
                      using the Cdk widget library.
Graph                 Draws a graph.
Histogram             Draws a histogram.
Item List             Creates a pop up field which allows the user to select
                      one of several choices in a small field. Very useful
                      for things like days of the week or month names.
Label                 Displays messages in a pop up box, or the label can be
                      considered part of the screen.
Marquee               Displays a message in a scrolling marquee.
Matrix                Creates a complex matrix with lots of options.
Menu                  Creates a pull-down menu interface.
Multiple Line Entry   A multiple line entry field. Very useful
                      for long fields. (like a description
                      field)
Radio List            Creates a radio button list.
Scale                 Creates a numeric scale. Used for allowing a user to
                      pick a numeric value and restrict them to a range of
                      values.
Scrolling List        Creates a scrolling list/menu list.
Scrolling Window      Creates a scrolling log file viewer. Can add
                      information into the window while its running.
                      A good widget for displaying the progress of
                      something. (akin to a console window)
Selection List        Creates a multiple option selection list.
Slider                Akin to the scale widget, this widget provides a
                      visual slide bar to represent the numeric value.
Template              Creates a entry field with character sensitive
                      positions. Used for pre-formatted fields like
                      dates and phone numbers.
Viewer                This is a file/information viewer. Very useful
                      when you need to display loads of information.
===========================================================================
</pre>

<p>
A few of the widgets are modified by Thomas Dickey in recent
versions.
</p>
</div>
</div>

<div id="outline-container-sec-26-1-2" class="outline-4">
<h4 id="sec-26-1-2">19.1.2. Some Attractive Features</h4>
<div class="outline-text-4" id="text-26-1-2">
<p>
Apart from making our life easier with readily usable widgets, cdk
solves one frustrating problem with printing multi colored
strings, justified strings elegantly. Special formatting tags can
be embedded in the strings which are passed to CDK functions. For
Example
</p>

<p>
If the string
</p>

<pre class="example">
"&lt;/B/1&gt;This line should have a yellow foreground and a blue
background.&lt;!1&gt;"
</pre>

<p>
given as a parameter to newCDKLabel(), it prints the line with
yellow foreground and blue background. There are other tags
available for justifying string, embedding special drawing
characters etc.. Please refer to the man page <code>cdk_display(3X)</code>
for details. The man page explains the usage with nice examples.
</p>
</div>
</div>

<div id="outline-container-sec-26-1-3" class="outline-4">
<h4 id="sec-26-1-3">19.1.3. Conclusion</h4>
<div class="outline-text-4" id="text-26-1-3">
<p>
All in all, CDK is a well-written package of widgets, which if
used properly can form a strong frame work for developing complex
GUI.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-26-2" class="outline-3">
<h3 id="sec-26-2">19.2. The dialog</h3>
<div class="outline-text-3" id="text-26-2">
<p>
Long long ago, in September 1994, when few people knew linux, Jeff
Tranter wrote an <a href="http://www2.linuxjournal.com/lj-issues/issue5/2807.html">article</a> on dialog in Linux Journal. He starts the
article with these words..
</p>

<div class="italic">
<p>
Linux is based on the Unix operating system, but also features a
number of unique and useful kernel features and application
programs that often go beyond what is available under Unix. One
little-known gem is "dialog", a utility for creating
professional-looking dialog boxes from within shell scripts. This
article presents a tutorial introduction to the dialog utility,
and shows examples of how and where it can be used
</p>

</div>

<p>
As he explains, dialog is a real gem in making professional-looking
dialog boxes with ease. It creates a variety of dialog boxes,
menus, check lists etc.. It is usually installed by default. If
not, you can download it from <a href="http://invisible-island.net/dialog/">Thomas Dickey</a>'s site.
</p>

<p>
The above-mentioned article gives a very good overview of its uses
and capabilites. The man page has more details. It can be used in
variety of situations. One good example is building of linux kernel
in text mode.  Linux kernel uses a modified version of dialog
tailored for its needs.
</p>

<p>
dialog was initially designed to be used with shell scripts. If you
want to use its functionality in a c program, then you can use
libdialog. The documentation regarding this is sparse. Definitive
reference is the dialog.h header file which comes with the
library. You may need to hack here and there to get the required
output. The source is easily customizable. I have used it on a
number of occasions by modifying the code.
</p>
</div>
</div>

<div id="outline-container-sec-26-3" class="outline-3">
<h3 id="sec-26-3">19.3. Perl Curses Modules CURSES::FORM and CURSES::WIDGETS</h3>
<div class="outline-text-3" id="text-26-3">
<p>
The perl module Curses, Curses::Form and Curses::Widgets give
access to curses from perl. If you have curses and basic perl is
installed, you can get these modules from <a href="http://www.cpan.org/modules/01modules.index.html">CPAN All Modules page</a>.
Get the three zipped modules in the Curses category. Once installed
you can use these modules from perl scripts like any other
module. For more information on perl modules see perlmod man
page. The above modules come with good documentation and they have
some demo scripts to test the functionality. Though the widgets
provided are very rudimentary, these modules provide good access to
curses library from perl.
</p>

<p>
Some of my code examples are converted to perl by Anuradha
Ratnaweera and they are available in the <code>perl</code> directory.
</p>

<p>
For more information see man pages Curses(3) , Curses::Form(3) and
Curses::Widgets(3). These pages are installed only when the above
modules are acquired and installed.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-27" class="outline-2">
<h2 id="sec-27">20. Just For Fun !!!</h2>
<div class="outline-text-2" id="text-27">
<p>
This section contains few programs written by me just for fun. They
don't signify a better programming practice or the best way of using
ncurses. They are provided here so as to allow beginners to get
ideas and add more programs to this section. If you have written a
couple of nice, simple programs in curses and want them to included
here, contact <a href="mailto:ppadala@gmail.com">me</a>.
</p>
</div>

<div id="outline-container-sec-27-1" class="outline-3">
<h3 id="sec-27-1">20.1. The Game of Life</h3>
<div class="outline-text-3" id="text-27-1">
<p>
Game of life is a wonder of math. In <a href="http://www.math.com/students/wonders/life/life.html">Paul Callahan</a>'s words
</p>

<pre class="example">
The Game of Life (or simply Life) is not a game in the conventional sense. There
are no players, and no winning or losing. Once the "pieces" are placed in the
starting position, the rules determine everything that happens later.
Nevertheless, Life is full of surprises! In most cases, it is impossible to look
at a starting position (or pattern) and see what will happen in the future. The
only way to find out is to follow the rules of the game.
</pre>

<p>
This program starts with a simple inverted U pattern and shows how
wonderful life works. There is a lot of room for improvement in the
program. You can let the user enter pattern of his choice or even
take input from a file. You can also change rules and play with a
lot of variations. Search on <a href="http://www.google.com">google</a> for interesting information on
game of life.
</p>

<p>
<i>File Path: JustForFun/life.c</i>
</p>
</div>
</div>

<div id="outline-container-sec-27-2" class="outline-3">
<h3 id="sec-27-2">20.2. Magic Square</h3>
<div class="outline-text-3" id="text-27-2">
<p>
Magic Square, another wonder of math, is very simple to understand
but very difficult to make. In a magic square sum of the numbers in
each row, each column is equal. Even diagnol sum can be
equal. There are many variations which have special properties.
</p>

<p>
This program creates a simple magic square of odd order.
</p>

<p>
<i>File Path: JustForFun/magic.c</i>
</p>
</div>
</div>

<div id="outline-container-sec-27-3" class="outline-3">
<h3 id="sec-27-3">20.3. Towers of Hanoi</h3>
<div class="outline-text-3" id="text-27-3">
<p>
The famous towers of hanoi solver. The aim of the game is to move
the disks on the first peg to last peg, using middle peg as a
temporary stay. The catch is not to place a larger disk over a
small disk at any time.
</p>

<p>
<i>File Path: JustForFun/hanoi.c</i>
</p>
</div>
</div>

<div id="outline-container-sec-27-4" class="outline-3">
<h3 id="sec-27-4">20.4. Queens Puzzle</h3>
<div class="outline-text-3" id="text-27-4">
<p>
The objective of the famous N-Queen puzzle is to put N queens on a
N X N chess board without attacking each other.
</p>

<p>
This program solves it with a simple backtracking technique.
</p>

<p>
<i>File Path: JustForFun/queens.c</i>
</p>
</div>
</div>

<div id="outline-container-sec-27-5" class="outline-3">
<h3 id="sec-27-5">20.5. Shuffle</h3>
<div class="outline-text-3" id="text-27-5">
<p>
A fun game, if you have time to kill.
</p>

<p>
<i>File Path: JustForFun/shuffle.c</i>
</p>
</div>
</div>

<div id="outline-container-sec-27-6" class="outline-3">
<h3 id="sec-27-6">20.6. Typing Tutor</h3>
<div class="outline-text-3" id="text-27-6">
<p>
A simple typing tutor, I created more out of need than for ease of
use.  If you know how to put your fingers correctly on the
keyboard, but lack practice, this can be helpful.
</p>

<p>
<i>File Path: JustForFun/tt.c</i>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-28" class="outline-2">
<h2 id="sec-28">21. References</h2>
<div class="outline-text-2" id="text-28">
<ul class="org-ul">
<li>NCURSES man pages
</li>

<li>NCURSES FAQ at
<a href="http://invisible-island.net/ncurses/ncurses.faq.html">http://invisible-island.net/ncurses/ncurses.faq.html</a>
</li>

<li>Writing programs with NCURSES by Eric Raymond and Zeyd M. Ben-Halim
at <a href="http://invisible-island.net/ncurses/ncurses-intro.html">http://invisible-island.net/ncurses/ncurses-intro.html</a> -
somewhat obsolete. I was inspired by this document and the structure
of this HOWTO follows from the original document
</li>
</ul>
</div>
</div>
</div>
</body>
</html>
